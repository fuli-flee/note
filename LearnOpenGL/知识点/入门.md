[toc]
***
# 一. 基础概念

## 1.1 OpenGL
[OpenGL规范文档](https://registry.khronos.org/OpenGL/specs/gl/glspec33.core.pdf)

OpenGL到底是什么。一般它被认为是一个API
包含了一系列可以操作图形、图像的函数。
然而，OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范
OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定

### 1.1.1 核心模式与立即渲染模式

- **早期 OpenGL 采用立即渲染模式**（固定渲染管线），虽易于使用理解，但效率低且开发者对 OpenGL 计算的控制自由度小。
- 从 OpenGL3.2 开始，规范弃用立即渲染模式，鼓励使用核心模式。**核心模式使用现代函数**，虽学习难度大，但灵活性、效率更高，能让开发者更深入理解图形编程，且本教程面向 OpenGL3.3 核心模式，因为更高版本 OpenGL 是在其基础上引入额外功能，核心架构未变。
- 另外，使用新版本 OpenGL 特性需新一代显卡支持，所以多数开发者基于较低版本编写程序，仅提供启用新版本特性的选项。

## 1.2 GLFW
GLFW 是一个帮你搞定 OpenGL 「底层环境」的工具库

它替你解决「创建窗口、处理键盘 / 鼠标输入、管理显卡上下文、控制帧率」这些和 OpenGL 核心渲染无关，但又必须做的基础工作。

## 1.3 GLAD
因为OpenGL只是一个标准/规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。

开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。

而GLAD就是简化这个过程的, 所以在调用任何OpenGL的函数之前我们需要初始化GLAD。

***
# 二. 创建窗口

## 2.1 双缓冲(Double Buffer)

应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。

***
# 三. 创建三角形


## 3.1 图形渲染管线

处理3D坐标转为2D坐标

图形渲染管线可以被划分为两个主要部分：
- 第一部分把你的3D坐标转换为2D坐标，
- 第二部分是把2D坐标转变为实际的有颜色的像素。

2D坐标和像素也是不同的:
- 2D坐标精确表示一个点在2D空间中的位置，
- 而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。

图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分。
<center>

![alt text](/LearnOpenGL/图片/入门/LearnOpenGL11-19_16-28-36.jpg)

</center>

### 3.1.1 图元
告诉 OpenGL 如何 “解读” 你传入的顶点数据，是按 “点”、“线” 还是 “三角形” 来组装渲染。

举个简单一点的例子, 比如你有 3 个顶点：A (0,0)、B (1,0)、C (0.5,1)
- 选图元 `GL_POINTS`（点）：屏幕上显示 3 个独立的点；
- 选图元 `GL_LINES`（线段）：按顺序两两配对（A-B、C 多余不显示），显示 1 条线；
- 选图元 `GL_LINE_LOOP`（线环）：两两配对且首尾相连（A-B、B-C、C-A），显示一个三角形的轮廓；
- 选图元 `GL_TRIANGLES`（三角形）：三个顶点组成一个三角形（A-B-C），显示一个实心三角形。

### 3.1.2 顶点着色器
它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。

### 3.1.3 几何着色器
顶点着色器阶段的输出可以选择性地传递给几何着色器

然后将这些顶点形成图元, 并且能够通过发出新的顶点来形成新的(或其他)图元来生成其他形状。

也就是说几何着色器可以通过代码逻辑 “凭空” 生成新顶点，再把这些新顶点和原始顶点（或纯新顶点）组合成新的图元，最终渲染出原本没有的形状。

举个例子: 把 “点” 变成 “正方形”
- 假设顶点着色器只输出 1 个顶点（图元类型是 “点”），几何着色器接收这个点后：
    - 以这个原始点为 “中心”，新增 3 个顶点, 这3个点你爱咋写咋写, 这个规矩是你用代码定的（比如原始点坐标是 (0,0,0)，新增 (1,1,0)、(-1,1,0)、(-1,-1,0)）；
    - 把 “原始点 + 3 个新增顶点” 组合成 2 个三角形（正方形由 2 个三角形拼成）；
    - 输出这 2 个三角形图元。

### 3.1.4 图元装配
将顶点着色器（或几何着色器）输出的所有顶点作为输入，并将所有的点装配成指定图元的形状；本节例子中是两个三角形。

### 3.1.5 片段着色器
主要目的是计算一个像素的最终颜色

***

## 3.2 顶点输入
OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理它。所有在这个范围内的坐标叫做**标准化设备坐标(Normalized Device Coordinates, NDC)**，此范围内的坐标最终显示在屏幕上

### 3.2.1标准化设备坐标（NDC）
NDC 是 3D 渲染管线中介于裁剪空间和屏幕空间之间的中间坐标，核心特点是「设备无关、范围固定」

把 “不同摄像机参数（如视场角、近远平面）、不同屏幕尺寸” 的渲染需求，统一到一个固定范围的坐标系统中，方便后续映射到具体屏幕。

> NDC就是将不同摄像机的视锥体给 "压扁" 成了一个立方体

### 3.2.2 屏幕空间坐标

屏幕空间坐标是 **最终用于渲染的物理像素坐标**，由 NDC 经过「视口变换」得到，核心特点是「设备相关、对应像素位置」

告诉 GPU “每个顶点应该渲染到屏幕的哪个像素位置”，是和具体显示设备绑定的坐标

> 屏幕空间坐标就是 NDC 立方体映射到屏幕像素

我们把以上概念类比为“拍照流程”
- NDC 立方体：你拍的照片是 “平面的”，但拍摄范围是 “立体的”——NDC 就相当于把这个 “立体的视锥体”按比例压缩、拉平，变成一个 “标准的正方体盒子”（范围 [-1,1]³）。
- 屏幕空间坐标：这个 “NDC 正方体” 就像一张 “标准尺寸的底片”，而 `glViewport` 就是 “洗照片的相纸规格”（比如 1920×1080 像素）

再加深一下印象: 屏幕空间坐标是 “NDC 里的所有点（不管是近平面还是远平面的点）”，都会被映射到屏幕的像素上。

### 3.2.3 顶点缓冲对象
顶点着色器, 它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。

我们通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。

显卡管理给定的数据的形式:
- GL_STATIC_DRAW ：数据不会或几乎不会改变。
- GL_DYNAMIC_DRAW：数据会被改变很多。
- GL_STREAM_DRAW ：数据每次绘制时都会改变。

## 3.3 绘制一个物体的基本流程
现代OpenGL需要我们至少设置一个**顶点着色器**和一个**片段着色器**。
当学完顶点输入, 顶点着色器, 编译着色器, 片元着色器, 链接顶点属性后
就可得知绘制在屏幕上绘制一个顶点的基本流程为
```cpp
// 0. 复制顶点数组到缓冲中供OpenGL使用
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

// 1. 设置顶点属性指针
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);

// 2. 当我们渲染一个物体时要使用着色器程序
glUseProgram(shaderProgram);

// 3. 绘制物体
一些绘制物体的函数();
```

## 3.4 顶点数组对象
OpenGL 中的一个 状态对象，作用是 “缓存” 顶点数据的 “解释规则” 和 VBO 的绑定关系，避免每次渲染都重复设置这些规则

- 不存顶点数据本身，只存 “配置状态”；
- 是现代 OpenGL 核心模式的 必需项（没有 VAO 无法渲染，早期固定管线不需要）；
- 一个 VAO 可以对应一个或多个 VBO（比如一个 VBO 存坐标，另一个存颜色，VAO 记录这两个 VBO 的解析规则）。

```cpp
// 步骤1：创建 VBO 并传入顶点数据（CPU → GPU 显存）
1. 生成 VBO 对象（glGenBuffers）；
2. 绑定 VBO 到目标（glBindBuffer(GL_ARRAY_BUFFER, vbo)）；
3. 把 CPU 中的顶点数据复制到 VBO（glBufferData）；
   （此时 VBO 里有数据，但 OpenGL 不知道怎么解析）

// 步骤2：创建 VAO 并记录解析规则
1. 生成 VAO 对象（glGenVertexArrays）；
2. 绑定 VAO（glBindVertexArray(vao)）—— 这一步是关键！
   （绑定后，后续所有“顶点属性配置”都会被 VAO 记录）
3. 绑定要使用的 VBO（如果之前没绑定）；
4. 配置顶点属性指针（glVertexAttribPointer）：
   - 告诉 OpenGL：“VBO 里第 N 个属性（比如坐标是属性0），
     每个属性占几个分量（比如3个float对应x/y/z），
     数据类型是什么（float），是否归一化，
     每个顶点的总字节数（步长），
     该属性在顶点数据中的偏移量（比如坐标从0字节开始，颜色从12字节开始）；
5. 启用该顶点属性（glEnableVertexAttribArray）；
6. （可选）解绑 VBO 和 VAO（不影响已记录的状态）；
```

**总结:**
- **一个 VAO 可以关联多个 VBO**：比如 VBO1 存坐标，VBO2 存颜色，VAO 会记录 “哪个属性对应哪个 VBO” 以及各自的解析规则。
- **VBO 可以被多个 VAO 共用**：比如多个模型用相同的顶点坐标（同一个 VBO），但颜色 / 纹理不同（不同解析规则），可以用多个 VAO 关联同一个 VBO；
- VBO 负责 “把顶点数据搬到 GPU 存着”，VAO 负责 “记着怎么用这些数据”

## 3.5 元素缓冲对象
也叫索引缓冲对象(Index Buffer Object，IBO)
EBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储 OpenGL 用来决定要绘制哪些顶点的索引。

***
# 四. 着色器
着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。
着色器是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。

## 4.1 GLSL
着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。

一个典型的着色器有下面的结构：
```glsl
#version version_number
in type in_variable_name;
in type in_variable_name;

out type out_variable_name;

uniform type uniform_name;

void main()
{
  // 处理输入并进行一些图形操作
  ...
  // 输出处理过的结果到输出变量
  out_variable_name = weird_stuff_we_processed;
}
```

### 4.1.1 数据类型
特殊的, 向量(Vector)和矩阵(Matrix)

**向量:**
|类型	|含义|
|---|---|
|vecn	|包含n个float分量的默认向量|
|bvecn|	包含n个bool分量的向量|
|ivecn|	包含n个int分量的向量|
|uvecn|	包含n个unsigned int分量的向量|
|dvecn|	包含n个double分量的向量|

**向量重组**
一个向量的分量可以通过`vec.x`这种方式获取，这里x是指这个向量的第一个分量。你可以分别使用`.x`、`.y`、`.z`和`.w`来获取它们的第1、2、3、4个分量。GLSL也允许你对颜色使用`rgba`，或是对纹理坐标使用`stpq`访问相同的分量。
```glsl
vec2 someVec;
vec4 differentVec = someVec.xyxx;
vec3 anotherVec = differentVec.zyw;
vec4 otherVec = someVec.xxxx + anotherVec.yxzy;
```
## 4.2 输入输出
每个着色器之间只能通过输入输出进行交流
GLSL定义了`in`和`out`关键字专门来实现这个目的。
每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但在顶点和片段着色器中会有点不同。

**顶点着色器**
一个顶点可以包含多个信息: 位置, 颜色, 纹理坐标, 法线等
而它们在内存上是连续的, 我们想要高效的读取相应信息就需要指定顶点属性位置 
为了定义顶点数据该如何管理，我们使用location这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。
```glsl
// 顶点着色器
#version 330 core

// 直接在GLSL中指定位置
// location = ? 这个数字你可以随便定, 
// 只要 “着色器里的 location” 和 “CPU 端配置” 一一对应，
// 且每个属性用唯一数字就行。
layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aColor;
layout(location = 2) in vec2 aTexCoord;

out vec3 ourColor;
out vec2 TexCoord;

void main()
{
    gl_Position = vec4(aPos, 1.0);
    ourColor = aColor;
    TexCoord = aTexCoord;
}
```

## 4.3 Uniform
Uniform是另一种从我们的应用程序在 CPU 上传递数据到 GPU 上的着色器的方式

但uniform是全局的, 也就意味着
- uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问 
- 无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。

> 如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它，这可能导致一些非常麻烦的错误，


注意:
- 查询uniform地址不要求你之前使用过着色器程序，
- 但是更新一个uniform之前你必须先使用程序(调用glUseProgram)，因为它是在当前激活的着色器程序中设置uniform的。
***
# 五. 纹理
为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个**纹理坐标**(Texture Coordinate)


纹理坐标在x和y轴上，范围为0到1之间（注意我们使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做**采样**(Sampling)。纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终止于(1, 1)，即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。
<center>

![alt text](/LearnOpenGL/图片/入门/LearnOpenGL11-22_10-22-18.jpg)

</center>

## 5.1 纹理环绕方式

纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像（我们基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择：


|环绕方式	|描述|
|:---:|---|
|GL_REPEAT|	对纹理的默认行为。重复纹理图像。|
|GL_MIRRORED_REPEAT	|和GL_REPEAT一样，但每次重复图片是镜像放置的。|
|GL_CLAMP_TO_EDGE	|纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。|
|GL_CLAMP_TO_BORDER|	超出的坐标为用户指定的边缘颜色。|

<center>

![alt text](/LearnOpenGL/图片/入门/LearnOpenGL11-22_10-26-42.jpg)

</center>

## 5.2 纹理过滤
纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel)映射到纹理坐标

当你有一个很大的物体但是纹理的分辨率很低的时候, 就可以使用纹理过滤

**其中重要的两个:GL_NEAREST和GL_LINEAR。**

- GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）:
<center>

![alt text](/LearnOpenGL/图片/入门/LearnOpenGL11-22_10-47-45.jpg)

</center>

- GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）
<center>

![alt text](/LearnOpenGL/图片/入门/LearnOpenGL11-22_10-48-02.jpg)

</center>

邻近过滤更加"棱角分明", 适合做8-bit风格
线性过滤更加平滑, 可以得到更加真实的输出
<center>

![alt text](/LearnOpenGL/图片/入门/LearnOpenGL11-22_10-51-42.jpg)

</center>

## 5.3 Mipmap
多级渐远纹理, 它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。那么Mipmap对于内存的额外开销极限为1/3
<center>

![alt text](/LearnOpenGL/图片/入门/LearnOpenGL11-22_10-58-17.jpg)

</center>

**Mipmap主要是使用在纹理被缩小的情况下的：纹理放大不会使用Mipmap**

## 5.3 纹理单元

一个纹理的位置值通常称为一个纹理单元(Texture Unit)。一个纹理的默认纹理单元是0，它是默认的激活纹理单元。

纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器，我们可以一次绑定多个纹理，只要我们首先激活对应的纹理单元。


OpenGL要求y轴`0.0`坐标是在图片的底部的，但是图片的y轴`0.0`坐标通常在顶部。所以正常输出的图片都是上下翻转的, 使用以下代码即可
```glsl
stbi_set_flip_vertically_on_load(true);
```

***
# 六. 变换

## 6.1 向量

### 6.1.1 点乘
两个向量的点乘等于它们的数乘结果乘以两个向量之间夹角的余弦值。

$$\bar{v}\cdot\bar{k}=||\bar{v}||\cdot||\bar{k}||\cdot\cos\theta$$

所以要计算两个单位向量间的夹角，我们可以使用反余弦函数$cos^{-1}$


### 6.1.2 叉乘
叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。

$$\begin{pmatrix}
A_x \\
A_y \\
A_z
\end{pmatrix}\times
\begin{pmatrix}
B_x \\
B_y \\
B_z
\end{pmatrix}=
\begin{pmatrix}
A_y\cdot B_z-A_z\cdot B_y \\
A_z\cdot B_x-A_x\cdot B_z \\
A_x\cdot B_y-A_y\cdot B_x
\end{pmatrix}$$

## 6.2 矩阵

### 6.2.1 缩放
$$\begin{bmatrix}S_1&0&0&0\\0&S_2&0&0\\0&0&S_3&0\\0&0&0&1\end{bmatrix}\cdot\begin{pmatrix}x\\y\\z\\1\end{pmatrix}=\begin{pmatrix}S_1\cdot x\\S_2\cdot y\\S_3\cdot z\\1\end{pmatrix}$$

### 6.2.2 位移
$$\begin{bmatrix}1&0&0&T_x\\0&1&0&T_y\\0&0&1&T_z\\0&0&0&1\end{bmatrix}\cdot\begin{pmatrix}x\\y\\z\\1\end{pmatrix}=\begin{pmatrix}x+T_x\\y+T_y\\z+T_z\\1\end{pmatrix}$$

**齐次坐标(Homogeneous Coordinates)**

向量的w分量也叫齐次坐标。想要从齐次向量得到3D向量，我们可以把x、y和z坐标分别除以w坐标。我们通常不会注意这个问题，因为w分量通常是1.0。使用齐次坐标有几点好处：它允许我们在3D向量上进行位移（如果没有w分量我们是不能位移向量的）

如果一个向量的齐次坐标是0，这个坐标就是方向向量(Direction Vector)，因为w坐标是0，这个向量就不能位移（译注：这也就是我们说的不能位移一个方向）。

### 6.2.3 旋转

弧度转角度：`角度 = 弧度 * (180.0f / PI)`
角度转弧度：`弧度 = 角度 * (PI / 180.0f)`

1. 沿x轴旋转：
$$\begin{bmatrix}1&0&0&0\\0&\cos\theta&-\sin\theta&0\\0&\sin\theta&\cos\theta&0\\0&0&0&1\end{bmatrix}\cdot\begin{pmatrix}x\\y\\z\\1\end{pmatrix}=\begin{pmatrix}x\\\cos\theta\cdot y-\sin\theta\cdot z\\\sin\theta\cdot y+\cos\theta\cdot z\\1\end{pmatrix}$$

2. 沿y轴旋转：
$$\begin{bmatrix}\cos\theta&0&\sin\theta&0\\0&1&0&0\\-\sin\theta&0&\cos\theta&0\\0&0&0&1\end{bmatrix}\cdot\begin{pmatrix}x\\y\\z\\1\end{pmatrix}=\begin{pmatrix}\cos\theta\cdot x+\sin\theta\cdot z\\y\\-\sin\theta\cdot x+\cos\theta\cdot z\\1\end{pmatrix}$$

3. 沿z轴旋转：
$$\begin{bmatrix}\cos\theta&-\sin\theta&0&0\\\sin\theta&\cos\theta&0&0\\0&0&1&0\\0&0&0&1\end{bmatrix}\cdot\begin{pmatrix}x\\y\\z\\1\end{pmatrix}=\begin{pmatrix}\cos\theta\cdot x-\sin\theta\cdot y\\\sin\theta\cdot x+\cos\theta\cdot y\\z\\1\end{pmatrix}$$

这里会存在万向节死锁

## 6.3 矩阵的组合
当矩阵相乘时我们**先写位移再写缩放变换**的。矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。
当矩阵相乘时，在最右边的矩阵是第一个与向量相乘的, 所以阅读矩阵相乘时的顺序是从右往左

**例如:**
$$Trans.Scale=\begin{bmatrix}1&0&0&1\\0&1&0&2\\0&0&1&3\\0&0&0&1\end{bmatrix}.\begin{bmatrix}2&0&0&0\\0&2&0&0\\0&0&2&0\\0&0&0&1\end{bmatrix}=\begin{bmatrix}2&0&0&1\\0&2&0&2\\0&0&2&3\\0&0&0&1\end{bmatrix}$$
</br>

向量先缩放2倍，然后位移了(1, 2, 3)个单位
$$\begin{bmatrix}2&0&0&1\\0&2&0&2\\0&0&2&3\\0&0&0&1\end{bmatrix}.\begin{bmatrix}x\\y\\z\\1\end{bmatrix}=\begin{bmatrix}2x+1\\2y+2\\2z+3\\1\end{bmatrix}$$

***
# 七. 坐标系统
比较重要的5个不同的坐标系统：

- 局部空间(Local Space，或者称为物体空间(Object Space))
- 世界空间(World Space)
- 观察空间(View Space，或者称为视觉空间(Eye Space))
- 裁剪空间(Clip Space)
- 屏幕空间(Screen Space)

为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是 **模型(Model)、观察(View)、投影(Projection)** 三个矩阵。我们的顶点坐标起始于**局部空间(Local Space)**，在这里它称为**局部坐标(Local Coordinate)**，它在之后会变为**世界坐标(World Coordinate)**，**观察坐标(View Coordinate)**，**裁剪坐标(Clip Coordinate)**，并最后以**屏幕坐标(Screen Coordinate)**的形式结束。

<center>

![alt text](/LearnOpenGL/图片/入门/LearnOpenGL11-24_18-54-12.jpg)

</center>

1. **局部坐标**是对象相对于局部原点的坐标，也是**物体起始的坐标**。
2. 下一步是将局部坐标变换为世界空间坐标，**世界空间坐标**是处于一个更大的空间范围的。这些坐标相对于**世界的全局原点**，它们会和其它物体一起相对于世界的原点进行摆放。
3. 接下来我们将世界坐标变换为**观察空间坐标**，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。
4. 坐标到达观察空间之后，我们需要将其投影到**裁剪坐标**。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。
5. 最后，我们将裁剪坐标变换为**屏幕坐标**，我们将使用一个叫做**视口变换**(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。

我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如: 
- 当需要对物体进行修改的时候，在局部空间中来操作会更说得通；
- 如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。

## 7.1 局部空间
局部空间是指物体所在的坐标空间，即对象最开始所在的地方。

## 7.2 世界空间
世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由 **模型矩阵(Model Matrix)** 实现的。模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。

## 7.3 观察空间
观察空间经常被人们称之OpenGL的**摄像机(Camera)**（所以有时也称为**摄像机空间(Camera Space)** 或视觉空间(Eye Space)）。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个**观察矩阵(View Matrix)** 里，它被用来将世界坐标变换到观察空间。

## 7.4 裁剪空间
在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是**裁剪空间(Clip Space)**名字的由来。
为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个**投影矩阵(Projection Matrix)**，它指定了一个范围的坐标

## 7.5 透视投影
透视投影矩阵将给定的视锥体范围映射到裁剪空间，除此之外还修改了每个顶点坐标的w值，从而使得离观察者越远的顶点坐标w分量越大。被变换到裁剪空间的坐标都会在-w到w的范围之间（任何大于这个范围的坐标都会被裁剪掉）。OpenGL要求所有可见的坐标都落在-1.0到1.0范围内，作为顶点着色器最后的输出，因此，一旦坐标在裁剪空间内之后，透视除法就会被应用到裁剪空间坐标上：
$$out=\begin{pmatrix}x/w\\y/w\\z/w\end{pmatrix}$$

**透视投影的视锥体:**
<center>

![alt text](/LearnOpenGL/图片/入门/LearnOpenGL11-25_11-10-04.jpg)

</center>

**名词解释**
Fov: 视野
aspect_ratio: 宽高比


**注意:** 
这里讲一个容易理解的错误的地方, 上图蓝色和绿色的fov是一样的, 用等比很容易证明

## 7.6 MVP变换
$$V_{clip}=M_{projection}\cdot M_{view}\cdot M_{model}\cdot V_{local}$$

## 7.7 深度缓冲
又称为**Z-buffer**
GLFW会自动为你生成这样一个缓冲（就像它也有一个颜色缓冲来存储输出图像的颜色）。深度值存储在每个片段里面（作为片段的z值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为**深度测试(Depth Testing)**，它是由OpenGL自动完成的。
***
# 八. 摄像机
当我们讨论摄像机/观察空间(Camera/View Space)的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。要定义一个摄像机，我们需要它在世界空间中的**位置**、**观察的方向**、一个指向它**右侧的向量**以及一个指向它**上方的向量**。


**格拉姆—施密特正交化(Gram-Schmidt Process)**
<center>

![alt text](/LearnOpenGL/图片/入门/LearnOpenGL11-25_15-15-00.jpg)

</center>

## 8.1 LookAt
如果你使用3个相互垂直（或非线性）的轴定义了一个坐标空间，你可以用这3个轴外加一个平移向量来创建一个矩阵，并且你可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。这正是LookAt矩阵所做的，现在我们有了3个相互垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建我们自己的LookAt矩阵了：

$$LookAt=\begin{bmatrix}R_x&R_y&R_z&0\\U_x&U_y&U_z&0\\D_x&D_y&D_z&0\\0&0&0&1\end{bmatrix}*\begin{bmatrix}1&0&0&-P_x\\0&1&0&-P_y\\0&0&1&-P_z\\0&0&0&1\end{bmatrix}$$

其中**R是右向量**，**U是上向量**，**D是方向向量**, **P是摄像机位置向量**。注意，位置向量是相反的，因为我们最终希望把世界平移到与我们自身移动的相反方向。把这个LookAt矩阵作为观察矩阵可以很高效地把所有世界坐标变换到刚刚定义的观察空间。

## 8.2 Deltatime
目前我们的移动速度是个常量。理论上没什么问题，但是实际情况下根据处理器的能力不同，有些人可能会比其他人每秒绘制更多帧, 结果就是，根据配置的不同，有些人可能移动很快，而有些人会移动很慢。当你发布你的程序的时候，你必须确保它在所有硬件上移动速度都一样。

图形程序和游戏通常会跟踪一个**时间差(Deltatime)**变量，它储存了渲染上一帧所用的时间。我们把所有速度都去乘以deltaTime值。结果就是，如果我们的deltaTime很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高来平衡渲染所花去的时间。使用这种方法时，无论你的电脑快还是慢，摄像机的速度都会相应平衡，这样每个用户的体验就都一样了。

## 8.3 欧拉角
欧拉角(Euler Angle)是可以表示3D空间中任何旋转的3个值，一共有3种欧拉角：
- 俯仰角(Pitch)
- 偏航角(Yaw)
- 滚转角(Roll)
<center>

![alt text](/LearnOpenGL/图片/入门/LearnOpenGL11-25_16-33-21.jpg)

</center>

**俯仰角:**
<center>

![alt text](/LearnOpenGL/图片/入门/LearnOpenGL11-25_16-40-21.jpg)

</center>

**偏航角:**
<center>

![alt text](/LearnOpenGL/图片/入门/LearnOpenGL11-25_16-40-40.jpg)

</center>
