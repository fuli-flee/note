[toc]
***
# 一. 基础概念

## 1.1 OpenGL
[OpenGL规范文档](https://registry.khronos.org/OpenGL/specs/gl/glspec33.core.pdf)

OpenGL到底是什么。一般它被认为是一个API
包含了一系列可以操作图形、图像的函数。
然而，OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范
OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定

### 1.1.1 核心模式与立即渲染模式

- **早期 OpenGL 采用立即渲染模式**（固定渲染管线），虽易于使用理解，但效率低且开发者对 OpenGL 计算的控制自由度小。
- 从 OpenGL3.2 开始，规范弃用立即渲染模式，鼓励使用核心模式。**核心模式使用现代函数**，虽学习难度大，但灵活性、效率更高，能让开发者更深入理解图形编程，且本教程面向 OpenGL3.3 核心模式，因为更高版本 OpenGL 是在其基础上引入额外功能，核心架构未变。
- 另外，使用新版本 OpenGL 特性需新一代显卡支持，所以多数开发者基于较低版本编写程序，仅提供启用新版本特性的选项。

## 1.2 GLFW
GLFW 是一个帮你搞定 OpenGL 「底层环境」的工具库

它替你解决「创建窗口、处理键盘 / 鼠标输入、管理显卡上下文、控制帧率」这些和 OpenGL 核心渲染无关，但又必须做的基础工作。

## 1.3 GLAD
因为OpenGL只是一个标准/规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。

开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。

而GLAD就是简化这个过程的, 所以在调用任何OpenGL的函数之前我们需要初始化GLAD。

***
# 二. 创建窗口

## 2.1 双缓冲(Double Buffer)

应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。

***
# 三. 创建三角形


## 3.1 图形渲染管线

处理3D坐标转为2D坐标

图形渲染管线可以被划分为两个主要部分：
- 第一部分把你的3D坐标转换为2D坐标，
- 第二部分是把2D坐标转变为实际的有颜色的像素。

2D坐标和像素也是不同的:
- 2D坐标精确表示一个点在2D空间中的位置，
- 而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。

图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分。
<center>

![alt text](/LearnOpenGL/图片/LearnOpenGL11-19_16-28-36.jpg)

</center>

### 3.1.1 图元
告诉 OpenGL 如何 “解读” 你传入的顶点数据，是按 “点”、“线” 还是 “三角形” 来组装渲染。

举个简单一点的例子, 比如你有 3 个顶点：A (0,0)、B (1,0)、C (0.5,1)
- 选图元 `GL_POINTS`（点）：屏幕上显示 3 个独立的点；
- 选图元 `GL_LINES`（线段）：按顺序两两配对（A-B、C 多余不显示），显示 1 条线；
- 选图元 `GL_LINE_LOOP`（线环）：两两配对且首尾相连（A-B、B-C、C-A），显示一个三角形的轮廓；
- 选图元 `GL_TRIANGLES`（三角形）：三个顶点组成一个三角形（A-B-C），显示一个实心三角形。

### 3.1.2 顶点着色器
它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。

### 3.1.3 几何着色器
顶点着色器阶段的输出可以选择性地传递给几何着色器

然后将这些顶点形成图元, 并且能够通过发出新的顶点来形成新的(或其他)图元来生成其他形状。

也就是说几何着色器可以通过代码逻辑 “凭空” 生成新顶点，再把这些新顶点和原始顶点（或纯新顶点）组合成新的图元，最终渲染出原本没有的形状。

举个例子: 把 “点” 变成 “正方形”
- 假设顶点着色器只输出 1 个顶点（图元类型是 “点”），几何着色器接收这个点后：
    - 以这个原始点为 “中心”，新增 3 个顶点, 这3个点你爱咋写咋写, 这个规矩是你用代码定的（比如原始点坐标是 (0,0,0)，新增 (1,1,0)、(-1,1,0)、(-1,-1,0)）；
    - 把 “原始点 + 3 个新增顶点” 组合成 2 个三角形（正方形由 2 个三角形拼成）；
    - 输出这 2 个三角形图元。

### 3.1.4 图元装配
将顶点着色器（或几何着色器）输出的所有顶点作为输入，并将所有的点装配成指定图元的形状；本节例子中是两个三角形。

### 3.1.5 片段着色器
主要目的是计算一个像素的最终颜色

***

## 3.2 顶点输入
OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理它。所有在这个范围内的坐标叫做**标准化设备坐标(Normalized Device Coordinates, NDC)**，此范围内的坐标最终显示在屏幕上

### 3.2.1标准化设备坐标（NDC）
NDC 是 3D 渲染管线中介于裁剪空间和屏幕空间之间的中间坐标，核心特点是「设备无关、范围固定」

把 “不同摄像机参数（如视场角、近远平面）、不同屏幕尺寸” 的渲染需求，统一到一个固定范围的坐标系统中，方便后续映射到具体屏幕。

> NDC就是将不同摄像机的视锥体给 "压扁" 成了一个立方体

### 3.2.2 屏幕空间坐标

屏幕空间坐标是 **最终用于渲染的物理像素坐标**，由 NDC 经过「视口变换」得到，核心特点是「设备相关、对应像素位置」

告诉 GPU “每个顶点应该渲染到屏幕的哪个像素位置”，是和具体显示设备绑定的坐标

> 屏幕空间坐标就是 NDC 立方体映射到屏幕像素

我们把以上概念类比为“拍照流程”
- NDC 立方体：你拍的照片是 “平面的”，但拍摄范围是 “立体的”——NDC 就相当于把这个 “立体的视锥体”按比例压缩、拉平，变成一个 “标准的正方体盒子”（范围 [-1,1]³）。
- 屏幕空间坐标：这个 “NDC 正方体” 就像一张 “标准尺寸的底片”，而 `glViewport` 就是 “洗照片的相纸规格”（比如 1920×1080 像素）

再加深一下印象: 屏幕空间坐标是 “NDC 里的所有点（不管是近平面还是远平面的点）”，都会被映射到屏幕的像素上。

### 3.2.3 顶点缓冲对象
顶点着色器, 它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。

我们通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。

显卡管理给定的数据的形式:
- GL_STATIC_DRAW ：数据不会或几乎不会改变。
- GL_DYNAMIC_DRAW：数据会被改变很多。
- GL_STREAM_DRAW ：数据每次绘制时都会改变。

## 3.3 绘制一个物体的基本流程
现代OpenGL需要我们至少设置一个**顶点着色器**和一个**片段着色器**。
当学完顶点输入, 顶点着色器, 编译着色器, 片元着色器, 链接顶点属性后
就可得知绘制在屏幕上绘制一个顶点的基本流程为
```cpp
// 0. 复制顶点数组到缓冲中供OpenGL使用
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

// 1. 设置顶点属性指针
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);

// 2. 当我们渲染一个物体时要使用着色器程序
glUseProgram(shaderProgram);

// 3. 绘制物体
一些绘制物体的函数();
```

## 3.4 顶点数组对象
OpenGL 中的一个 状态对象，作用是 “缓存” 顶点数据的 “解释规则” 和 VBO 的绑定关系，避免每次渲染都重复设置这些规则

- 不存顶点数据本身，只存 “配置状态”；
- 是现代 OpenGL 核心模式的 必需项（没有 VAO 无法渲染，早期固定管线不需要）；
- 一个 VAO 可以对应一个或多个 VBO（比如一个 VBO 存坐标，另一个存颜色，VAO 记录这两个 VBO 的解析规则）。

```cpp
// 步骤1：创建 VBO 并传入顶点数据（CPU → GPU 显存）
1. 生成 VBO 对象（glGenBuffers）；
2. 绑定 VBO 到目标（glBindBuffer(GL_ARRAY_BUFFER, vbo)）；
3. 把 CPU 中的顶点数据复制到 VBO（glBufferData）；
   （此时 VBO 里有数据，但 OpenGL 不知道怎么解析）

// 步骤2：创建 VAO 并记录解析规则
1. 生成 VAO 对象（glGenVertexArrays）；
2. 绑定 VAO（glBindVertexArray(vao)）—— 这一步是关键！
   （绑定后，后续所有“顶点属性配置”都会被 VAO 记录）
3. 绑定要使用的 VBO（如果之前没绑定）；
4. 配置顶点属性指针（glVertexAttribPointer）：
   - 告诉 OpenGL：“VBO 里第 N 个属性（比如坐标是属性0），
     每个属性占几个分量（比如3个float对应x/y/z），
     数据类型是什么（float），是否归一化，
     每个顶点的总字节数（步长），
     该属性在顶点数据中的偏移量（比如坐标从0字节开始，颜色从12字节开始）；
5. 启用该顶点属性（glEnableVertexAttribArray）；
6. （可选）解绑 VBO 和 VAO（不影响已记录的状态）；
```

**总结:**
- **一个 VAO 可以关联多个 VBO**：比如 VBO1 存坐标，VBO2 存颜色，VAO 会记录 “哪个属性对应哪个 VBO” 以及各自的解析规则。
- **VBO 可以被多个 VAO 共用**：比如多个模型用相同的顶点坐标（同一个 VBO），但颜色 / 纹理不同（不同解析规则），可以用多个 VAO 关联同一个 VBO；
- VBO 负责 “把顶点数据搬到 GPU 存着”，VAO 负责 “记着怎么用这些数据”

## 3.5 元素缓冲对象
也叫索引缓冲对象(Index Buffer Object，IBO)
EBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储 OpenGL 用来决定要绘制哪些顶点的索引。

***
# 四. 着色器
着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。
着色器是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。

## 4.1 GLSL
着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。

一个典型的着色器有下面的结构：
```glsl
#version version_number
in type in_variable_name;
in type in_variable_name;

out type out_variable_name;

uniform type uniform_name;

void main()
{
  // 处理输入并进行一些图形操作
  ...
  // 输出处理过的结果到输出变量
  out_variable_name = weird_stuff_we_processed;
}
```

### 4.1.1 数据类型
特殊的, 向量(Vector)和矩阵(Matrix)

**向量:**
|类型	|含义|
|---|---|
|vecn	|包含n个float分量的默认向量|
|bvecn|	包含n个bool分量的向量|
|ivecn|	包含n个int分量的向量|
|uvecn|	包含n个unsigned int分量的向量|
|dvecn|	包含n个double分量的向量|

**向量重组**
一个向量的分量可以通过`vec.x`这种方式获取，这里x是指这个向量的第一个分量。你可以分别使用`.x`、`.y`、`.z`和`.w`来获取它们的第1、2、3、4个分量。GLSL也允许你对颜色使用`rgba`，或是对纹理坐标使用`stpq`访问相同的分量。
```glsl
vec2 someVec;
vec4 differentVec = someVec.xyxx;
vec3 anotherVec = differentVec.zyw;
vec4 otherVec = someVec.xxxx + anotherVec.yxzy;
```
## 4.2 输入输出
每个着色器之间只能通过输入输出进行交流
GLSL定义了`in`和`out`关键字专门来实现这个目的。
每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但在顶点和片段着色器中会有点不同。

**顶点着色器**
一个顶点可以包含多个信息: 位置, 颜色, 纹理坐标, 法线等
而它们在内存上是连续的, 我们想要高效的读取相应信息就需要指定顶点属性位置 
为了定义顶点数据该如何管理，我们使用location这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。
```glsl
// 顶点着色器
#version 330 core

// 直接在GLSL中指定位置
// location = ? 这个数字你可以随便定, 
// 只要 “着色器里的 location” 和 “CPU 端配置” 一一对应，
// 且每个属性用唯一数字就行。
layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aColor;
layout(location = 2) in vec2 aTexCoord;

out vec3 ourColor;
out vec2 TexCoord;

void main()
{
    gl_Position = vec4(aPos, 1.0);
    ourColor = aColor;
    TexCoord = aTexCoord;
}
```

## 4.3 Uniform
Uniform是另一种从我们的应用程序在 CPU 上传递数据到 GPU 上的着色器的方式

但uniform是全局的, 也就意味着
- uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问 
- 无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。

> 如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它，这可能导致一些非常麻烦的错误，


注意:
- 查询uniform地址不要求你之前使用过着色器程序，
- 但是更新一个uniform之前你必须先使用程序(调用glUseProgram)，因为它是在当前激活的着色器程序中设置uniform的。
***
# 五. 纹理
为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个**纹理坐标**(Texture Coordinate)


纹理坐标在x和y轴上，范围为0到1之间（注意我们使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做**采样**(Sampling)。纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终止于(1, 1)，即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。
<center>

![alt text](/LearnOpenGL/图片/LearnOpenGL11-22_10-22-18.jpg)

</center>

## 5.1 纹理环绕方式

纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像（我们基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择：


|环绕方式	|描述|
|:---:|---|
|GL_REPEAT|	对纹理的默认行为。重复纹理图像。|
|GL_MIRRORED_REPEAT	|和GL_REPEAT一样，但每次重复图片是镜像放置的。|
|GL_CLAMP_TO_EDGE	|纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。|
|GL_CLAMP_TO_BORDER|	超出的坐标为用户指定的边缘颜色。|

<center>

![alt text](/LearnOpenGL/图片/LearnOpenGL11-22_10-26-42.jpg)

</center>

## 5.2 纹理过滤
纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel)映射到纹理坐标

当你有一个很大的物体但是纹理的分辨率很低的时候, 就可以使用纹理过滤

**其中重要的两个:GL_NEAREST和GL_LINEAR。**

- GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）:
<center>

![alt text](/LearnOpenGL/图片/LearnOpenGL11-22_10-47-45.jpg)

</center>

- GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）
<center>

![alt text](/LearnOpenGL/图片/LearnOpenGL11-22_10-48-02.jpg)

</center>

邻近过滤更加"棱角分明", 适合做8-bit风格
线性过滤更加平滑, 可以得到更加真实的输出
<center>

![alt text](/LearnOpenGL/图片/LearnOpenGL11-22_10-51-42.jpg)

</center>

## 5.3 Mipmap
多级渐远纹理, 它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。那么Mipmap对于内存的额外开销极限为1/3
<center>

![alt text](/LearnOpenGL/图片/LearnOpenGL11-22_10-58-17.jpg)

</center>

**Mipmap主要是使用在纹理被缩小的情况下的：纹理放大不会使用Mipmap**

## 5.3 纹理单元

一个纹理的位置值通常称为一个纹理单元(Texture Unit)。一个纹理的默认纹理单元是0，它是默认的激活纹理单元。

纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器，我们可以一次绑定多个纹理，只要我们首先激活对应的纹理单元。


OpenGL要求y轴`0.0`坐标是在图片的底部的，但是图片的y轴`0.0`坐标通常在顶部。所以正常输出的图片都是上下翻转的, 使用以下代码即可
```glsl
stbi_set_flip_vertically_on_load(true);
```