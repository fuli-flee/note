[toc]
***
# 一. 基础概念

## 1.1 OpenGL
[OpenGL规范文档](https://registry.khronos.org/OpenGL/specs/gl/glspec33.core.pdf)

OpenGL到底是什么。一般它被认为是一个API
包含了一系列可以操作图形、图像的函数。
然而，OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范
OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定

### 1.1.1 核心模式与立即渲染模式

- **早期 OpenGL 采用立即渲染模式**（固定渲染管线），虽易于使用理解，但效率低且开发者对 OpenGL 计算的控制自由度小。
- 从 OpenGL3.2 开始，规范弃用立即渲染模式，鼓励使用核心模式。**核心模式使用现代函数**，虽学习难度大，但灵活性、效率更高，能让开发者更深入理解图形编程，且本教程面向 OpenGL3.3 核心模式，因为更高版本 OpenGL 是在其基础上引入额外功能，核心架构未变。
- 另外，使用新版本 OpenGL 特性需新一代显卡支持，所以多数开发者基于较低版本编写程序，仅提供启用新版本特性的选项。

## 1.2 GLFW
GLFW 是一个帮你搞定 OpenGL 「底层环境」的工具库

它替你解决「创建窗口、处理键盘 / 鼠标输入、管理显卡上下文、控制帧率」这些和 OpenGL 核心渲染无关，但又必须做的基础工作。

## 1.3 GLAD
因为OpenGL只是一个标准/规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。

开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。

而GLAD就是简化这个过程的, 所以在调用任何OpenGL的函数之前我们需要初始化GLAD。

***
# 二. 创建窗口

## 2.1 双缓冲(Double Buffer)

应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。

***
# 三. 创建三角形


## 3.1 图形渲染管线

处理3D坐标转为2D坐标

图形渲染管线可以被划分为两个主要部分：
- 第一部分把你的3D坐标转换为2D坐标，
- 第二部分是把2D坐标转变为实际的有颜色的像素。

2D坐标和像素也是不同的:
- 2D坐标精确表示一个点在2D空间中的位置，
- 而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。

图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分。
<center>

![alt text](/LearnOpenGL/图片/LearnOpenGL11-19_16-28-36.jpg)

</center>

### 3.1.1 图元
告诉 OpenGL 如何 “解读” 你传入的顶点数据，是按 “点”、“线” 还是 “三角形” 来组装渲染。

举个简单一点的例子, 比如你有 3 个顶点：A (0,0)、B (1,0)、C (0.5,1)
- 选图元 `GL_POINTS`（点）：屏幕上显示 3 个独立的点；
- 选图元 `GL_LINES`（线段）：按顺序两两配对（A-B、C 多余不显示），显示 1 条线；
- 选图元 `GL_LINE_LOOP`（线环）：两两配对且首尾相连（A-B、B-C、C-A），显示一个三角形的轮廓；
- 选图元 `GL_TRIANGLES`（三角形）：三个顶点组成一个三角形（A-B-C），显示一个实心三角形。

### 3.1.2 顶点着色器
它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。

### 3.1.3 几何着色器
顶点着色器阶段的输出可以选择性地传递给几何着色器

然后将这些顶点形成图元, 并且能够通过发出新的顶点来形成新的(或其他)图元来生成其他形状。

也就是说几何着色器可以通过代码逻辑 “凭空” 生成新顶点，再把这些新顶点和原始顶点（或纯新顶点）组合成新的图元，最终渲染出原本没有的形状。

举个例子: 把 “点” 变成 “正方形”
- 假设顶点着色器只输出 1 个顶点（图元类型是 “点”），几何着色器接收这个点后：
    - 以这个原始点为 “中心”，新增 3 个顶点, 这3个点你爱咋写咋写, 这个规矩是你用代码定的（比如原始点坐标是 (0,0,0)，新增 (1,1,0)、(-1,1,0)、(-1,-1,0)）；
    - 把 “原始点 + 3 个新增顶点” 组合成 2 个三角形（正方形由 2 个三角形拼成）；
    - 输出这 2 个三角形图元。

### 3.1.4 图元装配
将顶点着色器（或几何着色器）输出的所有顶点作为输入，并将所有的点装配成指定图元的形状；本节例子中是两个三角形。

### 3.1.5 片段着色器
主要目的是计算一个像素的最终颜色

***

## 3.2 顶点输入
OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理它。所有在这个范围内的坐标叫做**标准化设备坐标(Normalized Device Coordinates, NDC)**，此范围内的坐标最终显示在屏幕上

### 3.2.1标准化设备坐标（NDC）
NDC 是 3D 渲染管线中介于裁剪空间和屏幕空间之间的中间坐标，核心特点是「设备无关、范围固定」

把 “不同摄像机参数（如视场角、近远平面）、不同屏幕尺寸” 的渲染需求，统一到一个固定范围的坐标系统中，方便后续映射到具体屏幕。

> NDC就是将不同摄像机的视锥体给 "压扁" 成了一个立方体

### 3.2.2 屏幕空间坐标

屏幕空间坐标是 **最终用于渲染的物理像素坐标**，由 NDC 经过「视口变换」得到，核心特点是「设备相关、对应像素位置」

告诉 GPU “每个顶点应该渲染到屏幕的哪个像素位置”，是和具体显示设备绑定的坐标

> 屏幕空间坐标就是 NDC 立方体映射到屏幕像素

我们把以上概念类比为“拍照流程”
- NDC 立方体：你拍的照片是 “平面的”，但拍摄范围是 “立体的”——NDC 就相当于把这个 “立体的视锥体”按比例压缩、拉平，变成一个 “标准的正方体盒子”（范围 [-1,1]³）。
- 屏幕空间坐标：这个 “NDC 正方体” 就像一张 “标准尺寸的底片”，而 `glViewport` 就是 “洗照片的相纸规格”（比如 1920×1080 像素）

再加深一下印象: 屏幕空间坐标是 “NDC 里的所有点（不管是近平面还是远平面的点）”，都会被映射到屏幕的像素上。

### 3.2.3 顶点缓冲对象
顶点着色器, 它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。

我们通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。