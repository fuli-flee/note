[toc]
***
# 一. 深度测试

深度缓冲就像颜色缓冲(Color Buffer)（储存所有的片段颜色：视觉输出）一样，在每个片段中储存了信息，并且（通常）和颜色缓冲有着一样的宽度和高度。深度缓冲是由窗口系统自动创建的，它会以16、24或32位float的形式储存它的深度值。在大部分的系统中，深度缓冲的精度都是24位的。

当深度测试(Depth Testing)被启用的时候，OpenGL会将一个片段的深度值与深度缓冲的内容进行对比。OpenGL会执行一个深度测试，如果这个测试通过了的话，深度缓冲将会更新为新的深度值。如果深度测试失败了，片段将会被丢弃。

深度缓冲是在**片段着色器运行之后**, 以及**模板测试(Stencil Testing)运行之后** ，在**屏幕空间**中运行的。屏幕空间坐标与通过OpenGL的`glViewport`所定义的视口密切相关，并且可以直接使用GLSL内建变量`gl_FragCoord`从片段着色器中直接访问。`gl_FragCoord`的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）。`gl_FragCoord`中也包含了一个z分量，它包含了片段真正的深度值。z值就是需要与深度缓冲内容所对比的那个值。

OpenGL深度测试默认是禁用的, OpenGL允许我们修改深度测试中使用的比较运算符。这允许我们来控制OpenGL什么时候该通过或丢弃一个片段，什么时候去更新深度缓冲。


|函数	|描述|
|---|---|
|GL_ALWAYS	|永远通过深度测试|
|GL_NEVER	|永远不通过深度测试|
|GL_LESS	|在片段深度值小于缓冲的深度值时通过测试|
|GL_EQUAL	|在片段深度值等于缓冲区的深度值时通过测试|
|GL_LEQUAL	|在片段深度值小于等于缓冲区的深度值时通过测试|
|GL_GREATER	|在片段深度值大于缓冲区的深度值时通过测试|
|GL_NOTEQUAL|	在片段深度值不等于缓冲区的深度值时通过测试|
|GL_GEQUAL	|在片段深度值大于等于缓冲区的深度值时通过测试|

## 1.1 深度值精度
深度缓冲包含了一个介于0.0和1.0之间的深度值，它将会与观察者视角所看见的场景中所有物体的z值进行比较。观察空间的z值可能是投影平截头体的近平面(Near)和远平面(Far)之间的任何值。我们需要一种方式来将这些观察空间的z值变换到[0, 1]范围之间，其中的一种方式就是将它们线性变换到[0, 1]范围之间。下面这个（线性）方程将z值变换到了0.0到1.0之间的深度值：
$$F_{depth}=\frac{z-near}{far-near}$$

<center>

![alt text](/LearnOpenGL/图片/渲染进阶/渲染进阶11-30_19-23-50.jpg)

</center>

然而，在实践中是几乎永远不会使用这样的线性深度缓冲(Linear Depth Buffer)的。要想有正确的投影性质，需要使用一个非线性的深度方程，它是与 1/z 成正比的。它做的就是在z值很小的时候提供非常高的精度，而在z值很远的时候提供更少的精度。花时间想想这个：我们真的需要对1000单位远的深度值和只有1单位远的充满细节的物体使用相同的精度吗？线性方程并不会考虑这一点。

由于非线性方程与 1/z 成正比，在1.0和2.0之间的z值将会变换至1.0到0.5之间的深度值，这就是一个float提供给我们的一半精度了，这在z值很小的情况下提供了非常大的精度。在50.0和100.0之间的z值将会只占2%的float精度，这正是我们所需要的。这样的一个考虑了远近距离的方程是这样的：
$$F_{depth}=\frac{1/z-1/near}{1/far-1/near}$$
<center>

![alt text](/LearnOpenGL/图片/渲染进阶/渲染进阶11-30_19-29-19.jpg)

</center>

## 1.2 深度冲突
一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。这个现象叫做深度冲突(Z-fighting)，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。
深度冲突是深度缓冲的一个常见问题，当物体在远处时效果会更明显（因为深度缓冲在z值比较大的时候有着更小的精度）。

在玩游戏时, 你可能会看到室内墙壁上的某些装饰纹理与墙体本身之间出现闪烁或 “抖动” 现象, 就是深度冲突.
***
# 二. 模板测试
当片段着色器处理完一个片段之后，模板测试(Stencil Test)会开始执行，和深度测试一样，它也可能会丢弃片段。接下来，被保留的片段会进入深度测试，它可能会丢弃更多的片段。模板测试是根据又一个缓冲来进行的，它叫做**模板缓冲**(Stencil Buffer)，我们可以在渲染的时候更新它来获得一些很有意思的效果。

<center>

![alt text](/LearnOpenGL/图片/渲染进阶/渲染进阶11-30_20-57-13.jpg)

</center>

一个模板缓冲中，（通常）每个模板值(Stencil Value)是8位的。所以每个像素/片段一共能有256种不同的模板值。我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了。


|行为	|描述|
|---|---|
|GL_KEEP	    |保持当前储存的模板值|
|GL_ZERO	    |将模板值设置为0|
|GL_REPLACE	    |将模板值设置为glStencilFunc函数设置的ref值|
|GL_INCR	    |如果模板值小于最大值则将模板值加1|
|GL_INCR_WRAP	|与GL_INCR一样，但如果模板值超过了最大值则归零|
|GL_DECR	    |如果模板值大于最小值则将模板值减1|
|GL_DECR_WRAP	|与GL_DECR一样，但如果模板值小于0则将其设置为最大值|
|GL_INVERT	    |按位翻转当前的模板缓冲值|