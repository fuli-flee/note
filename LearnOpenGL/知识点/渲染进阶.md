[toc]
***
# 一. 深度测试

深度缓冲就像颜色缓冲(Color Buffer)（储存所有的片段颜色：视觉输出）一样，在每个片段中储存了信息，并且（通常）和颜色缓冲有着一样的宽度和高度。深度缓冲是由窗口系统自动创建的，它会以16、24或32位float的形式储存它的深度值。在大部分的系统中，深度缓冲的精度都是24位的。

当深度测试(Depth Testing)被启用的时候，OpenGL会将一个片段的深度值与深度缓冲的内容进行对比。OpenGL会执行一个深度测试，如果这个测试通过了的话，深度缓冲将会更新为新的深度值。如果深度测试失败了，片段将会被丢弃。

深度缓冲是在**片段着色器运行之后**, 以及**模板测试(Stencil Testing)运行之后** ，在**屏幕空间**中运行的。屏幕空间坐标与通过OpenGL的`glViewport`所定义的视口密切相关，并且可以直接使用GLSL内建变量`gl_FragCoord`从片段着色器中直接访问。`gl_FragCoord`的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）。`gl_FragCoord`中也包含了一个z分量，它包含了片段真正的深度值。z值就是需要与深度缓冲内容所对比的那个值。

OpenGL深度测试默认是禁用的, OpenGL允许我们修改深度测试中使用的比较运算符。这允许我们来控制OpenGL什么时候该通过或丢弃一个片段，什么时候去更新深度缓冲。


|函数	|描述|
|---|---|
|GL_ALWAYS	|永远通过深度测试|
|GL_NEVER	|永远不通过深度测试|
|GL_LESS	|在片段深度值小于缓冲的深度值时通过测试|
|GL_EQUAL	|在片段深度值等于缓冲区的深度值时通过测试|
|GL_LEQUAL	|在片段深度值小于等于缓冲区的深度值时通过测试|
|GL_GREATER	|在片段深度值大于缓冲区的深度值时通过测试|
|GL_NOTEQUAL|	在片段深度值不等于缓冲区的深度值时通过测试|
|GL_GEQUAL	|在片段深度值大于等于缓冲区的深度值时通过测试|

## 1.1 深度值精度
深度缓冲包含了一个介于0.0和1.0之间的深度值，它将会与观察者视角所看见的场景中所有物体的z值进行比较。观察空间的z值可能是投影平截头体的近平面(Near)和远平面(Far)之间的任何值。我们需要一种方式来将这些观察空间的z值变换到[0, 1]范围之间，其中的一种方式就是将它们线性变换到[0, 1]范围之间。下面这个（线性）方程将z值变换到了0.0到1.0之间的深度值：
$$F_{depth}=\frac{z-near}{far-near}$$

<center>

![alt text](/LearnOpenGL/图片/渲染进阶/渲染进阶11-30_19-23-50.jpg)

</center>

然而，在实践中是几乎永远不会使用这样的线性深度缓冲(Linear Depth Buffer)的。要想有正确的投影性质，需要使用一个非线性的深度方程，它是与 1/z 成正比的。它做的就是在z值很小的时候提供非常高的精度，而在z值很远的时候提供更少的精度。花时间想想这个：我们真的需要对1000单位远的深度值和只有1单位远的充满细节的物体使用相同的精度吗？线性方程并不会考虑这一点。

由于非线性方程与 1/z 成正比，在1.0和2.0之间的z值将会变换至1.0到0.5之间的深度值，这就是一个float提供给我们的一半精度了，这在z值很小的情况下提供了非常大的精度。在50.0和100.0之间的z值将会只占2%的float精度，这正是我们所需要的。这样的一个考虑了远近距离的方程是这样的：
$$F_{depth}=\frac{1/z-1/near}{1/far-1/near}$$
<center>

![alt text](/LearnOpenGL/图片/渲染进阶/渲染进阶11-30_19-29-19.jpg)

</center>

## 1.2 深度冲突
一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。这个现象叫做深度冲突(Z-fighting)，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。
深度冲突是深度缓冲的一个常见问题，当物体在远处时效果会更明显（因为深度缓冲在z值比较大的时候有着更小的精度）。

在玩游戏时, 你可能会看到室内墙壁上的某些装饰纹理与墙体本身之间出现闪烁或 “抖动” 现象, 就是深度冲突.
***
# 二. 模板测试
当片段着色器处理完一个片段之后，模板测试(Stencil Test)会开始执行，和深度测试一样，它也可能会丢弃片段。接下来，被保留的片段会进入深度测试，它可能会丢弃更多的片段。模板测试是根据又一个缓冲来进行的，它叫做**模板缓冲**(Stencil Buffer)，我们可以在渲染的时候更新它来获得一些很有意思的效果。

<center>

![alt text](/LearnOpenGL/图片/渲染进阶/渲染进阶11-30_20-57-13.jpg)

</center>

一个模板缓冲中，（通常）每个模板值(Stencil Value)是8位的。所以每个像素/片段一共能有256种不同的模板值。我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了。


|行为	|描述|
|---|---|
|GL_KEEP	    |保持当前储存的模板值|
|GL_ZERO	    |将模板值设置为0|
|GL_REPLACE	    |将模板值设置为glStencilFunc函数设置的ref值|
|GL_INCR	    |如果模板值小于最大值则将模板值加1|
|GL_INCR_WRAP	|与GL_INCR一样，但如果模板值超过了最大值则归零|
|GL_DECR	    |如果模板值大于最小值则将模板值减1|
|GL_DECR_WRAP	|与GL_DECR一样，但如果模板值小于0则将其设置为最大值|
|GL_INVERT	    |按位翻转当前的模板缓冲值|

***
# 三. 混合
**混合**(Blending)通常是实现物体**透明度**(Transparency)的一种技术。透明就是说一个物体（或者其中的一部分）不是纯色(Solid Color)的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。一个有色玻璃窗是一个透明的物体，玻璃有它自己的颜色，但它最终的颜色还包含了玻璃之后所有物体的颜色。这也是混合这一名字的出处，我们混合(Blend)（不同物体的）多种颜色为一种颜色。所以透明度能让我们看穿物体。

透明的物体可以是完全透明的（让所有的颜色穿过），或者是半透明的（它让颜色通过，同时也会显示自身的颜色）。一个物体的透明度是通过它颜色的alpha值来决定的


OpenGL中的混合通过以下方程来实现：
$$\bar{C}_{result}=\bar{C}_{source}*F_{source}+\bar{C}_{destination}*F_{destination}$$

- $\bar{C}_{source}$：源颜色向量。这是源自纹理的颜色向量。
- $\bar{C}_{destination}$：目标颜色向量。这是当前储存在颜色缓冲中的颜色向量。
- $\bar{F}_{source}$：源因子值。指定了alpha值对源颜色的影响。
- $\bar{F}_{destination}$：目标因子值。指定了alpha值对目标颜色的影响


源颜色和目标颜色将会由OpenGL自动设定，但源因子和目标因子的值可以由我们来决定。我们先来看一个简单的例子：

<center>

![alt text](/LearnOpenGL/图片/渲染进阶/渲染进阶12-02_09-17-21.jpg)

</center>

我们有两个方形，我们希望将这个半透明的绿色方形绘制在红色方形之上。红色的方形将会是目标颜色（所以它应该先在颜色缓冲中），我们将要在这个红色方形之上绘制这个绿色方形。

问题来了：我们将因子值设置为什么？我们至少想让绿色方形乘以它的alpha值，所以我们想要将$\bar{F}_{src}$设置为源颜色向量的alpha值，也就是0.6。接下来就应该清楚了，目标方形的贡献应该为剩下的alpha值。如果绿色方形对最终颜色贡献了60% ，那么红色方块应该对最终颜色贡献了40%，即1.0 - 0.6。所以我们将$\bar{F}_{destination}$设置为1减去源颜色向量的alpha值。这个方程变成了：

$$\bar{C}_{result}=\begin{pmatrix}0.0\\1.0\\0.0\\0.6\end{pmatrix}*0.6+\begin{pmatrix}1.0\\0.0\\0.0\\1.0\end{pmatrix}*(1-0.6)$$

结果:
<center>

![alt text](/LearnOpenGL/图片/渲染进阶/渲染进阶12-02_09-28-05.jpg)

</center>

|选项|值|
|---|---|
|GL_ZERO|因子等于 0|
|GL_ONE|因子等于 1|
|GL_SRC_COLOR|因子等于源颜色向量\(\vec{C}_{source}\)|
|GL_ONE_MINUS_SRC_COLOR|因子等于\(1 - \vec{C}_{source}\)|
|GL_DST_COLOR|因子等于目标颜色向量\(\vec{C}_{destination}\)|
|GL_ONE_MINUS_DST_COLOR|因子等于\(1 - \vec{C}_{destination}\)|
|GL_SRC_ALPHA|因子等于\(\vec{C}_{source}\)的 alpha 分量|
|GL_ONE_MINUS_SRC_ALPHA|因子等于\(1 - \vec{C}_{source}\)的 alpha 分量|
|GL_DST_ALPHA|因子等于\(\vec{C}_{destination}\)的 alpha 分量|
|GL_ONE_MINUS_DST_ALPHA|因子等于\(1 - \vec{C}_{destination}\)的 alpha 分量|
|GL_CONSTANT_COLOR|因子等于常数颜色向量\(\vec{C}_{constant}\)|
|GL_ONE_MINUS_CONSTANT_COLOR|因子等于\(1 - \vec{C}_{constant}\)|
|GL_CONSTANT_ALPHA|因子等于\(\vec{C}_{constant}\)的 alpha 分量|
|GL_ONE_MINUS_CONSTANT_ALPHA|因子等于\(1 - \vec{C}_{constant}\)的 alpha 分量|

OpenGL甚至给了我们更多的灵活性，允许我们改变方程中源和目标部分的运算符。当前源和目标是相加的，但如果愿意的话，我们也可以让它们相减。glBlendEquation(GLenum mode)允许我们设置运算符，它提供了三个选项：

|运算符|说明|
|---|---|
|GL_FUNC_ADD              |默认选项，将两个分量相加：\(\vec{C}_{result}\)=*Src*+*Dst*|
|GL_FUNC_SUBTRACT         |将两个分量相减： \(\vec{C}_{result}\)=*Src*−*Dst*|
|GL_FUNC_REVERSE_SUBTRACT |将两个分量相减，但顺序相反：\(\vec{C}_{result}\)=*Dst*−*Src*|
|GL_MIN                   |取两个分量中的最小值：\(\vec{C}_{result}\)=*min*(*Dst*,*Src*)|
|GL_MAX                   |取两个分量中的最大值：\(\vec{C}_{result}\)=*max*(*Dst*,*Src*)|

## 3.1 渲染顺序

首先理解渲染顺序之前先理解**深度测试和混合的矛盾**:
- 深度测试（Z-Buffer）的作用：决定“谁挡住谁”。它只关心每个像素的深度值，不关心颜色是否透明。
- 混合（Blending）的作用：将当前片段的颜色（源）与帧缓冲中已有的颜色（目标）按照透明度进行混合，实现透明效果。

想象两个重叠的窗户，一前一后，都是部分透明。
1. 先画前面的窗户（近处）：
    - 它的每个片段（包括透明部分）都会写入深度缓冲。深度缓冲现在记录的是“离相机近”的深度值。
2. 再画后面的窗户（远处）：
    - 进行深度测试：它的大部分区域，深度值都比深度缓冲里记录的值更远。
    - 结果：这些区域被深度测试直接丢弃了！根本不会进入混合阶段。
    - 你最终只能看到前面窗户透明部分后面是更早之前绘制的背景，而不是“后面的窗户”。

<center>

![alt text](/LearnOpenGL/图片/渲染进阶/渲染进阶12-02_10-13-15.jpg)

</center>

要想让混合在多个物体上工作，我们需要最先绘制最远的物体，最后绘制最近的物体。普通不需要混合的物体仍然可以使用深度缓冲正常绘制，所以它们不需要排序。但我们仍要保证它们在绘制（排序的）透明物体之前已经绘制完毕了。当绘制一个有不透明和透明物体的场景的时候，大体的原则如下：
1. 先绘制所有不透明的物体。
2. 对所有透明的物体排序。
3. 按顺序绘制所有透明的物体。

排序透明物体的一种方法是，从观察者视角获取物体的距离。这可以通过计算摄像机位置向量和物体的位置向量之间的距离所获得。接下来我们把距离和它对应的位置向量存储到一个STL库的map数据结构中。map会自动根据键值(Key)对它的值排序，所以只要我们添加了所有的位置，并以它的距离作为键，它们就会自动根据距离值排序了。

***
# 四. 面剔除

任何一个闭合形状，它的每一个面都有两侧，每一侧要么面向用户，要么背对用户。而只绘制面向观察者的面正是 **面剔除(Face Culling)** 所做的, 我们能省下超过50%的片段着色器执行数

## 4.1 环绕顺序
现在的问题是如何区分正向面和反向面?

当我们定义一组三角形顶点时，我们会以特定的环绕顺序来定义它们，可能是顺时针(Clockwise)的，也可能是逆时针(Counter-clockwise)的。每个三角形由3个顶点所组成，我们会从三角形中间来看，为这3个顶点设定一个环绕顺序。

<center>

![alt text](/LearnOpenGL/图片/渲染进阶/渲染进阶12-02_15-53-35.jpg)

</center>

可以看到，我们首先定义了顶点1，之后我们可以选择定义顶点2或者顶点3，这个选择将定义了这个三角形的环绕顺序。下面的代码展示了这点：
```cpp
float vertices[] = {
    // 顺时针
    vertices[0], // 顶点1
    vertices[1], // 顶点2
    vertices[2], // 顶点3
    // 逆时针
    vertices[0], // 顶点1
    vertices[2], // 顶点3
    vertices[1]  // 顶点2  
};
```

每组组成三角形图元的三个顶点就包含了一个环绕顺序。OpenGL在渲染图元的时候将使用这个信息来决定一个三角形是一个正向三角形还是背向三角形。**默认情况下，逆时针顶点所定义的三角形将会被处理为正向三角形。**

当你定义顶点顺序的时候，你应该想象对应的三角形是面向你的，所以你定义的三角形从正面看去应该是逆时针的。实际的环绕顺序是在光栅化阶段进行的，也就是顶点着色器运行之后。这些顶点就是从**观察者视角**所见的了。

观察者所面向的所有三角形顶点就是我们所指定的正确环绕顺序了，而立方体另一面的三角形顶点则是以相反的环绕顺序所渲染的。这样的结果就是，我们所面向的三角形将会是正向三角形，而背面的三角形则是背向三角形。下面这张图显示了这个效果：
<center>

![alt text](/LearnOpenGL/图片/渲染进阶/渲染进阶12-02_16-08-01.jpg)

</center>

在顶点数据中，我们将两个三角形都以逆时针顺序定义（正面的三角形是1、2、3，背面的三角形也是1、2、3（如果我们从正面看这个三角形的话））。然而，如果从观察者当前视角使用1、2、3的顺序来绘制的话，从观察者的方向来看，背面的三角形将会是以顺时针顺序渲染的。虽然背面的三角形是以逆时针定义的，它现在是以顺时针顺序渲染的了。这正是我们想要剔除的不可见面了

***
# 五. 帧缓冲
用于写入颜色值的**颜色缓冲**、用于写入深度信息的**深度缓冲**和允许我们根据一些条件丢弃特定片段的**模板缓冲**。这些缓冲结合起来叫做**帧缓冲**(Framebuffer)，它被储存在GPU内存中的某处。OpenGL允许我们定义我们自己的帧缓冲，也就是说我们能够定义我们自己的颜色缓冲，甚至是深度缓冲和模板缓冲。

一个完整的帧缓冲需要满足以下的条件：
- 附加至少一个缓冲（颜色、深度或模板缓冲）。
- 至少有一个颜色附件(Attachment)。
- 所有的附件都必须是完整的（保留了内存）。
- 每个缓冲都应该有相同的样本数(sample)。

## 5.1 附件
附件是一个内存位置，它能够作为帧缓冲的一个缓冲，可以将它想象为一个图像。当创建一个附件的时候我们有两个选项：纹理或渲染缓冲对象(Renderbuffer Object)。

### 5.1.1 纹理附件
当把一个纹理附加到帧缓冲的时候，所有的渲染指令将会写入到这个纹理中，就像它是一个普通的颜色/深度或模板缓冲一样。使用纹理的优点是，所有渲染操作的结果将会被储存在一个纹理图像中，我们之后可以在着色器中很方便地使用它。

### 5.1.2 渲染缓冲对象附件

渲染缓冲对象(Renderbuffer Object)是在纹理之后引入到OpenGL中，作为一个可用的帧缓冲附件类型的，所以在过去纹理是唯一可用的附件。和纹理图像一样，渲染缓冲对象是一个真正的缓冲，即一系列的字节、整数、像素等。渲染缓冲对象附加的好处是，它会将数据储存为OpenGL原生的渲染格式，它是为离屏渲染到帧缓冲优化过的。

渲染缓冲对象直接将所有的渲染数据储存到它的缓冲中，不会做任何针对纹理格式的转换，让它变为一个更快的可写储存介质。然而，渲染缓冲对象通常都是只写的，所以你不能读取它们（比如使用纹理访问）。当然你仍然还是能够使用glReadPixels来读取它，这会从当前绑定的帧缓冲，而不是附件本身，中返回特定区域的像素。

因为它的数据已经是原生的格式了，当写入或者复制它的数据到其它缓冲中时是非常快的。所以，交换缓冲这样的操作在使用渲染缓冲对象时会非常快。我们在每个渲染迭代最后使用的glfwSwapBuffers，也可以通过渲染缓冲对象实现：只需要写入一个渲染缓冲图像，并在最后交换到另外一个渲染缓冲就可以了。渲染缓冲对象对这种操作非常完美。

### 5.1.3 总结
说实话, 我在看以上内容的原文的时候都差点睡着了, 我还是用点形象的方式记录吧

1. 先记住一个大前提：
   附件的本质是 帧缓冲（离屏渲染用的 “虚拟画布”）的 “数据容器” —— 你在帧缓冲上画的东西（颜色、深度、模板信息），最终都会存在这个 “容器” 里。而这个容器只有两种选择：`纹理附件` 或 `渲染缓冲对象附件`，它们的核心区别就是「能不能方便复用」和「读写速度」。
    </br>

2. 为什么需要 “附件”？
    你可以把「帧缓冲」想象成一个 没有自带画布的画架 —— 画架本身只是提供 “画画的场地”，但你得自己找块 “布”（附件）铺上去，才能真正画画（渲染）。这块 “布” 就是用来存你画的内容的，而 “布” 的材质（纹理 / 渲染缓冲），决定了后续你能用它做什么。
    </br>

    - 纹理附件：“可重复利用的照片”
      - 所有渲染结果都会变成「纹理图像」，着色器能直接访问它的像素 —— 这是它最核心的价值。

    - 渲染缓冲对象附件：“一次性的草稿纸”
      - 渲染内容确实存在, 但是不能像纹理那样在着色器里访问单个像素, 而优点是读写速度快, 因为数据是 OpenGL 原生格式，不用转换