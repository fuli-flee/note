[toc]
***
# 1. 工程文件夹
![alt](/Unity/图片/image.png)
- Assets: 工程资源文件夹(美术资源,脚本等)
- Library: 库文件夹(Unity自动生成管理)
- Logs: 日志文件夹,记录特殊信息
- obj: 编译产生中间文件
- Packages: 包配置信息
- ProjectSettings: 工程设置信息

只要这个Assets文件夹不丢,工程就能打开,其他的unity会帮你生成,但是里面的配置就未必是之前的了
***
# 2. Scene和Hierarchy窗口
层级窗口中看到的内容就是场景窗口中的显示对象

## 2.1 Hierarchy 层级窗口
层级窗口中显示的就是一个场景中的所有对象
Hierarchy窗口就是创建,拖动,操作的一个功能面板

**操作**
**Duplicate**这个可以理解为复制粘贴一步到位,快捷键为`Ctrl+D`

## 2.2 Scene 场景窗口
![alt text](/Unity/图片/image2.png)

**坐标轴**
以屏幕为参照
- 垂直屏幕向内为+Z
- 平行屏幕向右为+X
- 垂直屏幕向上为+Y

![alt text](/Unity/图片/image3.png)
***
# 3. Game游戏窗口和Project工程窗口
## 3.1 Game游戏窗口
![alt text](/Unity/图片/image5.png)
- Warn if No Cameras Rendering: 场景中没有摄像机时会发出警告
- Clear Every Frame in Edit Mode: 游戏未播放时,也更新Game窗口,避免显示问题

![alt text](/Unity/图片/image4.png)
## 2.3 Project工程窗口
Packages文件夹: 放的是官方拓展包
***
# 3. 工具栏
## 3.1 工具栏
![alt text](/Unity/图片/image6.png)
- File(文件操作): 新建工程, 新建场景, 工程打包等
- Edit(编辑操作): 对象编辑操作相关, 工程设置, 引擎设置相关
- Assets(资源操作): 基本等同于Project窗口中右键相关功能
- GameObject(对象操作): 基本等同于Hierarchy窗口中右键相关功能
- Component(脚本操作): Unity自带的脚本, 可以添加各系统重的脚本
- Window(窗口): 可以打开Unity各核心系统的窗口
- Help(帮助): 检查更新, 查看版本等

**Edit中的Project Settings**

Edit中的Project Settings中的选项其实就是对应的你Project Settings文件夹中的资源,修改过后的配置会存入到Project Settings中的配置文件
![alt text](/Unity/图片/image7.png)

**Edit中的Preference**
External Tools中可以更改你默认打开的IDE
![alt text](/Unity/图片/Snipaste_2025-09-18_09-32-07.jpg)
- Ctrl+Alt+F: 将物体移动到视口中心 
- Ctrl+Shift+F: 将物体移动到视口位置
![alt text](/Unity/图片/Snipaste_2025-09-18_10-01-04.jpg)

***
# 4.Unity中的反射机制和游戏场景的本质
## 回顾
程序正在运行时可以查看其他程序集或者自身的元数据, 一个运行的程序查看本身或者其他程序的元数据的行为就叫反射

## 对象的本质
- GameObject类对象是Unity提供的作为场景中所有对象的根本
- 在游戏场景中出现一个对象, 不管是图片, 模型, 音效, 摄像机等都是依附于GameObject对象的
- 而Transform是GameObject对象必不可少的一个依附对象
- 相当与就是用一个**Transform类对象**和**GameObject类对象**(注意这里都是类对象)进行关联, 用于设置位置和缩放

举例说明:
1. 修改Inspector面板中的Transform内容
> 利用反射: 已知对象, 类名, 变量名, 通过反射为该对象设置变量值
1. 新建一个脚本后,添加给一个指定的GameObject对象
> 已知类名, 可以获取所有公共成员,故可以在Inspector面板上创建各个公共字段信息

## 游戏场景的本质
- 游戏场景文件, 后缀为`.unity`,它的本质就是一个配置文件
- unity有一套自己识别处理它的机制
- 本质就是把场景对象相关信息读取出来,通过反射来创建各个对象关联各个脚本对象

***
# 4. 预制体(预设体)
- Unpack Prefab: 和之前的预制体取消关联
***
# 5. 脚本
类名和文件名必须一致,不然无法挂载(因为反射机制创建对象, 会通过文件名去找Type)
## 5.1 MonoBehavior
1. 创建的脚本默认都继承MonoBehavior, 继承了它才能够挂载在GameObject上
2. 继承了的MonoBehavior的脚本不能new,只能挂
3. 继承了MonoBehavior的脚本不要写构造函数,你都不能new,你写构造函数也没有意义了
4. 继承了MonoBehavior的脚本可以在一个对象上挂多个(在没有加DisallowMultipleComponent特性(不允许多次挂载,包括其子类)的情况下)
5. 继承MonoBehavior的类可以再次被继承, 遵循面向对象继承多态的规则

**不继承MonoBehavior的类**
1. 不能挂载到GameObject上
2. 想怎么写就怎么写, 要使用的时候需要自己new
3. 一般是单例模式的类(用于管理模块) 或者数据结构类(用于存储数据)
4. 不用保留默认出现的生命周期函数

**设置执行顺序**
![alt text](/Unity/图片/Snipaste_09-18_11-54-34.jpg)

**改变默认脚本内容**
要管理员权限
> Editor\Data\Resource\ScriptTemplates

***
# 6. 生命周期函数
## 概念
所有继承MonoBehavior的脚本,最终都会挂载到GameObject游戏对象上
生命周期函数就是该脚本对象依附的GameObject对象从出生到消亡整个生命周期中会通过反射自动调用的一些特殊函数

unity帮助我们记录了一个GameObject对象依附了哪些脚本, 会自动的得到这些对象, 通过反射去执行一些固定名字的函数

## 生命周期函数

!!! important 注意
    生命周期函数的访问修饰符一般为private和protected
    因为不需要在外部自己调用生命周期函数, 都是Unity自己帮助我们调用的
    生命周期函数支持继承多态

<center>

![alt text](/Unity/图片/Unity入门09-18_21-22-08.jpg)

</center>

1. **Awake**
当对象(自己这个类对象)**被创建时**才会调用该声明周期函数, **只会调用一次**
类似构造函数的存在, 我们可以在一个类对象刚创建时进行一些初始化操作
</br>

2. **OnEnable**
依附的GameObject对象**每次激活时调用**
当想要一个对象被激活时, 进行一些逻辑处理,就可以写在这个函数中
</br>

3. **Start**
**只会调用一次**,主要作用还是用于初始化信息的
当在update函数里动态创建对象时,会立马调用Awake函数,而start则会等到下一帧开始时调用
</br>

4. **FixedUpdate**
主要用于进行物理更新,它是每一帧都执行的,但是它的每一帧是可控的,且它运行的帧和其他update函数不一样,默认间隔时间是0.02s
</br>

5. **Update**
主要用于**处理游戏核心逻辑更新**的函数
</br>

6. **LaterUpdate**
一般用来**处理摄像机位置更新**相关内容
Update和LaterUpdate之间,unity会处理动画相关的更新
</br>

7. **OnDisable**
依附的GameObject对象**每次失活时调用**
当对象失活时,依附其上的生命周期函数都会停止调用
</br>

8. **OnDestroy**
**只调用一次**, 当一个对象销毁的时候会先调用一次OnDisable再调用OnDestroy



## 拓展
**Update和FixedUpdate时间间隔的区别**
1. Update 的时间间隔不固定
    Update的调用频率与游戏帧率（FPS）相关，每帧调用一次。如果帧率波动（比如从 60FPS 降到 30FPS），两次Update之间的时间间隔会相应变化（从约 16.7ms 变为约 33.3ms）。可以通过`Time.deltaTime`获取上一帧到当前帧的实际时间间隔，用于在移动、旋转等操作中进行时间补偿。
    
2. FixedUpdate 的时间间隔固定
    FixedUpdate的调用频率由项目设置中的 "Fixed Timestep"决定，时间间隔是固定的。无论帧率如何波动，FixedUpdate都会按照这个固定间隔执行，非常适合处理物理相关的逻辑。可以通过`Time.fixedDeltaTime`获取这个固定的时间间隔值。
</br>

**在unity中打印信息的方法**
```CSharp
//1. 没有继承MonoBehavior类时
Debug.Log("123");
Debug.LogError("123");
Debug.LogWarning("123");
//2. 继承了MonoBehavior时
print("123");
```

**生命周期函数并不是MonoBehavior的成员**
Unity帮助我们记录了场景上的所有GameObject对象以及各个关联的脚本对象, 在游戏执行的特定时期(对象创建时,失活激活时, 帧更新时)它会通过函数名反射得到脚本对象中对应的生命周期函数,然后再这些特定实际执行它们
***
# 7. Inspector窗口可编辑的变量
## 7.1 显示编辑
**private和protected修饰的变量无法显示编辑**
加上强制序列化字段特性`[SerializeField]`
序列化就是把一个对象保存到一个文件或者数据库字段中去

**让public修饰的变量也不能显示编辑**
在变量前加上特性`[HideInspector]`

**大部分默认类型都可以编辑**
但是字典以及自定义类型变量是不可以显示编辑的
但是区别在于字典怎么都不可以,但是自定义类型加上`[System.Serializable]`就可以被访问了

## 7.2 辅助特性
1. 分组说明特性Header, 为成员分组
> [Header("分组说明")]

2. 悬停注释Tooltip, 为变量添加说明
> [Tooltip("说明内容")]

3. 间隔特性 Space(), 让两个字段间出现间隔
> [Space()]

4. 修饰数值的滑条范围Range
> [Range(最小值, 最大值)]

5. 多行显示字符串 默认不写参数显示3行
写参数就是对应行
> [Multiline(4)]

6. 滚动条显示字符串 
默认不写参数就是超过3行显示滚动条
> [TextArea(3, 4)]
最少显示3行，最多4行，超过4行就显示滚动条

7. 为变量添加快捷方法 ContextMenuItem
参数1 显示按钮名
参数2 方法名 不能有参数
> [ContextMenuItem("显示按钮名", "方法名")]

8. 为方法添加特性能够在Inspector中执行
> [ContextMenu("测试函数")]

## 7.3 补充
1. Inspector窗口中的变量关联的就是对象的成员变量，运行时改变他们就是在改变成员变量
2. 拖曳到GameObject对象后 再改变脚本中变量默认值 界面上不会改变
3. 运行中修改的信息不会保存
***
# 8. MonoBehavior中的重要信息
## 8.1 重要成员
1. **获取依附的GameObject**
```CSharp
print(this.gameObject.name);
```
2. **获取依附的GameObject的位置信息**

    得到对象位置信息
    ```CSharp
    print(this.transform.position);//位置
    print(this.transform.eulerAngles);//角度
    print(this.transform.lossyScale);//缩放大小
    ```
    这种写法和上面是一样的效果 都是得到依附的对象的位置信息
    ```CSharp
    this.gameObject.transform
    ```

3. **获取脚本是否激活**
    ```CSharp
    this.enabled = false;
    ```

    获取别的脚本对象 依附的gameobject和 transform位置信息
    ```CSharp
    print(otherLesson3.gameObject.name);
    print(otherLesson3.transform.position);
    ```
## 8.2 重要方法
得到依附对象上挂载的其它脚本

1. **得到自己挂载的GameObject上的另一个脚本**
   - *根据脚本名获取* 获取脚本的方法 如果获取失败 就是没有对应的脚本 会默认返回空
   ```CSharp
   Test1 t = this.GetComponent("Test1") as Test1;
   ```
   - *根据Type获取*
   ```CSharp
   Test1 t = this.GetComponent(typeof(Test1)) as Test1;
   ```
   - **(推荐)根据泛型获取,因为不用二次转换**
   ```CSharp
   Test1 t = this.GetComponent(typeof(Test1)) as Test1;
   ```
   只要你能得到场景中别的对象或者对象依附的脚本, 那就能获取它的所有信息

2. **得到自己挂载的多个脚本**
    ```CSharp
    Test[] tests = this.GetCompenonts<Test>();

    List<Test> list = new List<Test>();
    this.GetCompenonts<Test>(list);
    ```

3. **得到当前依附的GameObject的子对象上挂载的脚本(它默认也会找自己身上是否挂载该脚本)**
   - 找单个
   ```CSharp
   //这个方法是有bool参数的,默认为false,意为子类若失活,就不再寻找该子类,不管有没有目标脚本挂载
   t = this.GetComponentInChildren<Test1>();

   //意为即使子类失活,只要挂载了Test1脚本就会获取
   t = this.GetComponentInChildren<Test1>(true);
   ```
   - 找多个
   ```CSharp
   //两种方法
   Test[] list = this.GetComponentsInChildren<Test>(true);

   List<Test> list1 = new List<Test>();
   this.GetComponentsInChildren<Test>(true, list1);
   ```

4. **得到父对象挂载的脚本(它默认也会找自己身上是否挂载该脚本)**
   - 单个
   ```CSharp
   //这个方法没有bool参数,因为父类都失活了,子类都会失活
   t = this.GetComponentInParent<Test1>();
   ```
   - 多个
   ```CSharp
   //这个方法没有bool参数,因为父类都失活了,子类都会失活
   //但是有list参数
   t = this.GetComponentsInParent<Test1>();
   ```
   以上两个方法可以理解从我自己开始为顺着族谱找到头

5. **尝试获取脚本**
    ```CSharp 
    Test1 test1;
    if(this.gameObject.TryGetComponent<Test1>(out test1))
    {
        //处理逻辑
    }
    ```
## 补充

### 如何理解this以及this.gameobject的关系以及区别
`this`: 代表该脚本本身
`this.gameobject`: 代表这个脚本依附的GameObject对象
`this.transform`: 代表这个脚本依附的GameObject对象的位置相关的信息

那问题来了,有一个GameObject,依附了Test和Test1脚本
```CSharp
Test1 t1 = this.GetComponent<Test1>();
Test1 t2 = this.gameObject.GetComponent<Test1>();

print(t1);
print(t2);
```
t2好理解,因为GameObject上依附了Test1脚本,所以好找,但是t1该怎么理解?是怎么通过脚本去找到另一个脚本的?

MonoBehaviour 类中有一个隐藏的逻辑：
当你直接调用 GetComponent() 时，它默认就是「向当前脚本所依附的 GameObject 要组件」。

MonoBehaviour 内部其实有类似这样的逻辑（简化版）：
```CSharp
public class MonoBehaviour {
    // 每个脚本都持有它所依附的GameObject的引用
    public GameObject gameObject;
    
    // GetComponent的默认实现，就是调用它所依附的GameObject的GetComponent
    public T GetComponent<T>() {
        return gameObject.GetComponent<T>();
    }
}
```
***
# 9. GameObject
## 9.1 成员变量
- 名字
```CSharp
this.gameObject.name;
```
- 是否激活
 ```CSharp
this.gameObject.activeSelf;
```
- 是否静态
```CSharp
this.gameObject.isStatic;
```
- 层级
```CSharp
this.gameObject.layer;
```
- 标签
```CSharp
this.gameObject.tag;
```

## 9.2 静态方法
### ①. 创建自带几何体
```CSharp
GameObject.CreatePrimitive(PrimitiveType.Cube);//立方体
```
### ②. 查找对象
#### (1)查找单个对象
- 通过对象名查找,这个查找效率比较低下,因为它会去遍历场景里的所有对象,没有找到会返回null
```CSharp
GameObject obj2 = GameObject.Find("长方体");
```
- 通过tag查找
```CSharp
GameObject obj3 = GameObject.FindWithTag("Player");
GameObject obj3 = GameObject.FindGameObjectWithTag("Player");//这两方法效果一样
```
> 以上两种方法是不把失活对象当做寻找目标的
> 如果场景中有多个满足条件的对象,我们无法得知获取的对象是哪一个

#### (2)查找多个对象
- 找多个对象的API,只能是通过tag去找,没有通过名字查找的API
```CSharp
GameObject[] objects = GameObject.FindGameObjectsWithTag("Player");
```
> 也不会把失活对象当做寻找目标的
- Object提供的方法, 它可以找到场景中挂载的某一脚本对象,效率巨低
```CSharp
Test o = GameObject.FindObjectOfType<Test>();
```
> C#的object是System.Object,是所有类的基类
> unity的Object是UnityEngine.Object,两个虽然同名,但命名空间不同,不是一个东西

### ③实例化对象(重要)
- 根据一个GameObject对象,创建出一个和它一模一样的对象(可以是场景中的对象,也可以是预制体)
```CSharp
GameObject obj5 = GameObject.Instantiate(myObj);
```
- 删除对象的方法, Destroy不仅可以删除对象,还可以删除指定脚本
```CSharp
GameObject.Destroy(obj);
GameObject.Destroy(obj,5);//后面参数代表延迟多少秒
GameObject.DestroyImmediate(obj);//立马移除一个对象,不会等到下一帧
```
> Destroy方法不会马上移除对象,只是给这个对象加了一个移除标识, 一般情况下,它会在下一帧把这个对象从内存中移除
> 如果没有特殊需求,建议不要用DestroyImmediate方法,因为Destroy方法是异步的,能降低卡顿的概率

- 过场景不移除, 默认情况 在切换场景时, 场景中对象都会被自动删除掉
- 如果你希望某个对象 过场景不被移除, 下面这句代码 就是不想谁过场景被移除 就传谁 
- 一般都是传 依附的GameObject对象
```CSharp
//自己依附的GameObject对象 过场景不被删除
GameObject.DontDestroyOnLoad(this.gameObject);
```
## 9.3 成员方法
#### 创建空物体
```CSharp
//new一个GameObject就是在创建一个空物体
GameObject obj1 = new GameObject();
GameObject obj2 = new GameObject("空物体");
GameObject obj3 = new GameObject("空物体", typeof(Test1),typeof(Test2));
```
#### 为对象添加脚本
继承MonoBehavior的脚本 是不能够去new 的, 如果想要动态的添加继承MonoBehavior的脚本 在某一个对象上, 直接使用GameObject提供的方法即可

```CSharp
Test1 t1 = obj1.AddComponent(typeof(Test1)) as Test1;
Test2 t2 = obj1.AddComponent<Lesson2>();
```
#### 标签比较
```CSharp
if(this.gameObject.CompareTag("Player")){} 
//等同于下面这句
if(this.gameObject.tag == "Player"){}
```

#### 设置激活失活
```CSharp
t1.SetActive(false);
```

#### 通过广播或者发送消息的形式 让自己或者别人 执行某些行为方法
通知自己 执行什么行为, 命令自己 去执行这个TestFun这个函数 会在自己身上挂载的所有脚本去找这个名字的函数
它会去找到 自己身上所有的脚本 有这个名字的函数去执行
```CSharp
this.gameObject.SendMessage("TestFun");
```

```CSharp
//广播行为 让自己和自己的子对象执行
this.gameObject.BroadcastMessage("函数名");

//向父对象和自己发送消息 并执行
this.gameObject.SendMessageUpwards("函数名");
```
***
# 10. Time
## ①时间缩放比例
```CSharp
//时间停止
Time.timeScale = 0;
//回复正常
Time.timeScale = 1;
//2倍速
Time.timeScale = 2;
```
## ②帧间隔时间
最近的一帧用了多长时间, 帧间隔时间 主要是用来计算位移
路程 = 时间*速度
根据需求 选择参与计算的间隔时间
如果希望 游戏暂停时就不动的 那就使用deltaTime
如果希望 不受暂停影响 unscaledDeltaTime
- 不受scale影响
```CSharp
print("帧间隔时间" + Time.deltaTime);
```
- 不受scale影响的帧间隔时间
```CSharp
print("不受scale影响的帧间隔时间" + Time.unscaledDeltaTime);
```

## ③游戏开始到现在的时间
它主要用来计时 单机游戏中计时
```CSharp
//受scale影响
print("游戏开始到现在的时间:" + Time.time);
//不受scale影响
print("不受scale影响的游戏开始到现在的时间:" + Time.unscaledTime);
```

## ④物理间隔时间
```CSharp
//受scale影响
print(Time.fixedDeltaTime);
//不受scale影响
print(Time.fixedUnscaledDeltaTime);
```

## ⑤帧数
```CSharp
//从开始到现在游戏跑了多少帧(次循环)
print(Time.frameCount);
```

***
# 11. Transform

## 11.1 位置
**Transform**: GameObject的位移,旋转,缩放,父子关系,坐标转换等相关操作都由它处理

### (1)Vector3
Vector3主要是用来表示三维坐标系中的一个点或者一个向量
- 声明
```CSharp
Vector3 v = new Vector3();//不传参默认为0
```
- 常用
```CSharp
print(Vector3.zero);    // {0, 0, 0}
print(Vector3.left);    // {1, 0 , 0}
print(Vector3.right);   // {-1, 0, 0}
print(Vector3.forward); // {0, 0, 1}
print(Vector3.back);    // {0, 0, -1}
print(Vector3.up);      // {0, 1, 0}
print(Vector3.down);    // {0, -1, 0}

//计算两个点的距离
Vector3.Distance(传两个点);
```
### (2)位置
- 相对世界坐标系
```CSharp
//如果对象有父子关系, 且父对象不在世界原点,那么打印出来的信息和面板上是不一致的
print(this.gameObject.transform);
print(this.transform);//两句等同
```
- 相对父对象
```CSharp
//如果你想以面板坐标为准来进行位置设置
print(this.transform.localPosition)
```
位置赋值不能直接改变下x,y,z; 只能整体改变
```CSharp
this.transform.position.x = 10; // 这样是不行的
```
- ①直接赋值
```CSharp
this.transform.position = new Vector3(20, this.transform.position.y, this.transform.position.z);
```
- ②先取出 再赋值
```CSharp
//虽然不能直接改 transform 的 xyz 但是 Vector3 是可以直接改 xyz 的
Vector3 pos = this.transform.localPosition;
pos.x = 10;
this.transform.localPosition = pos;
```
### (3)对象的当前的各个朝向
```CSharp
//面朝向
print(this.transform.forward);
//头顶朝向
print(this.transform.up);
//右朝向
print(this.transform.right);
```
## 11.2 位移
### 公式计算
- 局部坐标系朝向
```CSharp
//路径 = 方向 * 速度 * 时间 
this.transform.position += (this.transform.forward * 1 * Time.deltaTime);
```
- 世界坐标系朝向
```CSharp
this.transform.position += (Vector3.forward * 1 * Time.deltaTime);
```

### API
一般会使用API
```CSharp
//参数一: 位移多少
//参数二: 相对坐标系, 默认为局部坐标系
this.transform.Translate(Vector3.forward * 1 * Time.deltaTime,Space.World);
```

## 11.3 角度和旋转
### 角度
```CSharp
//相对世界坐标角度
print(this.transform.eulerAngles);

//相对父对象角度
print(this.transform.localEulerAngles);
```
注意：设置角度和设置位置一样 不能单独设置xyz 要一起设置

### 旋转
- 自转
```CSharp
//每个轴 具体转多少度
//第一个参数 相当于 是旋转的角度 每一帧 
//第二个参数 默认不填 就是相对于自己坐标系 进行的旋转
this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime, Space.World);
```
- 相对于轴
```CSharp
//参数一：是相对哪个轴进行转动
//参数二：是转动的 角度 是多少
//参数三：默认不填 就是相对于自己的坐标系 进行旋转
//       如果填  可以填写相对于 世界坐标系进行旋转
this.transform.Rotate(Vector3.right, 10 * Time.deltaTime, Space.World);
```
- 相对于某一点
```CSharp
//参数一：相对于哪一个点 转圈
//参数二：相对于那一个点的 哪一个轴转圈
//参数三：转的度数  旋转速度 * 时间
this.transform.RotateAround(Vector3.zero, Vector3.right, 10 * Time.deltaTime);
```
***
# 12. 缩放
```CSharp
//相对世界坐标系
print(this.transform.lossyScale);
//相对本地坐标系（父对象）
print(this.transform.localScale);
```
注意: 同样缩放不能只改xyz, 只能一起改, 且相对于世界坐标系的缩放大小只能得不能改; unity没有提供缩放相关的API

***
# 13. 看向
让一个对象的面朝向 可以一直看向某一个点或者某一个对象
```CSharp
this.transform.LookAt(lookAtObj);
```
***
# 14. 父子关系
## (1) 获取父对象
```CSharp
public Transform EarthPosition;
this.transform.parent = EarthPosition;
```
- API
```CSharp
this.transform.SetParent(null);
this.transform.SetParent(EarthPosition);

//参数一：父类
//参数二：是否保留世界坐标的 位置 角度 缩放 信息
//       true  会保留 世界坐标下的状态  和 父对象 进行计算 得到本地坐标系的信息
//       false 不会保留 会直接把世界坐标系下的 位置角度缩放 直接赋值到 本地坐标系下 
this.transform.SetParent(EarthPosition,false);
```
## (2) 断绝父子关系
只能影响直接的父子关系,直接的不行
```CSharp
this.transform.DetachChildren();
```
## (3) 获取子对象
①按名字查找
Find方法 是能够找到 失活的对象的, GameObject相关的 Find() 是不能找到失活对象的, 且也是对于直接父子关系来说的
```CSharp
print(this.transform.Find("Cube").name);
```
②遍历的方式
失活的子类也会算数量, 且也是对于直接父子关系
```CSharp
print(this.transform.childCount);
```
通过索引号 去得到自己对应的子类
```CSharp
this.transform.GetChild(0);
```

## (4) 子类的操作
①判断父类
```CSharp
public Transform son;
//判断自己是不是另一个对象的儿子
if(son.IsChildOf(this.transform))
{
    print("是我的儿子");
}
```
②得到自己作为子类的编号
```CSharp
print(son.GetSiblingIndex());
```
③把自己设置为第一个子类
```CSharp
son.SetAsFirstSibling();
```
④把自己设置为最后一个子类
```CSharp
son.SetAsLastSibling();
```
⑤把自己设置为指定编号的子类
```CSharp
//就算你填的数量 超出了范围（负数或者更大的数） 不会报错 会直接设置成最后一个编号
son.SetSiblingIndex(1);
```
***
# 15. 坐标转换
## 15.1 世界坐标转局部坐标(本地坐标)

**世界坐标系的点 转换 为相对本地坐标系的点**
- 受到缩放影响
```CSharp
print("转换后的点 " + this.transform.InverseTransformPoint(Vector3.forward));
```

**世界坐标系的方向 转换 为相对本地坐标系的方向**
- 不受缩放影响
```CSharp
print("转换后的方向" + this.transform.InverseTransformDirection(Vector3.forward));
```
- 受缩放影响
```CSharp
print("转换后的方向(受缩放影响)" + this.transform.InverseTransformVector(Vector3.forward));
```

## 15.2 本地坐标转世界坐标
**本地坐标系的点 转换 为相对世界坐标系的点**
- 受到缩放影响
```CSharp
print("本地 转 世界 点" + this.transform.TransformPoint(Vector3.forward));
```
**本地坐标系的方向 转换 为相对世界坐标系的方向** 
- 不受缩放影响
```CSharp
print("本地 转 世界 方向" + this.transform.TransformDirection(Vector3.forward));
```
- 受缩放影响
```Csharp
print("本地 转 世界 方向" + this.transform.TransformVector(Vector3.forward));
```

## 举个例子
```CSharp
[ContextMenu("左前方创建空物体")]
void GenerateEmpty()
{
    GameObject obj = new GameObject("左前方");
    obj.transform.position = this.transform.TransformPoint(-1, 0, 1);
}

[ContextMenu("前方创建3个球体")]
void GenerateThreeBall()
{
    for (int i = 1; i <= 3; ++i)
    {
        GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        obj.transform.position = this.transform.InverseTransformPoint(Vector3.forward * i);
    }
}
```
以上内容挂载在一个坐标为(10,0,10)的立方体上
第一段代码用`TransformPoint`,意为 "立方体的局部位置在世界中的哪里？" ,考虑世界坐标得出的结果(10-1, 0, 10+1) => (-9, 0, 11)
第二段代码用`InverseTransformPoint`, 意为 "世界坐标(0,0,i)相对于立方体的局部坐标是多少？" 
***
# 16. Input鼠标键盘输入
输入相关内容肯定是写在Update中的

## 16.1 鼠标在屏幕位置
屏幕坐标的原点 是在 屏幕的左下角  往右是X轴正方向 往上时Y轴正方向
返回值是Vector3, 但是只有 x和y有值 z一直是0 是因为屏幕本来就是2D的 不存在Z轴
```CSharp
print(Input.mousePosition);
```
## 16.2 检测鼠标输入
鼠标按下一瞬间 进入
0左键 1右键 2中键
```CSharp
//只要按下的这一瞬间 进入一次 返回一个bool值
if(Input.GetMouseButtonDown(0)) { };

//鼠标抬起一瞬间 进入
if(Input.GetMouseButtonUp(0)) { };

//鼠标长按按下抬起都会进入
//就是 当按住按键不放时 会一直进入 这个判断
if( Input.GetMouseButton(1)) { }

//中键滚动
//返回值的 y, -1往下滚  0没有滚  1往上滚
//它的返回值 是Vector的值 我们鼠标中键滚动 会改变其中的Y值
print(Input.mouseScrollDelta);
```

## 16.3检测键盘输入
```CSharp
//键盘按下
if( Input.GetKeyDown(KeyCode.W) ){};

//传入字符串的重载
//这里传入的 字符串 不能是大写的 不然会报错
//只能传入小写字符串
if( Input.GetKeyDown("q") ){};

//键盘抬起
if( Input.GetKeyUp(KeyCode.W) ){};

//键盘长按
if( Input.GetKey(KeyCode.W) ){};
```

## 检测默认轴输入
Unity提供了 更方便的方法 来帮助我们控制 对象的 位移和旋转
```CSharp
//键盘AD按下时 返回 -1到1之间的变换
//相当于 得到得这个值 就是我们的 左右方向 我们可以通过它来控制 对象左右移动 或者左右旋转
Input.GetAxis("Horizontal");

//键盘SW按下时 返回 -1到1之间的变换
//得到得这个值 就是我们的 上下方向 我们可以通过它来控制 对象上下移动 或者上下旋转
Input.GetAxis("Vertical");

//鼠标横向移动时 -1 到 1 左 右
Input.GetAxis("Mouse X");

//鼠标竖向移动时  -1 到 1 下 上
Input.GetAxis("Mouse Y");
```
我们默认的 GetAxis方法 是有渐变的 会总 `-1 ~ 0 ~ 1`之间 渐变 会出现小数
`GetAxisRaw`方法 和 `GetAxis`使用方式相同, 只不过 它的返回值 只会是 `-1 0 1` 不会有中间值

## 16.4 其他
```CSharp
//是否有任意键或鼠标长按
if(Input.anyKey){};

//是否有任意键或鼠标按下
if(Input.anyKeyDown){};

//这一帧的键盘输入
print(Input.inputString);

//手柄输入相关
//得到连接的手柄的所有按钮名字
string[] strs = Input.GetJoystickNames();

//某一个手柄键按下
if( Input.GetButtonDown("Jump") ){};

//某一个手柄键抬起
if (Input.GetButtonUp("Jump")){};

//某一个手柄键长按
if (Input.GetButton("Jump")){}; 

//移动设备触摸相关
if(Input.touchCount > 0)
{
    Touch t1 = Input.touches[0];
    //位置
    print(t1.position);
    //相对上次位置的变化
    print(t1.deltaPosition);
}

//是否启用多点触控
Input.multiTouchEnabled = false;


//陀螺仪（重力感应）
//是否开启陀螺仪 必须开启 才能正常使用
Input.gyro.enabled = true;
//重力加速度向量
print(Input.gyro.gravity);
//旋转速度
print(Input.gyro.rotationRate);
//陀螺仪 当前的旋转四元数 
//比如 用这个角度信息 来控制 场景上的一个3D物体受到重力影响
//手机怎么动 它怎么动
print(Input.gyro.attitude);
```
***
# 17.Screen
## 17.1 静态属性
### 常用
- 当前屏幕分辨率
```CSharp
Resolution r = Screen.currentResolution;
print("当前屏幕分辨率的宽" + r.width + "高" + r.height);
```
- 屏幕窗口当前宽高
```CSharp
//这得到的 是当前 窗口的 宽高 不是设备分辨率的宽高
//一般写代码 要用窗口宽高 做计算时 就用他们
print(Screen.width);
print(Screen.height);
```
- 屏幕休眠模式 
```CSharp
Screen.sleepTimeout = SleepTimeout.NeverSleep;
```

### 不常用
- 运行时是否全屏
```CSharp
Screen.fullScreen = true;
```
- 窗口模式
```CSharp
//窗口模式
Screen.fullScreenMode = FullScreenMode.Windowed;
//独占全屏FullScreenMode.ExclusiveFullScreen
//全屏窗口FullScreenMode.FullScreenWindow
//最大化窗口FullScreenMode.MaximizedWindow
//窗口模式FullScreenMode.Windowed
```
- 移动设备屏幕转向相关
```CSharp
//允许自动旋转为左横向 Home键在左
Screen.autorotateToLandscapeLeft = true;
//允许自动旋转为右横向 Home键在右
Screen.autorotateToLandscapeRight = true;
//允许自动旋转到纵向 Home键在下
Screen.autorotateToPortrait = true;
//允许自动旋转到纵向倒着看 Home键在上
Screen.autorotateToPortraitUpsideDown = true;
```
- 指定屏幕显示方向
```CSharp
Screen.orientation = ScreenOrientation.Landscape;
```

## 17.2 静态方法
- 设置分辨率 一般移动设备不使用
```CSharp
Screen.SetResolution(1920, 1080, false);
```
***
# 18. Camera可编辑的参数

## Clear Flags
- Depth Only: 只画该层, 背景透明
- Don`t Clear: 不移除, 覆盖渲染

## Culling Mask
选择性渲染部分层级

## Depth
**默认为-1, 在只有一个摄像机的情况下没有任何作用**
层级高的摄像机,渲染级别靠后,显示的图像靠前
举个例子: A摄像机深度-1, B摄像机为0, A会被先渲染, 呈现出一个图像, B会后渲染, 也呈现出一个图像, 那只会显示B摄像机的画面; 想象一个画架, 你画了一幅画(用白纸画的),放到了画架上, 你管这张画的深度记为-1, 然后又画了一幅画, 叠在-1的画之上, 你又管这张叠上的画的深度为0, 自然深度为0的画会挡住深度为-1的画, 你也就只能看到深度为0的那幅画

**为什么我上面要强调用什么画的呢?**
因为是有方法让两张画的内容叠加的, 先别想怎么叠加的,先想为什么会有叠加这一功能? 你在玩游戏的时候,你会发现UI是UI, 游戏内容是游戏内容, 它们互不影响, 这里就是把UI叠加到游戏画面的方法, 其中一个摄像机渲染UI, 一个摄像机渲染游戏

**再回头来解释怎么叠加的?**
在Clear Flags里的, 你可以理解为用什么材质的画布去画画, 天空盒就是已经画好的背景, Depth Only就是在用玻璃画画,当然需要配合Culling Mask来使用,决定画在哪一层,这样你渲染出的图就是一个透明背景,但是只渲染你想要的物体的一张图

**总结就是, `Depth Only`与`Culling Mask`与`Depth`是配合使用的,缺一不可**

## Target Texture
在Project窗口中右键可以创建一个`Render Texture` 
可以把摄像机画面渲染到一张图上, 如此设置后, 该摄像机渲染不会影响到Game窗口最终的输出
主要用于做小地图

## Occlusion Culling
是否开启剔除遮挡

如下图, 这是一个俯视图, 可以看到前方正方体挡住了后方的圆,那么开启Occlusion Culling后,将不再渲染这个圆,可以用来提升性能
<center>

![alt](/Unity/图片/Unity入门09-21_16-34-39.jpg)

</center>

## Viewport Rect(从这往下的是不太常用的)
视口范围, 屏幕上将绘制该摄像机视图的范围
主要用于多摄像机游戏, 0-1相当于宽高百分比

**Rendering Path**, 渲染路径
**Allow HDR**, 是否允许高动态范围渲染
**Allow MSAA**, 是否运行抗锯齿
**Allow Dynamic Resolution**, 是否允许动态分辨率呈现
**Target Display**, 用于哪个显示器
***

# 19. Camera代码相关
## 19.1 重要静态成员
### (1) 获取摄像机
- 主摄像机的获取
```CSharp
//如果想通过这种方式 快速获取摄像机 那么场景上必须有一个 tag为MainCamera的摄像机
print(Camera.main.name);
```
- 获取摄像机的数量
```CSharp
print(Camera.allCamerasCount);
```
- 得到所有摄像机
```CSharp
Camera[] allCamera = Camera.allCameras;
print(allCamera.Length);
```
### (2) 渲染相关委托
- 摄像机剔除前处理的委托函数 
```CSharp
Camera.onPreCull += (c) =>{};
```
- 摄像机渲染前处理的委托
```CSharp
Camera.onPreRender += (c) =>{};
```
- 摄像机 渲染后 处理的委托
```CSharp
Camera.onPostRender += (c) =>{};
```

## 19.2 重要静态成员
### (1) 界面上的参数
```CSharp
//比如 下面这句代码 就是得到主摄像机对象 上的深度 进行设置
Camera.main.depth = 10;
```

### (2) 世界坐标转屏幕坐标
转换过后 x和y对应的就是屏幕坐标 z对应的 是 这个3D物体 里我们的摄像机有多远
我们会用这个来做的功能 最多的 就是头顶血条相关的功能
```CSharp
Vector3 v = Camera.main.WorldToScreenPoint(this.transform.position);
```
### (3) 屏幕坐标转世界坐标
只所以改变Z轴 是因为 如果不改 Z默认为0
转换过去的世界坐标系的点 永远都是一个点 可以理解为 视口 相交的焦点
如果改变了Z 那么转换过去的 世界坐标的点 就是相对于 摄像机前方多少的单位的横截面上的世界坐标点
```CSharp
Vector3 v = Input.mousePosition;
v.z = 5;
obj.position = Camera.main.ScreenToWorldPoint(v);
```
***
# 20. 光源系统
## 20.1 光源组件
**Type**
光源类型:
Spot(聚光灯), Directional(方向光,环境光), Point(点光源), Area(面光源)

**Color**
颜色

**Mode**
光源模式
- Realtime: 实时光源, 每帧实时计算, 效果好, 性能消耗大
- Baked: 烘焙光源, 事先计算好, 无法动态变化
- Mixed: 混合光源, 预先计算 + 实时运算

**Intensity**
光源亮度

**Shadow Type**
- NoShadows: 关闭阴影
- HardShadows: 硬阴影(生硬阴影)
- SoftShadows: 软阴影(柔和阴影)
***

