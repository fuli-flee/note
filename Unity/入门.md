b[toc]
***
# 1. 工程文件夹
![alt](/Unity/图片/image.png)
- Assets: 工程资源文件夹(美术资源,脚本等)
- Library: 库文件夹(Unity自动生成管理)
- Logs: 日志文件夹,记录特殊信息
- obj: 编译产生中间文件
- Packages: 包配置信息
- ProjectSettings: 工程设置信息

只要这个Assets文件夹不丢,工程就能打开,其他的unity会帮你生成,但是里面的配置就未必是之前的了
***
# 2. Scene和Hierarchy窗口
层级窗口中看到的内容就是场景窗口中的显示对象

## 2.1 Hierarchy 层级窗口
层级窗口中显示的就是一个场景中的所有对象
Hierarchy窗口就是创建,拖动,操作的一个功能面板

**操作**
**Duplicate**这个可以理解为复制粘贴一步到位,快捷键为`Ctrl+D`

## 2.2 Scene 场景窗口
![alt text](/Unity/图片/image2.png)

**坐标轴**
以屏幕为参照
- 垂直屏幕向内为+Z
- 平行屏幕向右为+X
- 垂直屏幕向上为+Y

![alt text](/Unity/图片/image3.png)
***
# 3. Game游戏窗口和Project工程窗口
## 3.1 Game游戏窗口
![alt text](/Unity/图片/image5.png)
- Warn if No Cameras Rendering: 场景中没有摄像机时会发出警告
- Clear Every Frame in Edit Mode: 游戏未播放时,也更新Game窗口,避免显示问题

![alt text](/Unity/图片/image4.png)
## 2.3 Project工程窗口
Packages文件夹: 放的是官方拓展包
***
# 3. 工具栏和父子关系
## 3.1 工具栏
![alt text](/Unity/图片/image6.png)
- File(文件操作): 新建工程, 新建场景, 工程打包等
- Edit(编辑操作): 对象编辑操作相关, 工程设置, 引擎设置相关
- Assets(资源操作): 基本等同于Project窗口中右键相关功能
- GameObject(对象操作): 基本等同于Hierarchy窗口中右键相关功能
- Component(脚本操作): Unity自带的脚本, 可以添加各系统重的脚本
- Window(窗口): 可以打开Unity各核心系统的窗口
- Help(帮助): 检查更新, 查看版本等

**Edit中的Project Settings**

Edit中的Project Settings中的选项其实就是对应的你Project Settings文件夹中的资源,修改过后的配置会存入到Project Settings中的配置文件
![alt text](/Unity/图片/image7.png)

**Edit中的Preference**
External Tools中可以更改你默认打开的IDE
![alt text](/Unity/图片/Snipaste_2025-09-18_09-32-07.jpg)
- Ctrl+Alt+F: 将物体移动到视口中心 
- Ctrl+Shift+F: 将物体移动到视口位置
![alt text](/Unity/图片/Snipaste_2025-09-18_10-01-04.jpg)

***
# 4.Unity中的反射机制和游戏场景的本质
## 回顾
程序正在运行时可以查看其他程序集或者自身的元数据, 一个运行的程序查看本身或者其他程序的元数据的行为就叫反射

## 对象的本质
- GameObject类对象是Unity提供的作为场景中所有对象的根本
- 在游戏场景中出现一个对象, 不管是图片, 模型, 音效, 摄像机等都是依附于GameObject对象的
- 而Transform是GameObject对象必不可少的一个依附对象
- 相当与就是用一个**Transform类对象**和**GameObject类对象**(注意这里都是类对象)进行关联, 用于设置位置和缩放

举例说明:
1. 修改Inspector面板中的Transform内容
> 利用反射: 已知对象, 类名, 变量名, 通过反射为该对象设置变量值
1. 新建一个脚本后,添加给一个指定的GameObject对象
> 已知类名, 可以获取所有公共成员,故可以在Inspector面板上创建各个公共字段信息

## 游戏场景的本质
- 游戏场景文件, 后缀为`.unity`,它的本质就是一个配置文件
- unity有一套自己识别处理它的机制
- 本质就是把场景对象相关信息读取出来,通过反射来创建各个对象关联各个脚本对象

***
# 4. 预制体(预设体)
- Unpack Prefab: 和之前的预制体取消关联
***
# 5. 脚本
类名和文件名必须一致,不然无法挂载(因为反射机制创建对象, 会通过文件名去找Type)
## 5.1 MonoBehavior
1. 创建的脚本默认都继承MonoBehavior, 继承了它才能够挂载在GameObject上
2. 继承了的MonoBehavior的脚本不能new,只能挂
3. 继承了MonoBehavior的脚本不要写构造函数,你都不能new,你写构造函数也没有意义了
4. 继承了MonoBehavior的脚本可以在一个对象上挂多个(在没有加DisallowMultipleComponent特性(不允许多次挂载,包括其子类)的情况下)
5. 继承MonoBehavior的类可以再次被继承, 遵循面向对象继承多态的规则

**不继承MonoBehavior的类**
1. 不能挂载到GameObject上
2. 想怎么写就怎么写, 要使用的时候需要自己new
3. 一般是单例模式的类(用于管理模块) 或者数据结构类(用于存储数据)
4. 不用保留默认出现的生命周期函数

**设置执行顺序**
![alt text](/Unity/图片/Snipaste_09-18_11-54-34.jpg)

**改变默认脚本内容**
要管理员权限
> Editor\Data\Resource\ScriptTemplates

***
# 6. 生命周期函数
## 概念
所有继承MonoBehavior的脚本,最终都会挂载到GameObject游戏对象上
生命周期函数就是该脚本对象依附的GameObject对象从出生到消亡整个生命周期中会通过反射自动调用的一些特殊函数

unity帮助我们记录了一个GameObject对象依附了哪些脚本, 会自动的得到这些对象, 通过反射去执行一些固定名字的函数

## 生命周期函数
!!! important 注意
    生命周期函数的访问修饰符一般为private和protected
    因为不需要在外部自己调用生命周期函数, 都是Unity自己帮助我们调用的
    生命周期函数支持继承多态

<center>

![alt text](/Unity/图片/Unity入门09-18_21-22-08.jpg)

</center>

1. **Awake**
当对象(自己这个类对象)**被创建时**才会调用该声明周期函数, **只会调用一次**
类似构造函数的存在, 我们可以在一个类对象刚创建时进行一些初始化操作
</br>

2. **OnEnable**
依附的GameObject对象**每次激活时调用**
当想要一个对象被激活时, 进行一些逻辑处理,就可以写在这个函数中
</br>

3. **Start**
**只会调用一次**,主要作用还是用于初始化信息的
当在update函数里动态创建对象时,会立马调用Awake函数,而start则会等到下一帧开始时调用
</br>

4. **FixedUpdate**
主要用于进行物理更新,它是每一帧都执行的,但是它的每一帧是可控的,且它运行的帧和其他update函数不一样,默认间隔时间是0.02s
</br>

5. **Update**
主要用于**处理游戏核心逻辑更新**的函数
</br>

6. **LaterUpdate**
一般用来**处理摄像机位置更新**相关内容
Update和LaterUpdate之间,unity会处理动画相关的更新
</br>

7. **OnDisable**
依附的GameObject对象**每次失活时调用**
当对象失活时,依附其上的生命周期函数都会停止调用
</br>

8. **OnDestroy**
**只调用一次**, 当一个对象销毁的时候会先调用一次OnDisable再调用OnDestroy



## 拓展
**Update和FixedUpdate时间间隔的区别**
1. Update 的时间间隔不固定
    Update的调用频率与游戏帧率（FPS）相关，每帧调用一次。如果帧率波动（比如从 60FPS 降到 30FPS），两次Update之间的时间间隔会相应变化（从约 16.7ms 变为约 33.3ms）。可以通过`Time.deltaTime`获取上一帧到当前帧的实际时间间隔，用于在移动、旋转等操作中进行时间补偿。
    
2. FixedUpdate 的时间间隔固定
    FixedUpdate的调用频率由项目设置中的 "Fixed Timestep"决定，时间间隔是固定的。无论帧率如何波动，FixedUpdate都会按照这个固定间隔执行，非常适合处理物理相关的逻辑。可以通过`Time.fixedDeltaTime`获取这个固定的时间间隔值。

</br>

**在unity中打印信息的方法**
```CSharp
//1. 没有继承MonoBehavior类时
Debug.Log("123");
Debug.LogError("123");
Debug.LogWarning("123");
//2. 继承了MonoBehavior时
print("123");
```
***

