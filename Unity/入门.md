[toc]
***
# 1. 工程文件夹
![alt](/Unity/图片/image.png)
- Assets: 工程资源文件夹(美术资源,脚本等)
- Library: 库文件夹(Unity自动生成管理)
- Logs: 日志文件夹,记录特殊信息
- obj: 编译产生中间文件
- Packages: 包配置信息
- ProjectSettings: 工程设置信息

只要这个Assets文件夹不丢,工程就能打开,其他的unity会帮你生成,但是里面的配置就未必是之前的了
***
# 2. Scene和Hierarchy窗口
层级窗口中看到的内容就是场景窗口中的显示对象

## 2.1 Hierarchy 层级窗口
层级窗口中显示的就是一个场景中的所有对象
Hierarchy窗口就是创建,拖动,操作的一个功能面板

**操作**
**Duplicate**这个可以理解为复制粘贴一步到位,快捷键为`Ctrl+D`

## 2.2 Scene 场景窗口
![alt text](/Unity/图片/image2.png)

**坐标轴**
以屏幕为参照
- 垂直屏幕向内为+Z
- 平行屏幕向右为+X
- 垂直屏幕向上为+Y

![alt text](/Unity/图片/image3.png)
***
# 3. Game游戏窗口和Project工程窗口
## 3.1 Game游戏窗口
![alt text](/Unity/图片/image5.png)
- Warn if No Cameras Rendering: 场景中没有摄像机时会发出警告
- Clear Every Frame in Edit Mode: 游戏未播放时,也更新Game窗口,避免显示问题

![alt text](/Unity/图片/image4.png)
## 2.3 Project工程窗口
Packages文件夹: 放的是官方拓展包
***
# 3. 工具栏和父子关系
## 3.1 工具栏
![alt text](/Unity/图片/image6.png)
- File(文件操作): 新建工程, 新建场景, 工程打包等
- Edit(编辑操作): 对象编辑操作相关, 工程设置, 引擎设置相关
- Assets(资源操作): 基本等同于Project窗口中右键相关功能
- GameObject(对象操作): 基本等同于Hierarchy窗口中右键相关功能
- Component(脚本操作): Unity自带的脚本, 可以添加各系统重的脚本
- Window(窗口): 可以打开Unity各核心系统的窗口
- Help(帮助): 检查更新, 查看版本等

**Edit中的Project Settings**

Edit中的Project Settings中的选项其实就是对应的你Project Settings文件夹中的资源,修改过后的配置会存入到Project Settings中的配置文件
![alt text](/Unity/图片/image7.png)

**Edit中的Preference**
External Tools中可以更改你默认打开的IDE
![alt text](/Unity/图片/Snipaste_2025-09-18_09-32-07.jpg)
- Ctrl+Alt+F: 将物体移动到视口中心 
- Ctrl+Shift+F: 将物体移动到视口位置
![alt text](/Unity/图片/Snipaste_2025-09-18_10-01-04.jpg)

***
# 4.Unity中的反射机制和游戏场景的本质
## 回顾
程序正在运行时可以查看其他程序集或者自身的元数据, 一个运行的程序查看本身或者其他程序的元数据的行为就叫反射

## 对象的本质
- GameObject类对象是Unity提供的作为场景中所有对象的根本
- 在游戏场景中出现一个对象, 不管是图片, 模型, 音效, 摄像机等都是依附于GameObject对象的
- 而Transform是GameObject对象必不可少的一个依附对象
- 相当与就是用一个**Transform类对象**和**GameObject类对象**(注意这里都是类对象)进行关联, 用于设置位置和缩放

举例说明:
1. 修改Inspector面板中的Transform内容
> 利用反射: 已知对象, 类名, 变量名, 通过反射为该对象设置变量值
1. 新建一个脚本后,添加给一个指定的GameObject对象
> 已知类名, 可以获取所有公共成员,故可以在Inspector面板上创建各个公共字段信息

## 游戏场景的本质
- 游戏场景文件, 后缀为`.unity`,它的本质就是一个配置文件
- unity有一套自己识别处理它的机制
- 本质就是把场景对象相关信息读取出来,通过反射来创建各个对象关联各个脚本对象

***
# 4. 预制体(预设体)
- Unpack Prefab: 和之前的预制体取消关联
***
# 5. 脚本
类名和文件名必须一致,不然无法挂载(因为反射机制创建对象, 会通过文件名去找Type)
## 5.1 MonoBehavior
1. 创建的脚本默认都继承MonoBehavior, 继承了它才能够挂载在GameObject上
2. 继承了的MonoBehavior的脚本不能new,只能挂
3. 继承了MonoBehavior的脚本不要写构造函数,你都不能new,你写构造函数也没有意义了
4. 继承了MonoBehavior的脚本可以在一个对象上挂多个(在没有加DisallowMultipleComponent特性(不允许多次挂载,包括其子类)的情况下)
5. 继承MonoBehavior的类可以再次被继承, 遵循面向对象继承多态的规则

**不继承MonoBehavior的类**
1. 不能挂载到GameObject上
2. 想怎么写就怎么写, 要使用的时候需要自己new
3. 一般是单例模式的类(用于管理模块) 或者数据结构类(用于存储数据)
4. 不用保留默认出现的生命周期函数

**设置执行顺序**
![alt text](/Unity/图片/Snipaste_09-18_11-54-34.jpg)

**改变默认脚本内容**
要管理员权限
> Editor\Data\Resource\ScriptTemplates

***
# 6. 生命周期函数
## 概念
所有继承MonoBehavior的脚本,最终都会挂载到GameObject游戏对象上
生命周期函数就是该脚本对象依附的GameObject对象从出生到消亡整个生命周期中会通过反射自动调用的一些特殊函数

unity帮助我们记录了一个GameObject对象依附了哪些脚本, 会自动的得到这些对象, 通过反射去执行一些固定名字的函数

## 生命周期函数

!!! important 注意
    生命周期函数的访问修饰符一般为private和protected
    因为不需要在外部自己调用生命周期函数, 都是Unity自己帮助我们调用的
    生命周期函数支持继承多态

<center>

![alt text](/Unity/图片/Unity入门09-18_21-22-08.jpg)

</center>

1. **Awake**
当对象(自己这个类对象)**被创建时**才会调用该声明周期函数, **只会调用一次**
类似构造函数的存在, 我们可以在一个类对象刚创建时进行一些初始化操作
</br>

2. **OnEnable**
依附的GameObject对象**每次激活时调用**
当想要一个对象被激活时, 进行一些逻辑处理,就可以写在这个函数中
</br>

3. **Start**
**只会调用一次**,主要作用还是用于初始化信息的
当在update函数里动态创建对象时,会立马调用Awake函数,而start则会等到下一帧开始时调用
</br>

4. **FixedUpdate**
主要用于进行物理更新,它是每一帧都执行的,但是它的每一帧是可控的,且它运行的帧和其他update函数不一样,默认间隔时间是0.02s
</br>

5. **Update**
主要用于**处理游戏核心逻辑更新**的函数
</br>

6. **LaterUpdate**
一般用来**处理摄像机位置更新**相关内容
Update和LaterUpdate之间,unity会处理动画相关的更新
</br>

7. **OnDisable**
依附的GameObject对象**每次失活时调用**
当对象失活时,依附其上的生命周期函数都会停止调用
</br>

8. **OnDestroy**
**只调用一次**, 当一个对象销毁的时候会先调用一次OnDisable再调用OnDestroy



## 拓展
**Update和FixedUpdate时间间隔的区别**
1. Update 的时间间隔不固定
    Update的调用频率与游戏帧率（FPS）相关，每帧调用一次。如果帧率波动（比如从 60FPS 降到 30FPS），两次Update之间的时间间隔会相应变化（从约 16.7ms 变为约 33.3ms）。可以通过`Time.deltaTime`获取上一帧到当前帧的实际时间间隔，用于在移动、旋转等操作中进行时间补偿。
    
2. FixedUpdate 的时间间隔固定
    FixedUpdate的调用频率由项目设置中的 "Fixed Timestep"决定，时间间隔是固定的。无论帧率如何波动，FixedUpdate都会按照这个固定间隔执行，非常适合处理物理相关的逻辑。可以通过`Time.fixedDeltaTime`获取这个固定的时间间隔值。
</br>

**在unity中打印信息的方法**
```CSharp
//1. 没有继承MonoBehavior类时
Debug.Log("123");
Debug.LogError("123");
Debug.LogWarning("123");
//2. 继承了MonoBehavior时
print("123");
```

**生命周期函数并不是MonoBehavior的成员**
Unity帮助我们记录了场景上的所有GameObject对象以及各个关联的脚本对象, 在游戏执行的特定时期(对象创建时,失活激活时, 帧更新时)它会通过函数名反射得到脚本对象中对应的生命周期函数,然后再这些特定实际执行它们
***
# 7. Inspector窗口可编辑的变量
## 7.1 显示编辑
**private和protected修饰的变量无法显示编辑**
加上强制序列化字段特性`[SerializeField]`
序列化就是把一个对象保存到一个文件或者数据库字段中去

**让public修饰的变量也不能显示编辑**
在变量前加上特性`[HideInspector]`

**大部分默认类型都可以编辑**
但是字典以及自定义类型变量是不可以显示编辑的
但是区别在于字典怎么都不可以,但是自定义类型加上`[System.Serializable]`就可以被访问了

## 7.2 辅助特性
1. 分组说明特性Header, 为成员分组
> [Header("分组说明")]

2. 悬停注释Tooltip, 为变量添加说明
> [Tooltip("说明内容")]

3. 间隔特性 Space(), 让两个字段间出现间隔
> [Space()]

4. 修饰数值的滑条范围Range
> [Range(最小值, 最大值)]

5. 多行显示字符串 默认不写参数显示3行
写参数就是对应行
> [Multiline(4)]

6. 滚动条显示字符串 
默认不写参数就是超过3行显示滚动条
> [TextArea(3, 4)]
最少显示3行，最多4行，超过4行就显示滚动条

7. 为变量添加快捷方法 ContextMenuItem
参数1 显示按钮名
参数2 方法名 不能有参数
> [ContextMenuItem("显示按钮名", "方法名")]

8. 为方法添加特性能够在Inspector中执行
> [ContextMenu("测试函数")]

## 7.3 补充
1. Inspector窗口中的变量关联的就是对象的成员变量，运行时改变他们就是在改变成员变量
2. 拖曳到GameObject对象后 再改变脚本中变量默认值 界面上不会改变
3. 运行中修改的信息不会保存
***
# 8. MonoBehavior中的重要信息
## 8.1 重要成员
1. **获取依附的GameObject**
```CSharp
print(this.gameObject.name);
```
2. **获取依附的GameObject的位置信息**

    得到对象位置信息
    ```CSharp
    print(this.transform.position);//位置
    print(this.transform.eulerAngles);//角度
    print(this.transform.lossyScale);//缩放大小
    ```
    这种写法和上面是一样的效果 都是得到依附的对象的位置信息
    ```CSharp
    this.gameObject.transform
    ```

3. **获取脚本是否激活**
    ```CSharp
    this.enabled = false;
    ```

    获取别的脚本对象 依附的gameobject和 transform位置信息
    ```CSharp
    print(otherLesson3.gameObject.name);
    print(otherLesson3.transform.position);
    ```
## 8.2 重要方法
得到依附对象上挂载的其它脚本

1. **得到自己挂载的GameObject上的另一个脚本**
   - *根据脚本名获取* 获取脚本的方法 如果获取失败 就是没有对应的脚本 会默认返回空
   ```CSharp
   Test1 t = this.GetComponent("Test1") as Test1;
   ```
   - *根据Type获取*
   ```CSharp
   Test1 t = this.GetComponent(typeof(Test1)) as Test1;
   ```
   - **(推荐)根据泛型获取,因为不用二次转换**
   ```CSharp
   Test1 t = this.GetComponent(typeof(Test1)) as Test1;
   ```
   只要你能得到场景中别的对象或者对象依附的脚本, 那就能获取它的所有信息

2. **得到自己挂载的多个脚本**
    ```CSharp
    Test[] tests = this.GetCompenonts<Test>();

    List<Test> list = new List<Test>();
    this.GetCompenonts<Test>(list);
    ```

3. **得到当前依附的GameObject的子对象上挂载的脚本(它默认也会找自己身上是否挂载该脚本)**
   - 找单个
   ```CSharp
   //这个方法是有bool参数的,默认为false,意为子类若失活,就不再寻找该子类,不管有没有目标脚本挂载
   t = this.GetComponentInChildren<Test1>();

   //意为即使子类失活,只要挂载了Test1脚本就会获取
   t = this.GetComponentInChildren<Test1>(true);
   ```
   - 找多个
   ```CSharp
   //两种方法
   Test[] list = this.GetComponentsInChildren<Test>(true);

   List<Test> list1 = new List<Test>();
   this.GetComponentsInChildren<Test>(true, list1);
   ```

4. **得到父对象挂载的脚本(它默认也会找自己身上是否挂载该脚本)**
   - 单个
   ```CSharp
   //这个方法没有bool参数,因为父类都失活了,子类都会失活
   t = this.GetComponentInParent<Test1>();
   ```
   - 多个
   ```CSharp
   //这个方法没有bool参数,因为父类都失活了,子类都会失活
   //但是有list参数
   t = this.GetComponentsInParent<Test1>();
   ```
   以上两个方法可以理解从我自己开始为顺着族谱找到头

5. **尝试获取脚本**
    ```CSharp 
    Test1 test1;
    if(this.gameObject.TryGetComponent<Test1>(out test1))
    {
        //处理逻辑
    }
    ```
## 补充

### 如何理解this以及this.gameobject的关系以及区别
`this`: 代表该脚本本身
`this.gameobject`: 代表这个脚本依附的GameObject对象
`this.transform`: 代表这个脚本依附的GameObject对象的位置相关的信息

那问题来了,有一个GameObject,依附了Test和Test1脚本
```CSharp
Test1 t1 = this.GetComponent<Test1>();
Test1 t2 = this.gameObject.GetComponent<Test1>();

print(t1);
print(t2);
```
t2好理解,因为GameObject上依附了Test1脚本,所以好找,但是t1该怎么理解?是怎么通过脚本去找到另一个脚本的?

MonoBehaviour 类中有一个隐藏的逻辑：
当你直接调用 GetComponent() 时，它默认就是「向当前脚本所依附的 GameObject 要组件」。

MonoBehaviour 内部其实有类似这样的逻辑（简化版）：
```CSharp
public class MonoBehaviour {
    // 每个脚本都持有它所依附的GameObject的引用
    public GameObject gameObject;
    
    // GetComponent的默认实现，就是调用它所依附的GameObject的GetComponent
    public T GetComponent<T>() {
        return gameObject.GetComponent<T>();
    }
}
```
***
# 9. GameObject
## 9.1 成员变量
- 名字
```CSharp
this.gameObject.name;
```
- 是否激活
 ```CSharp
this.gameObject.activeSelf;
```
- 是否静态
```CSharp
this.gameObject.isStatic;
```
- 层级
```CSharp
this.gameObject.layer;
```
- 标签
```CSharp
this.gameObject.tag;
```

## 9.2 静态方法
### ①. 创建自带几何体
```CSharp
GameObject.CreatePrimitive(PrimitiveType.Cube);//立方体
```
### ②. 查找对象
#### (1)查找单个对象
- 通过对象名查找,这个查找效率比较低下,因为它会去遍历场景里的所有对象,没有找到会返回null
```CSharp
GameObject obj2 = GameObject.Find("长方体");
```
- 通过tag查找
```CSharp
GameObject obj3 = GameObject.FindWithTag("Player");
GameObject obj3 = GameObject.FindGameObjectWithTag("Player");//这两方法效果一样
```
> 以上两种方法是不把失活对象当做寻找目标的
> 如果场景中有多个满足条件的对象,我们无法得知获取的对象是哪一个

#### (2)查找多个对象
- 找多个对象的API,只能是通过tag去找,没有通过名字查找的API
```CSharp
GameObject[] objects = GameObject.FindGameObjectsWithTag("Player");
```
> 也不会把失活对象当做寻找目标的
- Object提供的方法, 它可以找到场景中挂载的某一脚本对象,效率巨低
```CSharp
Test o = GameObject.FindObjectOfType<Test>();
```
> C#的object是System.Object,是所有类的基类
> unity的Object是UnityEngine.Object,两个虽然同名,但命名空间不同,不是一个东西

### ③实例化对象(重要)
- 根据一个GameObject对象,创建出一个和它一模一样的对象(可以是场景中的对象,也可以是预制体)
```CSharp
GameObject obj5 = GameObject.Instantiate(myObj);
```
- 删除对象的方法, Destroy不仅可以删除对象,还可以删除指定脚本
```CSharp
GameObject.Destroy(obj);
GameObject.Destroy(obj,5);//后面参数代表延迟多少秒
GameObject.DestroyImmediate(obj);//立马移除一个对象,不会等到下一帧
```
> Destroy方法不会马上移除对象,只是给这个对象加了一个移除标识, 一般情况下,它会在下一帧把这个对象从内存中移除
> 如果没有特殊需求,建议不要用DestroyImmediate方法,因为Destroy方法是异步的,能降低卡顿的概率

- 过场景不移除, 默认情况 在切换场景时, 场景中对象都会被自动删除掉
- 如果你希望某个对象 过场景不被移除, 下面这句代码 就是不想谁过场景被移除 就传谁 
- 一般都是传 依附的GameObject对象
```CSharp
//自己依附的GameObject对象 过场景不被删除
GameObject.DontDestroyOnLoad(this.gameObject);
```
## 9.3 成员方法
#### 创建空物体
```CSharp
//new一个GameObject就是在创建一个空物体
GameObject obj1 = new GameObject();
GameObject obj2 = new GameObject("空物体");
GameObject obj3 = new GameObject("空物体", typeof(Test1),typeof(Test2));
```
#### 为对象添加脚本
继承MonoBehavior的脚本 是不能够去new 的, 如果想要动态的添加继承MonoBehavior的脚本 在某一个对象上, 直接使用GameObject提供的方法即可

```CSharp
Test1 t1 = obj1.AddComponent(typeof(Test1)) as Test1;
Test2 t2 = obj1.AddComponent<Lesson2>();
```
#### 标签比较
```CSharp
if(this.gameObject.CompareTag("Player")){} 
//等同于下面这句
if(this.gameObject.tag == "Player"){}
```

#### 设置激活失活
```CSharp
t1.SetActive(false);
```

#### 通过广播或者发送消息的形式 让自己或者别人 执行某些行为方法
通知自己 执行什么行为, 命令自己 去执行这个TestFun这个函数 会在自己身上挂载的所有脚本去找这个名字的函数
它会去找到 自己身上所有的脚本 有这个名字的函数去执行
```CSharp
this.gameObject.SendMessage("TestFun");
```

```CSharp
//广播行为 让自己和自己的子对象执行
this.gameObject.BroadcastMessage("函数名");

//向父对象和自己发送消息 并执行
this.gameObject.SendMessageUpwards("函数名");
```
***
# 10. Time
## ①时间缩放比例
```CSharp
//时间停止
Time.timeScale = 0;
//回复正常
Time.timeScale = 1;
//2倍速
Time.timeScale = 2;
```
## ②帧间隔时间
最近的一帧用了多长时间, 帧间隔时间 主要是用来计算位移
路程 = 时间*速度
根据需求 选择参与计算的间隔时间
如果希望 游戏暂停时就不动的 那就使用deltaTime
如果希望 不受暂停影响 unscaledDeltaTime
- 不受scale影响
```CSharp
print("帧间隔时间" + Time.deltaTime);
```
- 不受scale影响的帧间隔时间
```CSharp
print("不受scale影响的帧间隔时间" + Time.unscaledDeltaTime);
```

## ③游戏开始到现在的时间
它主要用来计时 单机游戏中计时
```CSharp
//受scale影响
print("游戏开始到现在的时间:" + Time.time);
//不受scale影响
print("不受scale影响的游戏开始到现在的时间:" + Time.unscaledTime);
```

## ④物理间隔时间
```CSharp
//受scale影响
print(Time.fixedDeltaTime);
//不受scale影响
print(Time.fixedUnscaledDeltaTime);
```

## ⑤帧数
```CSharp
//从开始到现在游戏跑了多少帧(次循环)
print(Time.frameCount);
```

***
# 11. Transform

## 11.1 位置
**Transform**: GameObject的位移,旋转,缩放,父子关系,坐标转换等相关操作都由它处理

### (1)Vector3
Vector3主要是用来表示三维坐标系中的一个点或者一个向量
- 声明
```CSharp
Vector3 v = new Vector3();//不传参默认为0
```
- 常用
```CSharp
print(Vector3.zero);    // {0, 0, 0}
print(Vector3.left);    // {1, 0 , 0}
print(Vector3.right);   // {-1, 0, 0}
print(Vector3.forward); // {0, 0, 1}
print(Vector3.back);    // {0, 0, -1}
print(Vector3.up);      // {0, 1, 0}
print(Vector3.down);    // {0, -1, 0}

//计算两个点的距离
Vector3.Distance(传两个点);
```
### (2)位置
- 相对世界坐标系
```CSharp
//如果对象有父子关系, 且父对象不在世界原点,那么打印出来的信息和面板上是不一致的
print(this.gameObject.transform);
print(this.transform);//两句等同
```
- 相对父对象
```CSharp
//如果你想以面板坐标为准来进行位置设置
print(this.transform.localPosition)
```
位置赋值不能直接改变下x,y,z; 只能整体改变
```CSharp
this.transform.position.x = 10; // 这样是不行的
```
- ①直接赋值
```CSharp
this.transform.position = new Vector3(20, this.transform.position.y, this.transform.position.z);
```
- ②先取出 再赋值
```CSharp
//虽然不能直接改 transform 的 xyz 但是 Vector3 是可以直接改 xyz 的
Vector3 pos = this.transform.localPosition;
pos.x = 10;
this.transform.localPosition = pos;
```
### (3)对象的当前的各个朝向
```CSharp
//面朝向
print(this.transform.forward);
//头顶朝向
print(this.transform.up);
//右朝向
print(this.transform.right);
```
## 11.2 位移
### 公式计算
- 局部坐标系朝向
```CSharp
//路径 = 方向 * 速度 * 时间 
this.transform.position += (this.transform.forward * 1 * Time.deltaTime);
```
- 世界坐标系朝向
```CSharp
this.transform.position += (Vector3.forward * 1 * Time.deltaTime);
```

### API
一般会使用API
```CSharp
//参数一: 位移多少
//参数二: 相对坐标系, 默认为局部坐标系
this.transform.Translate(Vector3.forward * 1 * Time.deltaTime,Space.World);
```

## 11.3 角度和旋转
### 角度
```CSharp
//相对世界坐标角度
print(this.transform.eulerAngles);

//相对父对象角度
print(this.transform.localEulerAngles);
```
注意：设置角度和设置位置一样 不能单独设置xyz 要一起设置

### 旋转
- 自转
```CSharp
//每个轴 具体转多少度
//第一个参数 相当于 是旋转的角度 每一帧 
//第二个参数 默认不填 就是相对于自己坐标系 进行的旋转
this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime, Space.World);
```
- 相对于轴
```CSharp
//参数一：是相对哪个轴进行转动
//参数二：是转动的 角度 是多少
//参数三：默认不填 就是相对于自己的坐标系 进行旋转
//       如果填  可以填写相对于 世界坐标系进行旋转
this.transform.Rotate(Vector3.right, 10 * Time.deltaTime, Space.World);
```
- 相对于某一点
```CSharp
//参数一：相对于哪一个点 转圈
//参数二：相对于那一个点的 哪一个轴转圈
//参数三：转的度数  旋转速度 * 时间
this.transform.RotateAround(Vector3.zero, Vector3.right, 10 * Time.deltaTime);
```
***

