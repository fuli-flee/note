[toc]
***
# 1. 工程文件夹
![alt](/Unity/图片/image.png)
- Assets: 工程资源文件夹(美术资源,脚本等)
- Library: 库文件夹(Unity自动生成管理)
- Logs: 日志文件夹,记录特殊信息
- obj: 编译产生中间文件
- Packages: 包配置信息
- ProjectSettings: 工程设置信息

只要这个Assets文件夹不丢,工程就能打开,其他的unity会帮你生成,但是里面的配置就未必是之前的了
***
# 2. Scene和Hierarchy窗口
层级窗口中看到的内容就是场景窗口中的显示对象

## 2.1 Hierarchy 层级窗口
层级窗口中显示的就是一个场景中的所有对象
Hierarchy窗口就是创建,拖动,操作的一个功能面板

**操作**
**Duplicate**这个可以理解为复制粘贴一步到位,快捷键为`Ctrl+D`

## 2.2 Scene 场景窗口
![alt text](/Unity/图片/image2.png)

**坐标轴**
以屏幕为参照
- 垂直屏幕向内为+Z
- 平行屏幕向右为+X
- 垂直屏幕向上为+Y

![alt text](/Unity/图片/image3.png)
***
# 3. Game游戏窗口和Project工程窗口
## 3.1 Game游戏窗口
![alt text](/Unity/图片/image5.png)
- Warn if No Cameras Rendering: 场景中没有摄像机时会发出警告
- Clear Every Frame in Edit Mode: 游戏未播放时,也更新Game窗口,避免显示问题

![alt text](/Unity/图片/image4.png)
## 2.3 Project工程窗口
Packages文件夹: 放的是官方拓展包
***
# 3. 工具栏
## 3.1 工具栏
![alt text](/Unity/图片/image6.png)
- File(文件操作): 新建工程, 新建场景, 工程打包等
- Edit(编辑操作): 对象编辑操作相关, 工程设置, 引擎设置相关
- Assets(资源操作): 基本等同于Project窗口中右键相关功能
- GameObject(对象操作): 基本等同于Hierarchy窗口中右键相关功能
- Component(脚本操作): Unity自带的脚本, 可以添加各系统重的脚本
- Window(窗口): 可以打开Unity各核心系统的窗口
- Help(帮助): 检查更新, 查看版本等

**Edit中的Project Settings**

Edit中的Project Settings中的选项其实就是对应的你Project Settings文件夹中的资源,修改过后的配置会存入到Project Settings中的配置文件
![alt text](/Unity/图片/image7.png)

**Edit中的Preference**
External Tools中可以更改你默认打开的IDE
![alt text](/Unity/图片/Snipaste_2025-09-18_09-32-07.jpg)
- Ctrl+Alt+F: 将物体移动到视口中心 
- Ctrl+Shift+F: 将物体移动到视口位置
![alt text](/Unity/图片/Snipaste_2025-09-18_10-01-04.jpg)

***
# 4.Unity中的反射机制和游戏场景的本质
## 回顾
程序正在运行时可以查看其他程序集或者自身的元数据, 一个运行的程序查看本身或者其他程序的元数据的行为就叫反射

## 对象的本质
- GameObject类对象是Unity提供的作为场景中所有对象的根本
- 在游戏场景中出现一个对象, 不管是图片, 模型, 音效, 摄像机等都是依附于GameObject对象的
- 而Transform是GameObject对象必不可少的一个依附对象
- 相当与就是用一个**Transform类对象**和**GameObject类对象**(注意这里都是类对象)进行关联, 用于设置位置和缩放

举例说明:
1. 修改Inspector面板中的Transform内容
> 利用反射: 已知对象, 类名, 变量名, 通过反射为该对象设置变量值
1. 新建一个脚本后,添加给一个指定的GameObject对象
> 已知类名, 可以获取所有公共成员,故可以在Inspector面板上创建各个公共字段信息

## 游戏场景的本质
- 游戏场景文件, 后缀为`.unity`,它的本质就是一个配置文件
- unity有一套自己识别处理它的机制
- 本质就是把场景对象相关信息读取出来,通过反射来创建各个对象关联各个脚本对象

***
# 4. 预制体(预设体)
- Unpack Prefab: 和之前的预制体取消关联
***
# 5. 脚本
类名和文件名必须一致,不然无法挂载(因为反射机制创建对象, 会通过文件名去找Type)
## 5.1 MonoBehavior
1. 创建的脚本默认都继承MonoBehavior, 继承了它才能够挂载在GameObject上
2. 继承了的MonoBehavior的脚本不能new,只能挂
3. 继承了MonoBehavior的脚本不要写构造函数,你都不能new,你写构造函数也没有意义了
4. 继承了MonoBehavior的脚本可以在一个对象上挂多个(在没有加DisallowMultipleComponent特性(不允许多次挂载,包括其子类)的情况下)
5. 继承MonoBehavior的类可以再次被继承, 遵循面向对象继承多态的规则

**不继承MonoBehavior的类**
1. 不能挂载到GameObject上
2. 想怎么写就怎么写, 要使用的时候需要自己new
3. 一般是单例模式的类(用于管理模块) 或者数据结构类(用于存储数据)
4. 不用保留默认出现的生命周期函数

**设置执行顺序**
![alt text](/Unity/图片/Snipaste_09-18_11-54-34.jpg)

**改变默认脚本内容**
要管理员权限
> Editor\Data\Resource\ScriptTemplates

***
# 6. 生命周期函数
## 概念
所有继承MonoBehavior的脚本,最终都会挂载到GameObject游戏对象上
生命周期函数就是该脚本对象依附的GameObject对象从出生到消亡整个生命周期中会通过反射自动调用的一些特殊函数

unity帮助我们记录了一个GameObject对象依附了哪些脚本, 会自动的得到这些对象, 通过反射去执行一些固定名字的函数

## 生命周期函数

!!! important 注意
    生命周期函数的访问修饰符一般为private和protected
    因为不需要在外部自己调用生命周期函数, 都是Unity自己帮助我们调用的
    生命周期函数支持继承多态

<center>

![alt text](/Unity/图片/Unity入门09-18_21-22-08.jpg)

</center>

1. **Awake**
当对象(自己这个类对象)**被创建时**才会调用该声明周期函数, **只会调用一次**
类似构造函数的存在, 我们可以在一个类对象刚创建时进行一些初始化操作
</br>

2. **OnEnable**
依附的GameObject对象**每次激活时调用**
当想要一个对象被激活时, 进行一些逻辑处理,就可以写在这个函数中
</br>

3. **Start**
**只会调用一次**,主要作用还是用于初始化信息的
当在update函数里动态创建对象时,会立马调用Awake函数,而start则会等到下一帧开始时调用
</br>

4. **FixedUpdate**
主要用于进行物理更新,它是每一帧都执行的,但是它的每一帧是可控的,且它运行的帧和其他update函数不一样,默认间隔时间是0.02s
</br>

5. **Update**
主要用于**处理游戏核心逻辑更新**的函数
</br>

6. **LaterUpdate**
一般用来**处理摄像机位置更新**相关内容
Update和LaterUpdate之间,unity会处理动画相关的更新
</br>

7. **OnDisable**
依附的GameObject对象**每次失活时调用**
当对象失活时,依附其上的生命周期函数都会停止调用
</br>

8. **OnDestroy**
**只调用一次**, 当一个对象销毁的时候会先调用一次OnDisable再调用OnDestroy



## 拓展
**Update和FixedUpdate时间间隔的区别**
1. Update 的时间间隔不固定
    Update的调用频率与游戏帧率（FPS）相关，每帧调用一次。如果帧率波动（比如从 60FPS 降到 30FPS），两次Update之间的时间间隔会相应变化（从约 16.7ms 变为约 33.3ms）。可以通过`Time.deltaTime`获取上一帧到当前帧的实际时间间隔，用于在移动、旋转等操作中进行时间补偿。
    
2. FixedUpdate 的时间间隔固定
    FixedUpdate的调用频率由项目设置中的 "Fixed Timestep"决定，时间间隔是固定的。无论帧率如何波动，FixedUpdate都会按照这个固定间隔执行，非常适合处理物理相关的逻辑。可以通过`Time.fixedDeltaTime`获取这个固定的时间间隔值。
</br>

**在unity中打印信息的方法**
```CSharp
//1. 没有继承MonoBehavior类时
Debug.Log("123");
Debug.LogError("123");
Debug.LogWarning("123");
//2. 继承了MonoBehavior时
print("123");
```

**生命周期函数并不是MonoBehavior的成员**
Unity帮助我们记录了场景上的所有GameObject对象以及各个关联的脚本对象, 在游戏执行的特定时期(对象创建时,失活激活时, 帧更新时)它会通过函数名反射得到脚本对象中对应的生命周期函数,然后再这些特定实际执行它们
***
# 7. Inspector窗口可编辑的变量
## 7.1 显示编辑
**private和protected修饰的变量无法显示编辑**
加上强制序列化字段特性`[SerializeField]`
序列化就是把一个对象保存到一个文件或者数据库字段中去

**让public修饰的变量也不能显示编辑**
在变量前加上特性`[HideInspector]`

**大部分默认类型都可以编辑**
但是字典以及自定义类型变量是不可以显示编辑的
但是区别在于字典怎么都不可以,但是自定义类型加上`[System.Serializable]`就可以被访问了

## 7.2 辅助特性
1. 分组说明特性Header, 为成员分组
> [Header("分组说明")]

2. 悬停注释Tooltip, 为变量添加说明
> [Tooltip("说明内容")]

3. 间隔特性 Space(), 让两个字段间出现间隔
> [Space()]

4. 修饰数值的滑条范围Range
> [Range(最小值, 最大值)]

5. 多行显示字符串 默认不写参数显示3行
写参数就是对应行
> [Multiline(4)]

6. 滚动条显示字符串 
默认不写参数就是超过3行显示滚动条
> [TextArea(3, 4)]
最少显示3行，最多4行，超过4行就显示滚动条

7. 为变量添加快捷方法 ContextMenuItem
参数1 显示按钮名
参数2 方法名 不能有参数
> [ContextMenuItem("显示按钮名", "方法名")]

8. 为方法添加特性能够在Inspector中执行
> [ContextMenu("测试函数")]

## 7.3 补充
1. Inspector窗口中的变量关联的就是对象的成员变量，运行时改变他们就是在改变成员变量
2. 拖曳到GameObject对象后 再改变脚本中变量默认值 界面上不会改变
3. 运行中修改的信息不会保存
***
# 8. MonoBehavior中的重要信息
## 8.1 重要成员
1. **获取依附的GameObject**
```CSharp
print(this.gameObject.name);
```
2. **获取依附的GameObject的位置信息**

    得到对象位置信息
    ```CSharp
    print(this.transform.position);//位置
    print(this.transform.eulerAngles);//角度
    print(this.transform.lossyScale);//缩放大小
    ```
    这种写法和上面是一样的效果 都是得到依附的对象的位置信息
    ```CSharp
    this.gameObject.transform
    ```

3. **获取脚本是否激活**
    ```CSharp
    this.enabled = false;
    ```

    获取别的脚本对象 依附的gameobject和 transform位置信息
    ```CSharp
    print(otherLesson3.gameObject.name);
    print(otherLesson3.transform.position);
    ```
## 8.2 重要方法
得到依附对象上挂载的其它脚本

1. **得到自己挂载的GameObject上的另一个脚本**
   - *根据脚本名获取* 获取脚本的方法 如果获取失败 就是没有对应的脚本 会默认返回空
   ```CSharp
   Test1 t = this.GetComponent("Test1") as Test1;
   ```
   - *根据Type获取*
   ```CSharp
   Test1 t = this.GetComponent(typeof(Test1)) as Test1;
   ```
   - **(推荐)根据泛型获取,因为不用二次转换**
   ```CSharp
   Test1 t = this.GetComponent(typeof(Test1)) as Test1;
   ```
   只要你能得到场景中别的对象或者对象依附的脚本, 那就能获取它的所有信息

2. **得到自己挂载的多个脚本**
    ```CSharp
    Test[] tests = this.GetCompenonts<Test>();

    List<Test> list = new List<Test>();
    this.GetCompenonts<Test>(list);
    ```

3. **得到当前依附的GameObject的子对象上挂载的脚本(它默认也会找自己身上是否挂载该脚本)**
   - 找单个
   ```CSharp
   //这个方法是有bool参数的,默认为false,意为子类若失活,就不再寻找该子类,不管有没有目标脚本挂载
   t = this.GetComponentInChildren<Test1>();

   //意为即使子类失活,只要挂载了Test1脚本就会获取
   t = this.GetComponentInChildren<Test1>(true);
   ```
   - 找多个
   ```CSharp
   //两种方法
   Test[] list = this.GetComponentsInChildren<Test>(true);

   List<Test> list1 = new List<Test>();
   this.GetComponentsInChildren<Test>(true, list1);
   ```

4. **得到父对象挂载的脚本(它默认也会找自己身上是否挂载该脚本)**
   - 单个
   ```CSharp
   //这个方法没有bool参数,因为父类都失活了,子类都会失活
   t = this.GetComponentInParent<Test1>();
   ```
   - 多个
   ```CSharp
   //这个方法没有bool参数,因为父类都失活了,子类都会失活
   //但是有list参数
   t = this.GetComponentsInParent<Test1>();
   ```
   以上两个方法可以理解从我自己开始为顺着族谱找到头

5. **尝试获取脚本**
    ```CSharp 
    Test1 test1;
    if(this.gameObject.TryGetComponent<Test1>(out test1))
    {
        //处理逻辑
    }
    ```
## 补充

### 如何理解this以及this.gameobject的关系以及区别
`this`: 代表该脚本本身
`this.gameobject`: 代表这个脚本依附的GameObject对象
`this.transform`: 代表这个脚本依附的GameObject对象的位置相关的信息

那问题来了,有一个GameObject,依附了Test和Test1脚本
```CSharp
Test1 t1 = this.GetComponent<Test1>();
Test1 t2 = this.gameObject.GetComponent<Test1>();

print(t1);
print(t2);
```
t2好理解,因为GameObject上依附了Test1脚本,所以好找,但是t1该怎么理解?是怎么通过脚本去找到另一个脚本的?

MonoBehaviour 类中有一个隐藏的逻辑：
当你直接调用 GetComponent() 时，它默认就是「向当前脚本所依附的 GameObject 要组件」。

MonoBehaviour 内部其实有类似这样的逻辑（简化版）：
```CSharp
public class MonoBehaviour {
    // 每个脚本都持有它所依附的GameObject的引用
    public GameObject gameObject;
    
    // GetComponent的默认实现，就是调用它所依附的GameObject的GetComponent
    public T GetComponent<T>() {
        return gameObject.GetComponent<T>();
    }
}
```
***
# 9. GameObject
## 9.1 成员变量
- 名字
```CSharp
this.gameObject.name;
```
- 是否激活
 ```CSharp
this.gameObject.activeSelf;
```
- 是否静态
```CSharp
this.gameObject.isStatic;
```
- 层级
```CSharp
this.gameObject.layer;
```
- 标签
```CSharp
this.gameObject.tag;
```

## 9.2 静态方法
### ①. 创建自带几何体
```CSharp
GameObject.CreatePrimitive(PrimitiveType.Cube);//立方体
```
### ②. 查找对象
#### (1)查找单个对象
- 通过对象名查找,这个查找效率比较低下,因为它会去遍历场景里的所有对象,没有找到会返回null
```CSharp
GameObject obj2 = GameObject.Find("长方体");
```
- 通过tag查找
```CSharp
GameObject obj3 = GameObject.FindWithTag("Player");
GameObject obj3 = GameObject.FindGameObjectWithTag("Player");//这两方法效果一样
```
> 以上两种方法是不把失活对象当做寻找目标的
> 如果场景中有多个满足条件的对象,我们无法得知获取的对象是哪一个

#### (2)查找多个对象
- 找多个对象的API,只能是通过tag去找,没有通过名字查找的API
```CSharp
GameObject[] objects = GameObject.FindGameObjectsWithTag("Player");
```
> 也不会把失活对象当做寻找目标的
- Object提供的方法, 它可以找到场景中挂载的某一脚本对象,效率巨低
```CSharp
Test o = GameObject.FindObjectOfType<Test>();
```
> C#的object是System.Object,是所有类的基类
> unity的Object是UnityEngine.Object,两个虽然同名,但命名空间不同,不是一个东西

### ③实例化对象(重要)
- 根据一个GameObject对象,创建出一个和它一模一样的对象(可以是场景中的对象,也可以是预制体)
```CSharp
GameObject obj5 = GameObject.Instantiate(myObj);
```
- 删除对象的方法, Destroy不仅可以删除对象,还可以删除指定脚本
```CSharp
GameObject.Destroy(obj);
GameObject.Destroy(obj,5);//后面参数代表延迟多少秒
GameObject.DestroyImmediate(obj);//立马移除一个对象,不会等到下一帧
```
> Destroy方法不会马上移除对象,只是给这个对象加了一个移除标识, 一般情况下,它会在下一帧把这个对象从内存中移除
> 如果没有特殊需求,建议不要用DestroyImmediate方法,因为Destroy方法是异步的,能降低卡顿的概率

- 过场景不移除, 默认情况 在切换场景时, 场景中对象都会被自动删除掉
- 如果你希望某个对象 过场景不被移除, 下面这句代码 就是不想谁过场景被移除 就传谁 
- 一般都是传 依附的GameObject对象
```CSharp
//自己依附的GameObject对象 过场景不被删除
GameObject.DontDestroyOnLoad(this.gameObject);
```
## 9.3 成员方法
#### 创建空物体
```CSharp
//new一个GameObject就是在创建一个空物体
GameObject obj1 = new GameObject();
GameObject obj2 = new GameObject("空物体");
GameObject obj3 = new GameObject("空物体", typeof(Test1),typeof(Test2));
```
#### 为对象添加脚本
继承MonoBehavior的脚本 是不能够去new 的, 如果想要动态的添加继承MonoBehavior的脚本 在某一个对象上, 直接使用GameObject提供的方法即可

```CSharp
Test1 t1 = obj1.AddComponent(typeof(Test1)) as Test1;
Test2 t2 = obj1.AddComponent<Lesson2>();
```
#### 标签比较
```CSharp
if(this.gameObject.CompareTag("Player")){} 
//等同于下面这句
if(this.gameObject.tag == "Player"){}
```

#### 设置激活失活
```CSharp
t1.SetActive(false);
```

#### 通过广播或者发送消息的形式 让自己或者别人 执行某些行为方法
通知自己 执行什么行为, 命令自己 去执行这个TestFun这个函数 会在自己身上挂载的所有脚本去找这个名字的函数
它会去找到 自己身上所有的脚本 有这个名字的函数去执行
```CSharp
this.gameObject.SendMessage("TestFun");
```

```CSharp
//广播行为 让自己和自己的子对象执行
this.gameObject.BroadcastMessage("函数名");

//向父对象和自己发送消息 并执行
this.gameObject.SendMessageUpwards("函数名");
```
***
# 10. Time
## ①时间缩放比例
```CSharp
//时间停止
Time.timeScale = 0;
//回复正常
Time.timeScale = 1;
//2倍速
Time.timeScale = 2;
```
## ②帧间隔时间
最近的一帧用了多长时间, 帧间隔时间 主要是用来计算位移
路程 = 时间*速度
根据需求 选择参与计算的间隔时间
如果希望 游戏暂停时就不动的 那就使用deltaTime
如果希望 不受暂停影响 unscaledDeltaTime
- 不受scale影响
```CSharp
print("帧间隔时间" + Time.deltaTime);
```
- 不受scale影响的帧间隔时间
```CSharp
print("不受scale影响的帧间隔时间" + Time.unscaledDeltaTime);
```

## ③游戏开始到现在的时间
它主要用来计时 单机游戏中计时
```CSharp
//受scale影响
print("游戏开始到现在的时间:" + Time.time);
//不受scale影响
print("不受scale影响的游戏开始到现在的时间:" + Time.unscaledTime);
```

## ④物理间隔时间
```CSharp
//受scale影响
print(Time.fixedDeltaTime);
//不受scale影响
print(Time.fixedUnscaledDeltaTime);
```

## ⑤帧数
```CSharp
//从开始到现在游戏跑了多少帧(次循环)
print(Time.frameCount);
```

***
# 11. Transform

## 11.1 位置
**Transform**: GameObject的位移,旋转,缩放,父子关系,坐标转换等相关操作都由它处理

### (1)Vector3
Vector3主要是用来表示三维坐标系中的一个点或者一个向量
- 声明
```CSharp
Vector3 v = new Vector3();//不传参默认为0
```
- 常用
```CSharp
print(Vector3.zero);    // {0, 0, 0}
print(Vector3.left);    // {1, 0 , 0}
print(Vector3.right);   // {-1, 0, 0}
print(Vector3.forward); // {0, 0, 1}
print(Vector3.back);    // {0, 0, -1}
print(Vector3.up);      // {0, 1, 0}
print(Vector3.down);    // {0, -1, 0}

//计算两个点的距离
Vector3.Distance(传两个点);
```
### (2)位置
- 相对世界坐标系
```CSharp
//如果对象有父子关系, 且父对象不在世界原点,那么打印出来的信息和面板上是不一致的
print(this.gameObject.transform);
print(this.transform);//两句等同
```
- 相对父对象
```CSharp
//如果你想以面板坐标为准来进行位置设置
print(this.transform.localPosition)
```
位置赋值不能直接改变下x,y,z; 只能整体改变
```CSharp
this.transform.position.x = 10; // 这样是不行的
```
- ①直接赋值
```CSharp
this.transform.position = new Vector3(20, this.transform.position.y, this.transform.position.z);
```
- ②先取出 再赋值
```CSharp
//虽然不能直接改 transform 的 xyz 但是 Vector3 是可以直接改 xyz 的
Vector3 pos = this.transform.localPosition;
pos.x = 10;
this.transform.localPosition = pos;
```
### (3)对象的当前的各个朝向
```CSharp
//面朝向
print(this.transform.forward);
//头顶朝向
print(this.transform.up);
//右朝向
print(this.transform.right);
```
## 11.2 位移
### 公式计算
- 局部坐标系朝向
```CSharp
//路径 = 方向 * 速度 * 时间 
this.transform.position += (this.transform.forward * 1 * Time.deltaTime);
```
- 世界坐标系朝向
```CSharp
this.transform.position += (Vector3.forward * 1 * Time.deltaTime);
```

### API
一般会使用API
```CSharp
//参数一: 位移多少
//参数二: 相对坐标系, 默认为局部坐标系
this.transform.Translate(Vector3.forward * 1 * Time.deltaTime,Space.World);
```

## 11.3 角度和旋转
### 角度
```CSharp
//相对世界坐标角度
print(this.transform.eulerAngles);

//相对父对象角度
print(this.transform.localEulerAngles);
```
注意：设置角度和设置位置一样 不能单独设置xyz 要一起设置

### 旋转
- 自转
```CSharp
//每个轴 具体转多少度
//第一个参数 相当于 是旋转的角度 每一帧 
//第二个参数 默认不填 就是相对于自己坐标系 进行的旋转
this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime, Space.World);
```
- 相对于轴
```CSharp
//参数一：是相对哪个轴进行转动
//参数二：是转动的 角度 是多少
//参数三：默认不填 就是相对于自己的坐标系 进行旋转
//       如果填  可以填写相对于 世界坐标系进行旋转
this.transform.Rotate(Vector3.right, 10 * Time.deltaTime, Space.World);
```
- 相对于某一点
```CSharp
//参数一：相对于哪一个点 转圈
//参数二：相对于那一个点的 哪一个轴转圈
//参数三：转的度数  旋转速度 * 时间
this.transform.RotateAround(Vector3.zero, Vector3.right, 10 * Time.deltaTime);
```
***
# 12. 缩放
```CSharp
//相对世界坐标系
print(this.transform.lossyScale);
//相对本地坐标系（父对象）
print(this.transform.localScale);
```
注意: 同样缩放不能只改xyz, 只能一起改, 且相对于世界坐标系的缩放大小只能得不能改; unity没有提供缩放相关的API

***
# 13. 看向
让一个对象的面朝向 可以一直看向某一个点或者某一个对象
```CSharp
this.transform.LookAt(lookAtObj);
```
***
# 14. 父子关系
## (1) 获取父对象
```CSharp
public Transform EarthPosition;
this.transform.parent = EarthPosition;
```
- API
```CSharp
this.transform.SetParent(null);
this.transform.SetParent(EarthPosition);

//参数一：父类
//参数二：是否保留世界坐标的 位置 角度 缩放 信息
//       true  会保留 世界坐标下的状态  和 父对象 进行计算 得到本地坐标系的信息
//       false 不会保留 会直接把世界坐标系下的 位置角度缩放 直接赋值到 本地坐标系下 
this.transform.SetParent(EarthPosition,false);
```
## (2) 断绝父子关系
只能影响直接的父子关系,直接的不行
```CSharp
this.transform.DetachChildren();
```
## (3) 获取子对象
①按名字查找
Find方法 是能够找到 失活的对象的, GameObject相关的 Find() 是不能找到失活对象的, 且也是对于直接父子关系来说的
```CSharp
print(this.transform.Find("Cube").name);
```
②遍历的方式
失活的子类也会算数量, 且也是对于直接父子关系
```CSharp
print(this.transform.childCount);
```
通过索引号 去得到自己对应的子类
```CSharp
this.transform.GetChild(0);
```

## (4) 子类的操作
①判断父类
```CSharp
public Transform son;
//判断自己是不是另一个对象的儿子
if(son.IsChildOf(this.transform))
{
    print("是我的儿子");
}
```
②得到自己作为子类的编号
```CSharp
print(son.GetSiblingIndex());
```
③把自己设置为第一个子类
```CSharp
son.SetAsFirstSibling();
```
④把自己设置为最后一个子类
```CSharp
son.SetAsLastSibling();
```
⑤把自己设置为指定编号的子类
```CSharp
//就算你填的数量 超出了范围（负数或者更大的数） 不会报错 会直接设置成最后一个编号
son.SetSiblingIndex(1);
```
***
# 15. 坐标转换
## 15.1 世界坐标转局部坐标(本地坐标)

**世界坐标系的点 转换 为相对本地坐标系的点**
- 受到缩放影响
```CSharp
print("转换后的点 " + this.transform.InverseTransformPoint(Vector3.forward));
```

**世界坐标系的方向 转换 为相对本地坐标系的方向**
- 不受缩放影响
```CSharp
print("转换后的方向" + this.transform.InverseTransformDirection(Vector3.forward));
```
- 受缩放影响
```CSharp
print("转换后的方向(受缩放影响)" + this.transform.InverseTransformVector(Vector3.forward));
```

## 15.2 本地坐标转世界坐标
**本地坐标系的点 转换 为相对世界坐标系的点**
- 受到缩放影响
```CSharp
print("本地 转 世界 点" + this.transform.TransformPoint(Vector3.forward));
```
**本地坐标系的方向 转换 为相对世界坐标系的方向** 
- 不受缩放影响
```CSharp
print("本地 转 世界 方向" + this.transform.TransformDirection(Vector3.forward));
```
- 受缩放影响
```Csharp
print("本地 转 世界 方向" + this.transform.TransformVector(Vector3.forward));
```

## 举个例子
```CSharp
[ContextMenu("左前方创建空物体")]
void GenerateEmpty()
{
    GameObject obj = new GameObject("左前方");
    obj.transform.position = this.transform.TransformPoint(-1, 0, 1);
}

[ContextMenu("前方创建3个球体")]
void GenerateThreeBall()
{
    for (int i = 1; i <= 3; ++i)
    {
        GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        obj.transform.position = this.transform.InverseTransformPoint(Vector3.forward * i);
    }
}
```
以上内容挂载在一个坐标为(10,0,10)的立方体上
第一段代码用`TransformPoint`,意为 "立方体的局部位置在世界中的哪里？" ,考虑世界坐标得出的结果(10-1, 0, 10+1) => (-9, 0, 11)
第二段代码用`InverseTransformPoint`, 意为 "世界坐标(0,0,i)相对于立方体的局部坐标是多少？" 
***
# 16. Input鼠标键盘输入
输入相关内容肯定是写在Update中的

## 16.1 鼠标在屏幕位置
屏幕坐标的原点 是在 屏幕的左下角  往右是X轴正方向 往上时Y轴正方向
返回值是Vector3, 但是只有 x和y有值 z一直是0 是因为屏幕本来就是2D的 不存在Z轴
```CSharp
print(Input.mousePosition);
```
## 16.2 检测鼠标输入
鼠标按下一瞬间 进入
0左键 1右键 2中键
```CSharp
//只要按下的这一瞬间 进入一次 返回一个bool值
if(Input.GetMouseButtonDown(0)) { };

//鼠标抬起一瞬间 进入
if(Input.GetMouseButtonUp(0)) { };

//鼠标长按按下抬起都会进入
//就是 当按住按键不放时 会一直进入 这个判断
if( Input.GetMouseButton(1)) { }

//中键滚动
//返回值的 y, -1往下滚  0没有滚  1往上滚
//它的返回值 是Vector的值 我们鼠标中键滚动 会改变其中的Y值
print(Input.mouseScrollDelta);
```

## 16.3检测键盘输入
```CSharp
//键盘按下
if( Input.GetKeyDown(KeyCode.W) ){};

//传入字符串的重载
//这里传入的 字符串 不能是大写的 不然会报错
//只能传入小写字符串
if( Input.GetKeyDown("q") ){};

//键盘抬起
if( Input.GetKeyUp(KeyCode.W) ){};

//键盘长按
if( Input.GetKey(KeyCode.W) ){};
```

## 检测默认轴输入
Unity提供了 更方便的方法 来帮助我们控制 对象的 位移和旋转
```CSharp
//键盘AD按下时 返回 -1到1之间的变换
//相当于 得到得这个值 就是我们的 左右方向 我们可以通过它来控制 对象左右移动 或者左右旋转
Input.GetAxis("Horizontal");

//键盘SW按下时 返回 -1到1之间的变换
//得到得这个值 就是我们的 上下方向 我们可以通过它来控制 对象上下移动 或者上下旋转
Input.GetAxis("Vertical");

//鼠标横向移动时 -1 到 1 左 右
Input.GetAxis("Mouse X");

//鼠标竖向移动时  -1 到 1 下 上
Input.GetAxis("Mouse Y");
```
我们默认的 GetAxis方法 是有渐变的 会总 `-1 ~ 0 ~ 1`之间 渐变 会出现小数
`GetAxisRaw`方法 和 `GetAxis`使用方式相同, 只不过 它的返回值 只会是 `-1 0 1` 不会有中间值

## 16.4 其他
```CSharp
//是否有任意键或鼠标长按
if(Input.anyKey){};

//是否有任意键或鼠标按下
if(Input.anyKeyDown){};

//这一帧的键盘输入
print(Input.inputString);

//手柄输入相关
//得到连接的手柄的所有按钮名字
string[] strs = Input.GetJoystickNames();

//某一个手柄键按下
if( Input.GetButtonDown("Jump") ){};

//某一个手柄键抬起
if (Input.GetButtonUp("Jump")){};

//某一个手柄键长按
if (Input.GetButton("Jump")){}; 

//移动设备触摸相关
if(Input.touchCount > 0)
{
    Touch t1 = Input.touches[0];
    //位置
    print(t1.position);
    //相对上次位置的变化
    print(t1.deltaPosition);
}

//是否启用多点触控
Input.multiTouchEnabled = false;


//陀螺仪（重力感应）
//是否开启陀螺仪 必须开启 才能正常使用
Input.gyro.enabled = true;
//重力加速度向量
print(Input.gyro.gravity);
//旋转速度
print(Input.gyro.rotationRate);
//陀螺仪 当前的旋转四元数 
//比如 用这个角度信息 来控制 场景上的一个3D物体受到重力影响
//手机怎么动 它怎么动
print(Input.gyro.attitude);
```
***
# 17.Screen
## 17.1 静态属性
### 常用
- 当前屏幕分辨率
```CSharp
Resolution r = Screen.currentResolution;
print("当前屏幕分辨率的宽" + r.width + "高" + r.height);
```
- 屏幕窗口当前宽高
```CSharp
//这得到的 是当前 窗口的 宽高 不是设备分辨率的宽高
//一般写代码 要用窗口宽高 做计算时 就用他们
print(Screen.width);
print(Screen.height);
```
- 屏幕休眠模式 
```CSharp
Screen.sleepTimeout = SleepTimeout.NeverSleep;
```

### 不常用
- 运行时是否全屏
```CSharp
Screen.fullScreen = true;
```
- 窗口模式
```CSharp
//窗口模式
Screen.fullScreenMode = FullScreenMode.Windowed;
//独占全屏FullScreenMode.ExclusiveFullScreen
//全屏窗口FullScreenMode.FullScreenWindow
//最大化窗口FullScreenMode.MaximizedWindow
//窗口模式FullScreenMode.Windowed
```
- 移动设备屏幕转向相关
```CSharp
//允许自动旋转为左横向 Home键在左
Screen.autorotateToLandscapeLeft = true;
//允许自动旋转为右横向 Home键在右
Screen.autorotateToLandscapeRight = true;
//允许自动旋转到纵向 Home键在下
Screen.autorotateToPortrait = true;
//允许自动旋转到纵向倒着看 Home键在上
Screen.autorotateToPortraitUpsideDown = true;
```
- 指定屏幕显示方向
```CSharp
Screen.orientation = ScreenOrientation.Landscape;
```

## 17.2 静态方法
- 设置分辨率 一般移动设备不使用
```CSharp
Screen.SetResolution(1920, 1080, false);
```
***
# 18. Camera可编辑的参数

## Clear Flags
- Depth Only: 只画该层, 背景透明
- Don`t Clear: 不移除, 覆盖渲染

## Culling Mask
选择性渲染部分层级

## Depth
**默认为-1, 在只有一个摄像机的情况下没有任何作用**
层级高的摄像机,渲染级别靠后,显示的图像靠前
举个例子: A摄像机深度-1, B摄像机为0, A会被先渲染, 呈现出一个图像, B会后渲染, 也呈现出一个图像, 那只会显示B摄像机的画面; 想象一个画架, 你画了一幅画(用白纸画的),放到了画架上, 你管这张画的深度记为-1, 然后又画了一幅画, 叠在-1的画之上, 你又管这张叠上的画的深度为0, 自然深度为0的画会挡住深度为-1的画, 你也就只能看到深度为0的那幅画

**为什么我上面要强调用什么画的呢?**
因为是有方法让两张画的内容叠加的, 先别想怎么叠加的,先想为什么会有叠加这一功能? 你在玩游戏的时候,你会发现UI是UI, 游戏内容是游戏内容, 它们互不影响, 这里就是把UI叠加到游戏画面的方法, 其中一个摄像机渲染UI, 一个摄像机渲染游戏

**再回头来解释怎么叠加的?**
在Clear Flags里的, 你可以理解为用什么材质的画布去画画, 天空盒就是已经画好的背景, Depth Only就是在用玻璃画画,当然需要配合Culling Mask来使用,决定画在哪一层,这样你渲染出的图就是一个透明背景,但是只渲染你想要的物体的一张图

**总结就是, `Depth Only`与`Culling Mask`与`Depth`是配合使用的,缺一不可**

## Target Texture
在Project窗口中右键可以创建一个`Render Texture` 
可以把摄像机画面渲染到一张图上, 如此设置后, 该摄像机渲染不会影响到Game窗口最终的输出
主要用于做小地图

## Occlusion Culling
是否开启剔除遮挡

如下图, 这是一个俯视图, 可以看到前方正方体挡住了后方的圆,那么开启Occlusion Culling后,将不再渲染这个圆,可以用来提升性能
<center>

![alt](/Unity/图片/Unity入门09-21_16-34-39.jpg)

</center>

## Viewport Rect(从这往下的是不太常用的)
视口范围, 屏幕上将绘制该摄像机视图的范围
主要用于多摄像机游戏, 0-1相当于宽高百分比

**Rendering Path**, 渲染路径
**Allow HDR**, 是否允许高动态范围渲染
**Allow MSAA**, 是否运行抗锯齿
**Allow Dynamic Resolution**, 是否允许动态分辨率呈现
**Target Display**, 用于哪个显示器
***

# 19. Camera代码相关
## 19.1 重要静态成员
### (1) 获取摄像机
- 主摄像机的获取
```CSharp
//如果想通过这种方式 快速获取摄像机 那么场景上必须有一个 tag为MainCamera的摄像机
print(Camera.main.name);
```
- 获取摄像机的数量
```CSharp
print(Camera.allCamerasCount);
```
- 得到所有摄像机
```CSharp
Camera[] allCamera = Camera.allCameras;
print(allCamera.Length);
```
### (2) 渲染相关委托
- 摄像机剔除前处理的委托函数 
```CSharp
Camera.onPreCull += (c) =>{};
```
- 摄像机渲染前处理的委托
```CSharp
Camera.onPreRender += (c) =>{};
```
- 摄像机 渲染后 处理的委托
```CSharp
Camera.onPostRender += (c) =>{};
```

## 19.2 重要静态成员
### (1) 界面上的参数
```CSharp
//比如 下面这句代码 就是得到主摄像机对象 上的深度 进行设置
Camera.main.depth = 10;
```

### (2) 世界坐标转屏幕坐标
转换过后 x和y对应的就是屏幕坐标 z对应的 是 这个3D物体 里我们的摄像机有多远
我们会用这个来做的功能 最多的 就是头顶血条相关的功能
```CSharp
Vector3 v = Camera.main.WorldToScreenPoint(this.transform.position);
```
### (3) 屏幕坐标转世界坐标
只所以改变Z轴 是因为 如果不改 Z默认为0
转换过去的世界坐标系的点 永远都是一个点 可以理解为 视口 相交的焦点
如果改变了Z 那么转换过去的 世界坐标的点 就是相对于 摄像机前方多少的单位的横截面上的世界坐标点
```CSharp
Vector3 v = Input.mousePosition;
v.z = 5;
obj.position = Camera.main.ScreenToWorldPoint(v);
```
***
# 20. 光源系统
渲染窗口
> Window -> Rendering -> Light
## 20.1 光源组件
**Type**
光源类型:
Spot(聚光灯), Directional(方向光,环境光), Point(点光源), Area(面光源)

**Color**:颜色

**Mode**
光源模式
- Realtime: 实时光源, 每帧实时计算, 效果好, 性能消耗大
- Baked: 烘焙光源, 事先计算好, 无法动态变化
- Mixed: 混合光源, 预先计算 + 实时运算

**Intensity**
光源亮度

**Shadow Type**
- NoShadows: 关闭阴影
- HardShadows: 硬阴影(生硬阴影)
- SoftShadows: 软阴影(柔和阴影)

**Cookie**: 投影遮罩
**Draw Halo**: 球形光环
**Flare**: 耀斑, 想看到耀斑效果需要在摄像机上加上flare组件
**Culling Mask**: 剔除遮罩层, 决定哪些层的对象受到该光源影响

**Indirect Multiplier(从这往下的组件都只做了解)**: 改变间接光的强度; >1,每次反弹会使光变暗,反之,变得更亮

**RealtimeShadows**
- Strength: 阴影暗度0 ~ 1之间,越大越黑
- Resolution: 阴影贴图渲染分辨率; 越高越逼真, 消耗越高
- Bias: 阴影推力光源的距离
- Normal Bias: 阴影投射面沿法线收缩距离
- Near Panel: 渲染阴影的近裁剪面

**Render Mode**
渲染优先级
- Auto: 运行时确定
- Important: 以像素质量为单位进行渲染, 效果逼真, 消耗大
- Not Important: 以快速模式进行渲染

## 20.2 光源面板
**Skybox Material**
天空盒材质, 可以改变天空盒

**Sun Source**
太阳来源, 不设置会默认使用场景中最亮的方向光来代表太阳

**Environment Lighting**
- Source: 环境光光源颜色
  - Skybox: 天空盒材质作为环境光颜色
  - Gradient: 可以为天空, 地平线, 地面单独选择颜色和它们之间混合
- Intensity Multiplier: 环境光亮度
- Amibient Mode: 全局光照模式, 只有启用了实时全局和全局烘焙时才有用
  - Realtime
  - Baked
<center>

![alt text](/Unity/图片/Unity入门09-22_09-24-38.jpg)

</center>

***
# 21. 碰撞检测
## 21.1 刚体
**两个物体产生碰撞的必要条件(很重要)**
两个物体都有碰撞器, 至少一个物体有刚体

现在可以把碰撞器(Collider)理解为表示用来物体体积
刚体现在简单来说就是为挂载的物体添加力的作用

**以下都很重要**
- Mass
质量(默认单位是kg), 质量越大惯性越大
</br>
- Drag
空气阻力, 根据力移动对象时影响对象的空气阻力大小, 0 表示没有空气阻力
</br>
- Angular Drag
根据扭矩旋转对象时影响对象的空气阻力大小为0
</br>
- Use Gravity
是否受重力影响
</br>
- Is Kinematic
如果启用此选项, 则对象将不会被物理引擎驱动,只能通过(Transform)对其进行操作, 对于移动平台, 或者如果要动画化附加了HingeJoint的刚体,此属性将非常有用
</br>
- interpolate
插值运算, 让刚体物体移动平滑
    - None 不使用插值
    - Interpolate 插值运算 根据前一帧的变换来平滑变换
    - Extrapolate 插值运算 根据下一帧的估计变换来平滑移动
</br>

- Collision Detection
<center>

![alt text](/Unity/图片/Unity入门09-22_10-02-20.jpg)
</center>

- Constraints
  - Freeze Position: 有选择地停止刚体沿世界X,Y和Z轴的移动
  - Freeze Rotation: 有选择地停止刚体围绕局部X,y和Z轴的旋转
## 21.2 碰撞器
碰撞器表示物体的体积(形状)

刚体会利用体积进行碰撞计算, 模拟真实的碰撞效果, 产生力的作用

### 3D碰撞器的种类
- 盒状, 球状, 胶囊, 网格, 轮胎, 地形

### 共同参数
- Is Trigger
是否是触发器, 如果启用, 则该碰撞体将用于触发事件, 并被物理引擎忽略, 主要用于进行没有物理效果的碰撞检测
勾选Is Trigger的物体意味着它只会用于碰撞检测, 不会再有物理相关的效果了
比如在游戏对敌人中射箭,力道很大, 能射穿过第一个敌人, 再命中后面的敌人, 这时就能为箭施加触发器, 不然射中了第一个敌人后,就会推着他一起向后运动
</br>

- Material
物理材质, 可以确定碰撞体和其他对象碰撞体时的交互(表现)方式
</br>
- Center
碰撞体在对象局部空间中的中心位置

### 常用碰撞器

<center>

![alt text](/Unity/图片/Unity入门09-22_10-52-24.jpg)
</center>

### 异性物体使用多种碰撞器组合
在对象上加Rigidbody组件后,该对象的所有子类的碰撞盒都会进行碰撞检测

## 21.3 物理材质
- Dynamic Friction
    动摩擦力, 通常为0到1之间的值, 值为0摩擦力就为0,值为1将使对象迅速静止
    </br>

- Static Friction
    静摩擦力
    </br>

- Bounciness
    表面弹性, 值为0将不会反弹, 值为1将在反弹是不产生任何能量损失,预计会有一些近似值, 但可能只会给模拟增加少量能量, 也就是说值为1时为弹性反弹,其他都为非弹性反弹, 看剩余能量的程度
    </br>

- Friction Combine
    两个碰撞对象的摩擦力的组合方式
    - Average 对两个摩擦力求平均
    - Minimum 使用两个值中的最小值
    - Maximum 使用两个值中的最大值
    - Multiply 两个摩擦值相乘
  </br>
- unce Combine
    两个碰撞对象的弹性的组合方式, 其模式与Friction Combine模式相同

## 21.2 碰撞检测函数 
碰撞和触发相应的函数 属于 **特殊的生命周期函数**, 也是通过反射调用
<center>

![alt text](/Unity/图片/Unity入门09-22_11-42-03.jpg)

</center>

### (1)物理碰撞响应函数
- 碰撞触发接触时会自动执行这个函数 
```CSharp
void OnCollisionEnter(Collision collision) { }
```
- 碰撞结束分离时会自动执行这个函数
```CSharp
void OnCollisionExit(Collision collision) { }
```
- 两个物体相互接触摩擦时会不停的调用该函数,也就是说两个物体即使紧挨着, 但是它们相对静止了,也是不会调用该函数的
```CSharp
void OnCollisionStay(Collision collision) { }
```

### (2) 关键参数
- 碰撞到的对象碰撞器信息
```CSharp
collision.collider
```
- 碰撞对象的依附对象
```CSharp
collision.gameObject
```
- 碰撞对象的依附对象的位置信息
```CSharp
collision.transform
```
- 触碰点数相关
```CSharp
collision.contactCount
//接触点具体坐标
ContactPoint[] pos = collision.contacts;
```

### (2)触发检测响应函数
- 触发开始的函数, 当第一次接触是会自动调用
```CSharp
void OnTriggerEnter(Collider other) { }
```
- 触发结束的函数, 当两个碰撞器结束相交时 会调用一次
```CSharp
void OnTriggerExit(Collider other) { }
```
- 当两个对象交织的时候, 会不停调用
```CSharp
void OnTriggerStay(Collider other) { }
```
### (3)明确什么时候会响应函数 
只要挂载的对象能和别的物体产生碰撞或触发, 那么对应的以上6个函数就能够被响应, 是不需要考虑挂载的对象上有没有Rigidbody和Collider的
如果是一个组成物体,刚体在父对象上, 如果你想通过子对象上挂脚本检测碰撞是不行的, 必须挂载到这个刚体父对象上

**为什么?**
因为 Unity 的物理系统是把 “父对象 + 所有子对象” 看作一个整体（一个 Rigidbody）。所有子对象的 Collider 都被视为这个父级 Rigidbody 的 “碰撞区域”。
当任何一个子对象的 Collider 发生碰撞时，这个事件是报告给拥有 Rigidbody 的那个 GameObject（父对象）的。只有父对象上的碰撞 / 触发函数才会被激活。

### (4)碰撞和触发器函数都可以写成虚函数, 在子类去重写逻辑
一般会把想要重写的 碰撞和触发函数 写成protected ,没有必要写成public, 因为不会自己手动调用,都是unity通过反射帮助我们自动调用的

## 22. 刚体加力
### 刚体自带添加力的方法

**① 获取刚体组件**
```CSharp
rigidBody = this.GetComponent<Rigidbody>();
```
**②添加力**
- 相对世界坐标, 世界坐标系 Z轴正方向加了一个力
```CSharp
rigidBody.AddForce(Vector3.forward * 10);
//如果想要在 世界坐标系方法中 让对象 相对于自己的面朝向动
rigidBody.AddForce(this.transform.forward * 10);
```
- 相对于局部坐标系
```CSharp
rigidBody.AddRelativeForce(Vector3.forward * 10);
```
**③添加扭矩力, 让其旋转**
  - 相对世界坐标
    ```CSharp
    rigidBody.AddTorque(Vector3.up * 10);
    ```
  - 相对本地坐标
    ```CSharp
    rigidBody.AddRelativeTorque(Vector3.up * 10);
    ```
**④直接改变速度**
```CSharp
//这个速度方向 是相对于 世界坐标系的 
//如果要直接通过改变速度 来让其移动 一定要注意这一点
rigidBody.velocity = Vector3.forward * 5;
```

**⑤模拟爆炸效果**
```CSharp
//模拟爆炸的力 一定是 所有希望产生爆炸效果影响的对象 
//都需要得到他们的刚体 来执行这个方法 才能都有效果
rigidBody.AddExplosionForce(100, Vector3.zero, 10);
```
### 力的几种模式
Acceleration, Force, Impulse, VelocityChange
```CSharp
rigidBody.AddForce(Vector3.forward * 10, ForceMode.Acceleration);
```

**动量定律**
> Ft = mv   ===>  v = Ft/m   

**① Acceleration**
给物体增加一个持续的加速度，忽略其质量,即质量为1

**② Force**
给物体添加一个持续的力，与物体的质量有关

**③ Impulse**
给物体添加一个瞬间的力，与物体的质量有关,忽略时间 默认为1

**④ VelocityChange**
给物体添加一个瞬时速度，忽略质量，忽略时间

### 立场脚本
> Add Component -> Constant Force

### 刚体的休眠
```CSharp
//获取刚体是否处于休眠状态 如果是 
if (rigidBody.IsSleeping())
{
    //就唤醒它
    rigidBody.WakeUp();
}
```
***


