[toc]
***
# 一. 各类型数据转字节数据

## 1.1 各类型数据和字节数据相互转换
C#提供了一个公共类帮助我们进行转化
类名：`BitConverter`
命名空间：`using System`

1. 将各类型转字节
```CSharp
byte[] bytes = BitConverter.GetBytes(256);
```

2. 字节数组转各类型
```CSharp
//这里用 BitConverter.To... 可以转化为各种类型
int i = BitConverter.ToInt32(bytes, 0); 
```

## 1.2 标准编码格式
类名：`Encoding`
需要引用命名空间：`using System.Text`;

1. 将字符串以指定编码格式转字节
```CSharp
byte[] bytes2 = Encoding.UTF8.GetBytes("扶离");
```

2. 字节数组以指定编码格式转字符串
```CSharp
string s = Encoding.UTF8.GetString(bytes2);
```
***
# 二. 文件操作

## 2.1 文件相关操作公共类
C#提供了一个名为File（文件）的公共类, 让我们可以快捷的通过代码操作文件相关

类名：`File`
命名空间： `System.IO`

## 2.2 文件操作File类的常用内容

下面讲解会用到的路径
```CSharp
string path = Application.dataPath + "/example.01";
string pathStr = Application.dataPath + "/exampleStr.01";
string pathStr2 = Application.dataPath + "/exampleStr2.01";
string pathStrCopy = Application.dataPath + "/exampleStrCopy.01";
string pathStrBackUp = Application.dataPath + "/exampleStrBackUp.01";
```

1. 判断文件是否存在
```CSharp
if (File.Exists(path1)) { }
```

2. 创建文件
```CSharp
FileStream fs = File.Create(path1);
```

3. 写入文件
   - 将指定字节数组 写入到指定路径的文件中
   ```CSharp
   byte[] bytes = BitConverter.GetBytes(999);
   File.WriteAllBytes(path1,bytes);
   ```

   - 将指定的string数组内容 一行行写入到指定路径中
   ```CSharp
    string[] strs = new string[] {"qwertyuiop","asdfghjkl","zxcvbnm"};
    File.WriteAllLines(pathStr,strs);
   ```

   - 将指定字符串写入指定路径
   ```CSharp
   File.WriteAllText(pathStr2, "qwertyuiopasdfghjklzxcvbnmn");
   ```

4. 读取文件
    - 读取字节数据
    ```CSharp
    bytes = File.ReadAllBytes(path);
    ```

    - 读取所有行信息
    ```CSharp
    strs = File.ReadAllLines(pathStr);
    ```

    - 读取所有文本信息
    ```CSharp
    string cont = File.ReadAllText(pathStr2);
    ```


5. 删除文件
```CSharp
//注意 如果删除正在打开的文件 会报错
File.Delete(path);
```

6. 复制文件
```CSharp
//参数一：现有文件 需要是流关闭状态
//参数二：目标文件
File.Copy(pathStr,pathStrCopy, true);
```

7. 文件替换
```CSharp
//参数一：用来替换的路径
//参数二：被替换的路径
//参数三：备份路径(备份被替换的文件)
File.Replace(pathStr2, pathStrCopy, pathStrBackUp);
```

- 执行代码前
我事先把文件里的内容改了, 改成了它们各自的文件名
> 现在exampleStr2文件里存的是"exampleStr2"; exampleStrCopy文件里存的是"exampleStrCopy"

<center>

![alt text](/Unity/图片/数据持久化/二进制/二进制10-25_18-53-39.jpg)

</center>

- 执行代码后
>现在exampleStrCopy文件里存的是"exampleStr2"; exampleStrBackUp文件里存的是"exampleStrCopy"
<center>

![alt text](/Unity/图片/数据持久化/二进制/二进制10-25_18-57-32.jpg)

</center>


8. 以流的形式 打开文件并写入或读取
```CSharp
//参数一：路径
//参数二：打开模式
//参数三：访问模式
FileStream fs = File.Open(pathStr, FileMode.OpenOrCreate, FileAccess.ReadWrite);
```
***

# 三. 文件流操作
在C#中提供了一个文件流类 FileStream 类
它主要作用是用于读写文件的细节
我们之前学过的File只能整体读写文件
而FileStream可以以读写字节的形式处理文件

说人话：
文件里面存储的数据就像是一条数据流（数组或者列表）
我们可以通过FileStream一部分一部分的读写数据流
比如我可以先存一个int（4个字节）再存一个bool（1个字节）再存一个string（n个字节）
利用FileStream可以以流式逐个读写

## 3.1 FileStream文件流类常用方法
类名：`FileStream`
需要引用命名空间：`System.IO`

### 3.1.1 打开或创建指定文件
- 方法一：`new FileStream`
    - 参数一：路径
    - 参数二：打开模式
        - CreateNew:创建新文件 如果文件存在 则报错
        - Create:创建文件，如果文件存在 则覆盖
        - Open:打开文件，如果文件不存在 报错
        - OpenOrCreate:打开或者创建文件根据实际情况操作
        - Append:若存在文件，则打开并查找文件尾，或者创建一个新文件
        - Truncate:打开并清空文件内容
    - 参数三：访问模式
    - 参数四：共享权限
        - None 谢绝共享
        - Read 允许别的程序读取当前文件
        - Write 允许别的程序写入该文件
        - ReadWrite 允许别的程序读写该文件
```CSharp
FileStream fs = new FileStream(path, FileMode.Create, FileAccess.ReadWrite);
```
</br>

- 方法二：`File.Create`
  - 参数一：路径
  - 参数二：缓存大小
  - 参数三：描述如何创建或覆盖该文件（不常用）
      - Asynchronous 可用于异步读写
      - DeleteOnClose 不在使用时，自动删除
      - Encrypted 加密
      - None 不应用其它选项
      - RandomAccess 随机访问文件
      - SequentialScan 从头到尾顺序访问文件
      - WriteThrough 通过中间缓存直接写入磁盘
```CSharp
FileStream fs2 = File.Create(path);
```
</br>

- 方法三：`File.Open`
    - 参数一：路径
    - 参数二：打开模式
```CSharp
FileStream fs3 = File.Open(path, FileMode.Open);
```

### 3.1.2 重要属性和方法
先声明一个文件流
```CSharp
FileStream fs = File.Open(path, FileMode.OpenOrCreate);
```

- 文本字节长度
    ```CSharp
    fs.Length
    ```

- 是否可写
    ```CSharp
    if(fs.CanRead){ }
    ```

- 是否可读
    ```CSharp
    if(fs.CanWrite){ }
    ```

- 将字节写入文件 当写入后 一定执行一次
    ```CSharp
    fs.Flush();
    ```

- 关闭流 当文件读写完毕后 一定执行
    ```CSharp
    fs.Close();
    ```

- 缓存资源销毁回收
    ```CSharp
    fs.Dispose();
    ```


### 3.1.3 写入字节
- 方法：`Write`
    - 参数一：写入的字节数组
    - 参数二：数组中的开始索引
    - 参数三：写入多少个字节

```CSharp
byte[] bytes = BitConverter.GetBytes(100);

fs.Write(bytes, 0, bytes.Length);
```

**写入字符串**
```CSharp
byte[] bytes = Encoding.UTF8.GetBytes("asdfghjkl;'");
// 先写入长度
fs.Write(BitConverter.GetBytes(bytes.Length), 0, 4);
// 再写入字符串具体内容
fs.Write(bytes, 0, bytes.Length);
```

### 3.1.4 读取字节
- 方法一：挨个读取字节数组
```CSharp
using (FileStream fs2 = File.Open(path,FileMode.Open,FileAccess.Read))
{
    //读取一个整形
    byte[] bytes2 = new byte[4];
    //参数一：用于存储读取的字节数组的容器
    //参数二：容器中开始的位置
    //参数三：读取多少个字节装入容器
    //返回值：当前流索引前进了几个位置
    int index = fs2.Read(bytes2, 0, 4);
    int num = BitConverter.ToInt32(bytes2, 0);


    //读取一个String类型
    //先读字符串长度, 再读字符串
    index = fs2.Read(bytes2, 0, 4);
    int length = BitConverter.ToInt32(bytes2, 0);

    bytes2 = new byte[length];
    index = fs2.Read(bytes2, 0, length);
    String str = Encoding.UTF8.GetString(bytes2);


    fs2.Dispose();
}
```

- 方法二：一次性读取再挨个读取
```CSharp
using (FileStream fs3 = File.Open(path, FileMode.Open, FileAccess.Read))
{
    //一开始就声明一个 和文件字节数组长度一样的容器
    byte[] bytes3 = new byte[fs3.Length];
    fs3.Read(bytes3, 0, (int)fs3.Length);
    fs3.Dispose();

    //读取整数
    int num = BitConverter.ToInt32(bytes3,0);

    //读取字符串
    //读取字符串字节数组的长度
    int strLen = BitConverter.ToInt32(bytes3, 4);
    //得到字符串
    string str = Encoding.UTF8.GetString(bytes3, 8, strLen);
}
```

### 3.1.5 更加安全的使用文件流对象
using关键字重要用法
```CSharp
using (声明一个引用对象)
{
    使用对象
}
```
无论发生什么情况 当using语句块结束后 
会自动调用该对象的销毁方法 避免忘记销毁或关闭流
using是一种更安全的使用方法

目前我们对文件流进行操作 为了文件操作安全 都用using来进行处理最好

***
# 四. 文件夹操作

## 4.1 文件夹操作公共类
类名: `Directory`
命名空间：`using System.IO`

1. 判断文件夹是否存在
```CSharp
if( Directory.Exists(path)) { }
```

2. 创建文件夹
```CSharp
DirectoryInfo info = Directory.CreateDirectory(path);
```

3. 删除文件夹
参数一：路径
参数二：是否删除非空目录，如果为true，将删除整个目录，如果是false，仅当该目录为空时才可删除
```CSharp
Directory.Delete(path);
```

4. 查找文件夹和文件
   - 得到指定路径下所有文件夹名
    ```CSharp
    string[] strs = Directory.GetDirectories(Application.dataPath);
    ```
   - 得到指定路径下所有文件名
    ```CSharp
    strs = Directory.GetFiles(Application.dataPath);
    ```
</br>

5. 移动文件夹
如果第二个参数所在的路径 已经存在了一个文件夹 那么会报错
移动会把文件夹中的所有内容一起移到新的路径
```CSharp
Directory.Move(pathFrom, pathTo);
```

## 4.2 DirectoryInfo和FileInfo
**`DirectoryInfo目录信息类`**

我们可以通过它获取文件夹的更多信息
它主要出现在两个地方

1. 创建文件夹方法的返回值
    ```CSharp
    DirectoryInfo dInfo = Directory.CreateDirectory(path);
    ```
   - 全路径 
    ```CSharp
    dInfo.FullName
    ```
   - 文件名
    ```CSharp
    dInfo.Name
    ```
2. 查找上级文件夹信息
    ```CSharp
    dInfo = Directory.GetParent(path);
    ```
3. 重要方法
得到所有子文件夹的目录信息
```CSharp
DirectoryInfo[] dInfos = dInfo.GetDirectories();
```

**`FileInfo文件信息类`**

```CSharp
//可以通过DirectoryInfo得到该文件下的所有文件信息
FileInfo[] fInfos = dInfo.GetFiles(); 
for (int i = 0; i < fInfos.Length; i++)
{
    print("**************");
    print(fInfos[i].Name);//文件名
    print(fInfos[i].FullName);//路径
    print(fInfos[i].Length);//字节长度
    print(fInfos[i].Extension);//后缀名
}
```