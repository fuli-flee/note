[toc]
***
# 一. 单例模式基类

## 1.1 不继承MonoBehaviour的单例模式基类

用面向对象的思想避免代码冗余（多余、重复）

### 1.1.1 管理单例的基类
如果想用基类, 直接继承它就行了, 然后在此基础上拓展自己的方法
下面两种方法都行, 我更偏向用属性的方法
```CSharp
public class BaseManager<T> where T : class, new()
{
    private static T instance;

    //用属性的方法
    public static T Instance
    {
        get
        {
            if (instance == null)
                instance = new T();
            return instance;
        }
    }
    
    //用函数的方法
    public static T GetInstance()
    {
        if (instance == null)
            instance = new T();
        return instance;
    }
}

```

### 1.1.2 潜在的安全问题
1. 构造函数问题：构造函数可在外部调用 可能会破坏唯一性
2. 多线程问题：当多个线程同时访问管理器时，可能会出现共享资源的安全访问问题

***
## 1.2 继承MonoBehaviour的单例模式基类

### 1.2.1 注意事项
继承MonoBehaviour的脚本不能new！
继承MonoBehaviour的脚本不能new！
继承MonoBehaviour的脚本不能new！

继承MonoBehaviour的脚本一定得依附在GameObject上
继承MonoBehaviour的脚本一定得依附在GameObject上
继承MonoBehaviour的脚本一定得依附在GameObject上

### 1.2.2 挂载式继承MonoBehaviour的单例模式基类的实现

先说好, 不推荐用这种方法, 因为很难控制它的唯一性, 你不知道你在哪里就多挂载了,但是也要理解它的原理

破坏唯一性的可能场景:
1. 挂载多个脚本
2. 切换场景回来时，由于场景放置了挂载脚本的对象，回到该场景时 又会有一个该单例模式对象
3. 还可以通过代码动态的添加多个该脚本 也会破坏唯一性

```CSharp
public class SingletonMono<T>: MonoBehaviour  where T : MonoBehaviour
{
    private static T instance;

    public static T Instance => instance;

    protected virtual void Awake()
    {
        instance = this as T;
    }
}

```

上面的第2点我再多补充一下:
- 你运行一个你写好的程序, 进入第一个场景, 这个场景里有单例创建出来了, 然后你切换到了另一个场景, 又切回来了, 你并没有删除单例, 所以根据这个代码, 它又会创建一个单例对象
</br>

- 那是不是加个if (instance == null)判空一下就行了呢?
</br>

- 答案是否定的, 当你切换场景再返回时，Unity 会重新加载场景中的所有对象，包括挂载了单例脚本的 GameObject。此时会发生：
  1. 旧场景中的单例实例如果没被销毁，仍然存在（instance 指向它）。
  2. 新场景加载时，会创建一个新的单例实例，触发 Awake 方法。

    如果只加 if (instance == null)，新实例会发现 instance 已被旧实例占用，导致新实例无法赋值，但旧实例和新实例会同时存在于场景中（两个 GameObject），违反单例的唯一性。

### 1.2.3 自动挂载式继承MonoBehaviour的单例模式基类的实现

这是开发当中常用的单例模式基类

```CSharp
public class SingletonAutoMono<T>: MonoBehaviour  where T : MonoBehaviour
{
    private static T instance;

    public static T Instance
    {
        get
        {
            if (instance == null)
            {
                GameObject obj = new GameObject();
                obj.name = typeof(T).ToString();
                instance = obj.AddComponent<T>();
                DontDestroyOnLoad(obj);
            }
            return instance;
        }
    }
}
```

### 1.2.4 潜在的安全问题
1. 构造函数问题：
  继承MonoBehaviour的函数，不能new，所以不用担心公共构造函数
2. 多线程问题：
  Unity主线程中相关内容，不允许其他线程直接调用，很少有这样的需求，所以也不用太担心
3. 重复挂载问题：
   1. 手动重复挂载
   2. 代码重复添加

需要人为干涉，定规则，或者通过代码逻辑强制处理

***
## 1.3 安全相关

### 1.3.1 唯一性问题--构造函数
1. 对于不继承MonoBehaviour的单例模式基类
   我们要避免在外部 new 单例模式类对象
</br>

2. 对于继承MonoBehaviour的单例模式基类
   由于继承MonoBehaviour的脚本不能通过new创建，因此不用过多考虑

#### 1.3.1.1 解决构造函数带来的安全问题

解决方案:
1. 父类变为抽象类

2. 规定继承单例模式基类的类必须显示实现私有无参构造函数

3. 在基类中通过反射来调用私有构造函数实例化对象
  主要知识点：
  利用Type中的 GetConstructor(约束条件, 绑定对象, 参数类型, 参数修饰符)方法来获取私有无参构造函数
  ```CSharp
  ConstructorInfo constructor = typeof(T).GetConstructor(
  BindingFlags.Instance | BindingFlags.NonPublic, //表示成员私有方法
    null,                                         //表示没有绑定对象
    Type.EmptyTypes,                              //表示没有参数
    null);                                        //表示没有参数修饰符
  ```

### 1.3.2 唯一性问题--重复挂载
### 1.3.3 线程安全--是否加锁