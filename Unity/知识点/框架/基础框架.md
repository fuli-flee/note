[toc]
***
# 一. 单例模式基类

## 1.1 不继承MonoBehaviour的单例模式基类

用面向对象的思想避免代码冗余（多余、重复）

### 1.1.1 管理单例的基类
如果想用基类, 直接继承它就行了, 然后在此基础上拓展自己的方法
下面两种方法都行, 我更偏向用属性的方法
```CSharp
public class BaseManager<T> where T : class, new()
{
    private static T instance;

    //用属性的方法
    public static T Instance
    {
        get
        {
            if (instance == null)
                instance = new T();
            return instance;
        }
    }
    
    //用函数的方法
    public static T GetInstance()
    {
        if (instance == null)
            instance = new T();
        return instance;
    }
}

```

### 1.1.2 潜在的安全问题
1. 构造函数问题：构造函数可在外部调用 可能会破坏唯一性
2. 多线程问题：当多个线程同时访问管理器时，可能会出现共享资源的安全访问问题

***
## 1.2 继承MonoBehaviour的单例模式基类

### 1.2.1 注意事项
继承MonoBehaviour的脚本不能new！
继承MonoBehaviour的脚本不能new！
继承MonoBehaviour的脚本不能new！

继承MonoBehaviour的脚本一定得依附在GameObject上
继承MonoBehaviour的脚本一定得依附在GameObject上
继承MonoBehaviour的脚本一定得依附在GameObject上

### 1.2.2 挂载式继承MonoBehaviour的单例模式基类的实现

先说好, 不推荐用这种方法, 因为很难控制它的唯一性, 你不知道你在哪里就多挂载了,但是也要理解它的原理

破坏唯一性的可能场景:
1. 挂载多个脚本
2. 切换场景回来时，由于场景放置了挂载脚本的对象，回到该场景时 又会有一个该单例模式对象
3. 还可以通过代码动态的添加多个该脚本 也会破坏唯一性

```CSharp
public class SingletonMono<T>: MonoBehaviour  where T : MonoBehaviour
{
    private static T instance;

    public static T Instance => instance;

    protected virtual void Awake()
    {
        instance = this as T;
    }
}

```

上面的第2点我再多补充一下:
- 你运行一个你写好的程序, 进入第一个场景, 这个场景里有单例创建出来了, 然后你切换到了另一个场景, 又切回来了, 你并没有删除单例, 所以根据这个代码, 它又会创建一个单例对象
</br>

- 那是不是加个if (instance == null)判空一下就行了呢?
</br>

- 答案是否定的, 当你切换场景再返回时，Unity 会重新加载场景中的所有对象，包括挂载了单例脚本的 GameObject。此时会发生：
  1. 旧场景中的单例实例如果没被销毁，仍然存在（instance 指向它）。
  2. 新场景加载时，会创建一个新的单例实例，触发 Awake 方法。

    如果只加 if (instance == null)，新实例会发现 instance 已被旧实例占用，导致新实例无法赋值，但旧实例和新实例会同时存在于场景中（两个 GameObject），违反单例的唯一性。

### 1.2.3 自动挂载式继承MonoBehaviour的单例模式基类的实现

这是开发当中常用的单例模式基类

```CSharp
public class SingletonAutoMono<T>: MonoBehaviour  where T : MonoBehaviour
{
    private static T instance;

    public static T Instance
    {
        get
        {
            if (instance == null)
            {
                GameObject obj = new GameObject();
                obj.name = typeof(T).ToString();
                instance = obj.AddComponent<T>();
                DontDestroyOnLoad(obj);
            }
            return instance;
        }
    }
}
```

### 1.2.4 潜在的安全问题
1. 构造函数问题：
  继承MonoBehaviour的函数，不能new，所以不用担心公共构造函数
2. 多线程问题：
  Unity主线程中相关内容，不允许其他线程直接调用，很少有这样的需求，所以也不用太担心
3. 重复挂载问题：
   1. 手动重复挂载
   2. 代码重复添加

需要人为干涉，定规则，或者通过代码逻辑强制处理

***
## 1.3 安全相关

### 1.3.1 唯一性问题--构造函数
1. 对于不继承MonoBehaviour的单例模式基类
   我们要避免在外部 new 单例模式类对象
</br>

2. 对于继承MonoBehaviour的单例模式基类
   由于继承MonoBehaviour的脚本不能通过new创建，因此不用过多考虑

#### 1.3.1.1 解决构造函数带来的安全问题

解决方案:
1. 父类变为抽象类

2. 规定继承单例模式基类的类必须显示实现私有无参构造函数

3. 在基类中通过反射来调用私有构造函数实例化对象
  主要知识点：
  利用Type中的 GetConstructor(约束条件, 绑定对象, 参数类型, 参数修饰符)方法来获取私有无参构造函数
  ```CSharp
  ConstructorInfo constructor = typeof(T).GetConstructor(
  BindingFlags.Instance | BindingFlags.NonPublic, //表示成员私有方法
    null,                                         //表示没有绑定对象
    Type.EmptyTypes,                              //表示没有参数
    null);                                        //表示没有参数修饰符
  ```
***
### 1.3.2 唯一性问题--重复挂载

对于继承MonoBehaviour的挂载式的单例模式基类
1. 手动挂载多个相同单例模式脚本
2. 代码动态添加多个相同单例模式脚本

#### 1.3.2.1 解决重复挂载带来的安全问题

解决方案: 
- 对于挂载式的单例模式脚本
  1. 同个对象的重复挂载
    为脚本添加特性[DisallowMultipleComponent]
    这个方法治标不治本, 在不同的对象上依然可以挂载同一种脚本

  2. 修改代码逻辑
    判断如果存在对象，移除脚本

- 对于自动挂载式的单例模式脚本
  制定使用规则，不允许手动挂载或代码添加

### 1.3.3 线程安全--是否加锁
如果程序当中存在多线程
我们需要考虑当多个线程同时访问同一个内存空间时出现的问题
如果不加以控制，可能会导致数据出错
我们一般称这种问题为多线程并发问题，指多线程对共享数据的并发访问和操作。

而一般解决该问题的方式，就是通过C#中的lock关键字进行加锁
我们需要考虑我们的单例模式对象们是否需要加锁(lock)

lock 的原理保证了在任何时刻只有一个线程能够执行被锁保护的代码块
从而防止多个线程同时访问或修改共享资源，确保线程安全

#### 1.3.3.1 解决多线程并发来带的问题
1. 不继承MonoBehaviour的单例模式
  建议加锁，避免以后使用多线程时出现并发问题
  比如在处理网络通讯模块、复杂算法模块时，经常会进行多线程并发处理
</br>

2. 继承MonoBehaviour的单例模式
  可加可不加，但是建议不加。
  因为Unity中的机制是，Unity主线程中处理的一些对象（如GameObject、Transform等等）
  是不允许被其他多线程修改访问的，会直接报错
  因此我们一般不会通过多线程去访问继承MonoBehaviour的相关对象
  既然如此，就不会发生多线程并发问题

**代码实现**
```CSharp
public static T Instance
{
    get
    {
        if (instance == null)
        {
            lock (lockObj)
            {
                if (instance == null)
                {
                    Type type = typeof(T);
                    ConstructorInfo info = type.GetConstructor(BindingFlags.NonPublic | BindingFlags.Instance, null,
                        Type.EmptyTypes, null);
                    if (info != null)
                    {
                        instance = info.Invoke(null) as T;
                    }
                    else
                    {
                        Debug.LogError("没有得到相应的无参构造函数");
                    }
                }
            }
        }
        return instance;
    }
}
```

- 解释一下上面代码中的**双重检查锁定**, 也就是那两个`if (instance == null)`判断(以下为了方便, 下面说的判空指的就是这个)
</br>

- 首先要知道加锁对于并发场景来说是很耗时的, 举个例子, 如果当AB两个线程都在判断第一个判空时通过了, 那么两个线程都来到了`lock (lockObj)`这一句, 但是肯定有一个线程先执行这句代码, 我这里假设A线程先执行这句加锁代码, 那么 B 就只能等他执行完加锁代码后, A 就也会进入加锁代码块中, 此时A就通过不了第二个判空, 如果没有第二个判空, 那么执行其中的逻辑, 就会又声明一个新的instance单例, 就破坏了唯一性
</br>

- 总结: 
  - 第一个判空是为了在实例化单例后防止重复进入加锁代码块而导致性能消耗
  - 第二个判空是为了防止多个线程在进入加锁代码块后都创建单例, 从而破坏唯一性
***
## 1.4 "懒汉" 与 "饿汉"
上面的演示代码全是 "懒汉", 而且 "懒汉" 的使用频率较多

### 1.4.1 懒汉
主要特点是在属性或者方法中**进行判空后再实例化**。

这个懒字体现在：这种单例模式**只会在第一次使用时才创建事例，而不是应用程序启动时就创建。** 一种“敌不动我不动”，“催一下动一下”的感觉

在商业项目中，游戏系统是非常多的，内存开销也是较大的，懒汉模式的**延迟实例化**特点可以帮助我们在一定程度上缓解一丁点的内存压力。（因为用才分配，不用不分配）

我来举个例子, UI 就非常适合用单例模式, 你玩王者荣耀, 你目标很明确, 我就是想开把5V5, 我一点也不想去看商城, 那加载耗时的就只有和5V5相关的UI, 本来我是不会去加载商城相关的UI的, 但是你用饿汉模式, 在进入游戏主界面时就一定要把其他你可能都不会点开的UI系统一起加载了, 那不就浪费时间了吗?

### 1.4.2 饿汉
“饿汉”单例模式的传统写法如下
```CSharp
public abstract class SingletonManager<T> where T : class, new()
{
    private static T instance =  new T();

    public static T Instance => instance;
}
```
这个饿字的体现在：这种单例模式在以下几种情况下会直接初始化
1. 创建该类型实例时（比如外部手动new一个对象，但是并没有使用该单例）
2. 访问静态成员时（比如访问其他静态内容，但是并没有使用该单例）
3. 使用反射获取该类型时
4. 加载程序集时（可能会，受诸多因素影响）

也就是说在这些时刻无论是否使用该事例，都会直接初始化

相当于不管我“吃不吃”，我就要创建它，先放在那，一种“饥不择食”的感觉。

虽然看起来“饿汉”没有“懒汉”那么好，但实际上，“饿汉”最大的优点就是“懒汉”的缺点，因为“饿汉”不用在实例化时考虑线程安全问题，它具有**天生的线程安全，C#会确保在多线程环境中这种静态成员的初始化只发生一次**。

***
# 二. 公共Mono

它的主要作用就是:
让不继承MonoBehaviour的脚本也能
1. 利用帧更新或定时更新处理逻辑
2. 利用协同程序处理逻辑
3. 可以统一执行管理帧更新或定时更新相关逻辑

它的基本原理
1. 通过事件或委托管理不继承MonoBehaviour脚本的相关更新函数
2. 提供协同程序开启或关闭的方法

## 2.1 主要实现
1. 创建MonoMgr继承 自动挂载式的继承MonoBehaviour的单例模式基类
2. 实现Update、FixedUpdate、LateUpdate生命周期函数
3. 声明对应事件或委托用于存储外部函数，并提供添加移除方法，从而达到让不继承MonoBehaviour的脚本可以执行帧更新或定时更新的目的
4. 声明协同程序开启关闭函数，从而达到让不继承MonoBehaviour的脚本可以执行协同程序的目的

```CSharp
//你别看这代码有点长, 但是其实就是分Update、FixedUpdate、LateUpdate来写的, 看懂一个就行了
using UnityEngine.Events;

public class MonoMgr : SingletonAutoMono<MonoMgr>
{
    private event UnityAction updateEvent;
    private event UnityAction fixedUpdateEvent;
    private event UnityAction lateUpdateEvent;

    private void AddUpdateListener(UnityAction updateFun)
    {
        updateEvent += updateFun;
    }
    
    private void RemoveUpdateListener(UnityAction updateFun)
    {
        updateEvent -= updateFun;
    }
    
    private void AddFixedUpdateListener(UnityAction fixedUpdateFun)
    {
        fixedUpdateEvent += fixedUpdateFun;
    }
    
    private void RemoveFixedUpdateListener(UnityAction fixedUpdateFun)
    {
        fixedUpdateEvent -= fixedUpdateFun;
    }
    
    private void AddLateUpdateListener(UnityAction lateUpdateFun)
    {
        lateUpdateEvent += lateUpdateFun;
    }
    
    private void RemoveLateUpdateListener(UnityAction lateUpdateFun)
    {
        lateUpdateEvent -= lateUpdateFun;
    }

    private void Update()
    {
        updateEvent?.Invoke();
    }

    private void FixedUpdate()
    {
        fixedUpdateEvent?.Invoke();
    }

    private void LateUpdate()
    {
        lateUpdateEvent?.Invoke();
    }
}
```