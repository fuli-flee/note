[toc]
***
# 一. 单例模式基类

## 1.1 不继承MonoBehaviour的单例模式基类

用面向对象的思想避免代码冗余（多余、重复）

### 1.1.1 管理单例的基类
如果想用基类, 直接继承它就行了, 然后在此基础上拓展自己的方法
下面两种方法都行, 我更偏向用属性的方法
```CSharp
public class BaseManager<T> where T : class, new()
{
    private static T instance;

    //用属性的方法
    public static T Instance
    {
        get
        {
            if (instance == null)
                instance = new T();
            return instance;
        }
    }
    
    //用函数的方法
    public static T GetInstance()
    {
        if (instance == null)
            instance = new T();
        return instance;
    }
}

```

### 1.1.2 潜在的安全问题
1. 构造函数问题：构造函数可在外部调用 可能会破坏唯一性
2. 多线程问题：当多个线程同时访问管理器时，可能会出现共享资源的安全访问问题

***
## 1.2 继承MonoBehaviour的单例模式基类

### 1.2.1 注意事项
继承MonoBehaviour的脚本不能new！
继承MonoBehaviour的脚本不能new！
继承MonoBehaviour的脚本不能new！

继承MonoBehaviour的脚本一定得依附在GameObject上
继承MonoBehaviour的脚本一定得依附在GameObject上
继承MonoBehaviour的脚本一定得依附在GameObject上

### 1.2.2 挂载式继承MonoBehaviour的单例模式基类的实现

先说好, 不推荐用这种方法, 因为很难控制它的唯一性, 你不知道你在哪里就多挂载了,但是也要理解它的原理

破坏唯一性的可能场景:
1. 挂载多个脚本
2. 切换场景回来时，由于场景放置了挂载脚本的对象，回到该场景时 又会有一个该单例模式对象
3. 还可以通过代码动态的添加多个该脚本 也会破坏唯一性

```CSharp
public class SingletonMono<T>: MonoBehaviour  where T : MonoBehaviour
{
    private static T instance;

    public static T Instance => instance;

    protected virtual void Awake()
    {
        instance = this as T;
    }
}

```

上面的第2点我再多补充一下:
- 你运行一个你写好的程序, 进入第一个场景, 这个场景里有单例创建出来了, 然后你切换到了另一个场景, 又切回来了, 你并没有删除单例, 所以根据这个代码, 它又会创建一个单例对象
</br>

- 那是不是加个if (instance == null)判空一下就行了呢?
</br>

- 答案是否定的, 当你切换场景再返回时，Unity 会重新加载场景中的所有对象，包括挂载了单例脚本的 GameObject。此时会发生：
  1. 旧场景中的单例实例如果没被销毁，仍然存在（instance 指向它）。
  2. 新场景加载时，会创建一个新的单例实例，触发 Awake 方法。

    如果只加 if (instance == null)，新实例会发现 instance 已被旧实例占用，导致新实例无法赋值，但旧实例和新实例会同时存在于场景中（两个 GameObject），违反单例的唯一性。

### 1.2.3 自动挂载式继承MonoBehaviour的单例模式基类的实现

这是开发当中常用的单例模式基类

```CSharp
public class SingletonAutoMono<T>: MonoBehaviour  where T : MonoBehaviour
{
    private static T instance;

    public static T Instance
    {
        get
        {
            if (instance == null)
            {
                GameObject obj = new GameObject();
                obj.name = typeof(T).ToString();
                instance = obj.AddComponent<T>();
                DontDestroyOnLoad(obj);
            }
            return instance;
        }
    }
}
```

### 1.2.4 潜在的安全问题
1. 构造函数问题：
  继承MonoBehaviour的函数，不能new，所以不用担心公共构造函数
2. 多线程问题：
  Unity主线程中相关内容，不允许其他线程直接调用，很少有这样的需求，所以也不用太担心
3. 重复挂载问题：
   1. 手动重复挂载
   2. 代码重复添加

需要人为干涉，定规则，或者通过代码逻辑强制处理

***
## 1.3 安全相关

### 1.3.1 唯一性问题--构造函数
1. 对于不继承MonoBehaviour的单例模式基类
   我们要避免在外部 new 单例模式类对象
</br>

2. 对于继承MonoBehaviour的单例模式基类
   由于继承MonoBehaviour的脚本不能通过new创建，因此不用过多考虑

#### 1.3.1.1 解决构造函数带来的安全问题

解决方案:
1. 父类变为抽象类

2. 规定继承单例模式基类的类必须显示实现私有无参构造函数

3. 在基类中通过反射来调用私有构造函数实例化对象
  主要知识点：
  利用Type中的 GetConstructor(约束条件, 绑定对象, 参数类型, 参数修饰符)方法来获取私有无参构造函数
  ```CSharp
  ConstructorInfo constructor = typeof(T).GetConstructor(
  BindingFlags.Instance | BindingFlags.NonPublic, //表示成员私有方法
    null,                                         //表示没有绑定对象
    Type.EmptyTypes,                              //表示没有参数
    null);                                        //表示没有参数修饰符
  ```
***
### 1.3.2 唯一性问题--重复挂载

对于继承MonoBehaviour的挂载式的单例模式基类
1. 手动挂载多个相同单例模式脚本
2. 代码动态添加多个相同单例模式脚本

#### 1.3.2.1 解决重复挂载带来的安全问题

解决方案: 
- 对于挂载式的单例模式脚本
  1. 同个对象的重复挂载
    为脚本添加特性[DisallowMultipleComponent]
    这个方法治标不治本, 在不同的对象上依然可以挂载同一种脚本

  2. 修改代码逻辑
    判断如果存在对象，移除脚本

- 对于自动挂载式的单例模式脚本
  制定使用规则，不允许手动挂载或代码添加

### 1.3.3 线程安全--是否加锁
如果程序当中存在多线程
我们需要考虑当多个线程同时访问同一个内存空间时出现的问题
如果不加以控制，可能会导致数据出错
我们一般称这种问题为多线程并发问题，指多线程对共享数据的并发访问和操作。

而一般解决该问题的方式，就是通过C#中的lock关键字进行加锁
我们需要考虑我们的单例模式对象们是否需要加锁(lock)

lock 的原理保证了在任何时刻只有一个线程能够执行被锁保护的代码块
从而防止多个线程同时访问或修改共享资源，确保线程安全

#### 1.3.3.1 解决多线程并发来带的问题
1. 不继承MonoBehaviour的单例模式
  建议加锁，避免以后使用多线程时出现并发问题
  比如在处理网络通讯模块、复杂算法模块时，经常会进行多线程并发处理
</br>

2. 继承MonoBehaviour的单例模式
  可加可不加，但是建议不加。
  因为Unity中的机制是，Unity主线程中处理的一些对象（如GameObject、Transform等等）
  是不允许被其他多线程修改访问的，会直接报错
  因此我们一般不会通过多线程去访问继承MonoBehaviour的相关对象
  既然如此，就不会发生多线程并发问题

**代码实现**
```CSharp
public static T Instance
{
    get
    {
        if (instance == null)
        {
            lock (lockObj)
            {
                if (instance == null)
                {
                    Type type = typeof(T);
                    ConstructorInfo info = type.GetConstructor(BindingFlags.NonPublic | BindingFlags.Instance, null,
                        Type.EmptyTypes, null);
                    if (info != null)
                    {
                        instance = info.Invoke(null) as T;
                    }
                    else
                    {
                        Debug.LogError("没有得到相应的无参构造函数");
                    }
                }
            }
        }
        return instance;
    }
}
```

- 解释一下上面代码中的**双重检查锁定**, 也就是那两个`if (instance == null)`判断(以下为了方便, 下面说的判空指的就是这个)
</br>

- 首先要知道加锁对于并发场景来说是很耗时的, 举个例子, 如果当AB两个线程都在判断第一个判空时通过了, 那么两个线程都来到了`lock (lockObj)`这一句, 但是肯定有一个线程先执行这句代码, 我这里假设A线程先执行这句加锁代码, 那么 B 就只能等他执行完加锁代码后, A 就也会进入加锁代码块中, 此时A就通过不了第二个判空, 如果没有第二个判空, 那么执行其中的逻辑, 就会又声明一个新的instance单例, 就破坏了唯一性
</br>

- 总结: 
  - 第一个判空是为了在实例化单例后防止重复进入加锁代码块而导致性能消耗
  - 第二个判空是为了防止多个线程在进入加锁代码块后都创建单例, 从而破坏唯一性
***
## 1.4 "懒汉" 与 "饿汉"
上面的演示代码全是 "懒汉", 而且 "懒汉" 的使用频率较多

### 1.4.1 懒汉
主要特点是在属性或者方法中**进行判空后再实例化**。

这个懒字体现在：这种单例模式**只会在第一次使用时才创建事例，而不是应用程序启动时就创建。** 一种“敌不动我不动”，“催一下动一下”的感觉

在商业项目中，游戏系统是非常多的，内存开销也是较大的，懒汉模式的**延迟实例化**特点可以帮助我们在一定程度上缓解一丁点的内存压力。（因为用才分配，不用不分配）

我来举个例子, UI 就非常适合用单例模式, 你玩王者荣耀, 你目标很明确, 我就是想开把5V5, 我一点也不想去看商城, 那加载耗时的就只有和5V5相关的UI, 本来我是不会去加载商城相关的UI的, 但是你用饿汉模式, 在进入游戏主界面时就一定要把其他你可能都不会点开的UI系统一起加载了, 那不就浪费时间了吗?

### 1.4.2 饿汉
“饿汉”单例模式的传统写法如下
```CSharp
public abstract class SingletonManager<T> where T : class, new()
{
    private static T instance =  new T();

    public static T Instance => instance;
}
```
这个饿字的体现在：这种单例模式在以下几种情况下会直接初始化
1. 创建该类型实例时（比如外部手动new一个对象，但是并没有使用该单例）
2. 访问静态成员时（比如访问其他静态内容，但是并没有使用该单例）
3. 使用反射获取该类型时
4. 加载程序集时（可能会，受诸多因素影响）

也就是说在这些时刻无论是否使用该事例，都会直接初始化

相当于不管我“吃不吃”，我就要创建它，先放在那，一种“饥不择食”的感觉。

虽然看起来“饿汉”没有“懒汉”那么好，但实际上，“饿汉”最大的优点就是“懒汉”的缺点，因为“饿汉”不用在实例化时考虑线程安全问题，它具有**天生的线程安全，C#会确保在多线程环境中这种静态成员的初始化只发生一次**。

***
# 二. 公共Mono

它的主要作用就是:
让不继承MonoBehaviour的脚本也能
1. 利用帧更新或定时更新处理逻辑
2. 利用协同程序处理逻辑
3. 可以统一执行管理帧更新或定时更新相关逻辑

它的基本原理
1. 通过事件或委托管理不继承MonoBehaviour脚本的相关更新函数
2. 提供协同程序开启或关闭的方法

## 2.1 主要实现
1. 创建MonoMgr继承 自动挂载式的继承MonoBehaviour的单例模式基类
2. 实现Update、FixedUpdate、LateUpdate生命周期函数
3. 声明对应事件或委托用于存储外部函数，并提供添加移除方法，从而达到让不继承MonoBehaviour的脚本可以执行帧更新或定时更新的目的
4. 声明协同程序开启关闭函数，从而达到让不继承MonoBehaviour的脚本可以执行协同程序的目的

```CSharp
//你别看这代码有点长, 但是其实就是分Update、FixedUpdate、LateUpdate来写的, 看懂一个就行了
using UnityEngine.Events;

public class MonoMgr : SingletonAutoMono<MonoMgr>
{
    private event UnityAction updateEvent;
    private event UnityAction fixedUpdateEvent;
    private event UnityAction lateUpdateEvent;

    private void AddUpdateListener(UnityAction updateFun)
    {
        updateEvent += updateFun;
    }
    
    private void RemoveUpdateListener(UnityAction updateFun)
    {
        updateEvent -= updateFun;
    }
    
    private void AddFixedUpdateListener(UnityAction fixedUpdateFun)
    {
        fixedUpdateEvent += fixedUpdateFun;
    }
    
    private void RemoveFixedUpdateListener(UnityAction fixedUpdateFun)
    {
        fixedUpdateEvent -= fixedUpdateFun;
    }
    
    private void AddLateUpdateListener(UnityAction lateUpdateFun)
    {
        lateUpdateEvent += lateUpdateFun;
    }
    
    private void RemoveLateUpdateListener(UnityAction lateUpdateFun)
    {
        lateUpdateEvent -= lateUpdateFun;
    }

    private void Update()
    {
        updateEvent?.Invoke();
    }

    private void FixedUpdate()
    {
        fixedUpdateEvent?.Invoke();
    }

    private void LateUpdate()
    {
        lateUpdateEvent?.Invoke();
    }
}
```
对于继承了MonoBehaviour的类来说, 就可以将他们的Update、FixedUpdate、LateUpdate集中在一起进行管理, 这样可以省一些性能消耗
```CSharp
public class HasMonoTest : MonoBehaviour
{
    private void Start()
    {
        MonoMgr.Instance.AddUpdateListener(TestUpdate);
    }

    //和直接写在Update的效果一样
    void TestUpdate()
    {
        print("TestUpdate");
    }
}
```

## 2.2 补充
- 除了公共Mono模块这种做法能让不继承Mono的脚本进行帧更新以外, 请问其它还有什么做法可以？
</br>

- 可以利用多线程，新开线程来构成一个新的游戏循环管理机制。
    不这么做的原因：
    在Unity中，主要的游戏逻辑通常在主线程上执行，而Unity的API不是线程安全的。
    这意味着如果您尝试在非主线程上直接调用Unity API，会导致报错，甚至会导致不稳定、崩溃或数据不一致。
    因此这种做法是不推荐的

***
# 三. 缓存池

## 3.1 主要作用
问题:
1. 对象的频繁创建
    频繁的实例化对象会带来一定的性能开销
2. 对象的频繁销毁
    对象的频繁销毁会造成大量的内存垃圾，会造成GC（垃圾回收）的频繁触发
    GC的触发，内存的释放，可能会带来卡顿感，影响玩家体验

解决方案就是缓存池

缓存池（对象池）的主要作用是优化资源管理，提高程序性能。
主要**通过重复利用已经创建的对象**，避免频繁的创建和销毁过程，
从而 减少 系统的内存分配 和 垃圾回收带来的开销。

## 3.2 基本原理

用一个“柜子”中的“各种抽屉”来装“东西”
用时去拿（没有就创造，存在就获取）
不用就还（将“东西”分门别类的放入“抽屉”中）

## 3.3 主要实现
1. 创建PoolMgr继承 不继承MonoBehaviour的单例模式基类
2. 声明柜子(Dictionary)和抽屉(List、Stack、Queue等)容器
3. 拿东西方法
   1. 有抽屉并且抽屉里有东西 直接获取
   2. 没有抽屉或者抽屉里没东西 创造
4. 放东西方法
   1. 有抽屉，直接放
   2. 没抽屉，创建抽屉，再放
5. 清空柜子方法
  我们在切场景时，对象都会被移除，这时应该清空柜子
  否则会出现内存泄漏，并且下次取东西会出问题


```CSharp
public class PoolMgr : SingletonBaseManager<PoolMgr>
{
    private PoolMgr() { }
    private Dictionary<string, Stack<GameObject>> poolDict;

    public GameObject GetObj(string path)
    {
        GameObject obj;
        if (poolDict.ContainsKey(path) && poolDict[path].Count > 0)
        {
            obj = poolDict[path].Pop();
            obj.SetActive(true);
        }
        else
        {
            obj = GameObject.Instantiate(Resources.Load<GameObject>(path));
            //将对象重命名, 因为默认创建会加上(clone), 这样不好管理
            obj.name = path;
        }
        return obj;
    }

    public void PushObj(GameObject obj)
    {
        //不是直接Destroy, 而是将其失活, 并把它放入到缓存池容器中
        obj.SetActive(false);
        
        if(!poolDict.ContainsKey(obj.name))
            poolDict.Add(obj.name, new Stack<GameObject>());
        poolDict[obj.name].Push(obj);
    }

    public void ClearPool()
    {
        poolDict.Clear();
    }
}
```
***
## 3.4 窗口布局优化
现在直接失活对象，当之后项目做大了，抽屉多了，对象多了
游戏中成百上千个对象，在开发测试时不方便从Hierarchy窗口中查看对象获取信息
因此我们希望能优化一下Hierarchy窗口中的布局
将对象和抽屉的关系可视化

### 3.4.1 制作思路和具体实现
我只写我相对于上面实例代码新增的部分

制作思路：
1. 柜子管理自己的柜子根物体
2. 抽屉管理自己的抽屉根物体
3. 失活时建立父子关系，激活活时断开父子关系

具体实现:
1. 先实现将所有对象放入柜子根物体中
```CSharp
public GameObject GetObj(string path)
{
    if (poolDict.ContainsKey(path) && poolDict[path].Count > 0)
    {
        //...
        obj.transform.SetParent(null);
    }
}

public void PushObj(GameObject obj)
{
    if (poolObj == null)
        poolObj = new GameObject("Pool");
    
    obj.SetActive(false);
    obj.transform.SetParent(poolObj.transform);
    //...
}
```
2. 再实现将对象放入对应的抽屉根物体中
   用面向对象的思想将抽屉相关数据行为封装起来
```CSharp
//代码修改很大, 主要是定义了PoolData这个新类
public class PoolData
{
    private Stack<GameObject> dataStack = new Stack<GameObject>();

    private GameObject rootObj;

    public int Count => dataStack.Count;

    public PoolData(GameObject poolObj, string name)
    {
        rootObj = new GameObject(name);
        rootObj.transform.SetParent(poolObj.transform);
    }

    public GameObject Pop()
    { 
        GameObject data = dataStack.Pop();
        data.transform.SetParent(null);
        data.SetActive(true);
        return data;
    }

    public void Push(GameObject data)
    {
        data.SetActive(false);
        data.transform.SetParent(rootObj.transform);
        dataStack.Push(data);
    }
}

public class PoolMgr : SingletonBaseManager<PoolMgr>
{
    public GameObject GetObj(string path)
    {
        GameObject obj;
        if (poolDict.ContainsKey(path) && poolDict[path].Count > 0)
        {
            obj = poolDict[path].Pop();
        }
        else
        {
            obj = GameObject.Instantiate(Resources.Load<GameObject>(path));
            obj.name = path;
        }
        return obj;
    }

    public void PushObj(GameObject obj)
    {
        if (poolObj == null)
            poolObj = new GameObject("Pool");
        
        if(!poolDict.ContainsKey(obj.name))
            poolDict.Add(obj.name, new PoolData(poolObj, obj.name));
        poolDict[obj.name].Push(obj);
    }

    public void ClearPool()
    { 
        poolDict.Clear();
        poolObj = null;
    }
}
```
3. 做成一个可控的开关来开启或关闭
   因为游戏里又看不到这些对象的父子关系, 而设置父子关系又会消耗性能
```CSharp
public class PoolData
{
    //...
    public PoolData(GameObject poolObj, string name)
    {
        if (PoolMgr.isOpenLayout)
        {
            rootObj = new GameObject(name);
            rootObj.transform.SetParent(poolObj.transform);
        }
    }

    public GameObject Pop()
    { 
        //...
        if (PoolMgr.isOpenLayout)
            data.transform.SetParent(null);
        //...
    }

    public void Push(GameObject data)
    {
        //...
        if (PoolMgr.isOpenLayout)
            data.transform.SetParent(rootObj.transform);
        //...
    }
}

public class PoolMgr : SingletonBaseManager<PoolMgr>
{
    //...
    public static bool isOpenLayout = true;

    //...
    public void PushObj(GameObject obj)
    {
        if (poolObj == null && isOpenLayout)
            poolObj = new GameObject("Pool");
        //...
    }
}
```
***
## 3.5 对象上限优化
目前制作的缓存池模块
理论上来说，当动态创建的对象长时间不放回抽屉
每次从缓存池中动态获取对象时，会不停的新建对象
那么也就是对象的数量是没有上限的
场景上的某种对象可以存在n个

而对象上限优化指的就是
我们希望控制对象数量有上限
对于不重要的资源我们没必要让其无限加量
而是将“使用最久”的资源直接抢来用

主要目的：
更加彻底的复用资源
对对象的数量上限加以限制
可以优化内存空间，甚至优化性能（减少数量上限，可以减小渲染压力）

### 3.5.1 制作思路和具体实现
制作思路：
1. 在抽屉里声明一个容器用来记录正在使用的资源
```CSharp
public class PoolData
{
    //...

    //使用中的对象的容器
    private List<GameObject> usedList = new List<GameObject>();

    public int UsedCount => usedList.Count;

    public void PushUsedList(GameObject usedObj)
    {
        usedList.Add(usedObj);
    }
}
```
2. 每次获取对象时，传入一个抽屉最大容量值（可以给一个默认值）
```CSharp
public GameObject GetObj(string path, int upLimit = 50)
```

3. 从缓存池中获取对象时就需要创建抽屉，用于记录当前使用的对象
4. 每次取对象时应该分情况考虑
    1. 没有抽屉时
    ```CSharp
    //这个方法直接重新写了
    public GameObject GetObj(string path, int upLimit = 50)
    {
        GameObject obj;

        //没有容器, 也就意味着该对象一次没有出现过
        //那就只能从默认的路径中去获取对象并创建
        if (!poolDict.ContainsKey(path))
        {
            obj = GameObject.Instantiate(Resources.Load<GameObject>(path));
            obj.name = path;
            
            poolDict.Add(path,new PoolData(path,poolObj, obj));
        }

        return obj;
    }
    ```
    2. 有抽屉，并且抽屉里有没用的对象或者使用中对象超过上限时
    ```CSharp
    public class PoolData
    {
        public GameObject Pop()
        {
            GameObject data;
            
            //有失活对象
            //那好说, 直接在池子里拿就行
            if (Count > 0)
                data = dataStack.Pop();
            //失活对象用完了(超上限)
            //那就直接从正在使用的对象容器中去取
            else
            {
                //要拿使用得最久的来用
                data = usedList[0];

                //把该元素移除,又重新加入, 那该元素自然在队尾了
                usedList.RemoveAt(0);
                usedList.Add(data);
            }
            
            //...
        }
    }

    public class PoolMgr : SingletonBaseManager<PoolMgr>
    {
        public GameObject GetObj(string path, int upLimit = 50)
        {
            //...

            //有容器, 容器里有失活对象或者超上限
            else if (poolDict[path].Count > 0 && poolDict[path].UsedCount >= upLimit)
            {
                obj = poolDict[path].Pop();
            }
        }
    }
    
    ```

    3. 有抽屉，但是抽屉里没有对象，使用中对象也没有超过上限时
    ```CSharp
    public GameObject GetObj(string path, int upLimit = 50)
    {
        //...

        //有容器, 但是容器里没失活对象, 也没超上限
        else
        {
            obj = GameObject.Instantiate(Resources.Load<GameObject>(path));
            obj.name = path;
            poolDict[path].PushUsedList(obj);
        }
    }
    ```

    你会发现其实情况1和情况3代码可以合并, 最终代码为
    ```CSharp
    public GameObject GetObj(string path, int upLimit = 50)
    {
        GameObject obj;
        //别忘了这里要进行判空
        //不然下面有一句代码会找不到poolObj
        //PushObj方法中的相同代码删掉也没关系
        if (poolObj == null && isOpenLayout)
            poolObj = new GameObject("Pool");

        if (!poolDict.ContainsKey(path) || 
            (poolDict[path].Count == 0 && poolDict[path].UsedCount <= upLimit))
        {
            obj = GameObject.Instantiate(Resources.Load<GameObject>(path));
            obj.name = path;
            
            if(!poolDict.ContainsKey(path))
                //就是这句, 会报错空引用
                poolDict.Add(path,new PoolData(path,poolObj, obj));
            else
                poolDict[path].PushUsedList(obj);
        }
        else 
        {
            obj = poolDict[path].Pop();
        }
        return obj;
    }
    ```

5. 每次放回对象时
  由于记录了正在使用的资源，因此每次放入抽屉时还需要从记录容器中移除对象
```CSharp
public class PoolData
{
    public void Push(GameObject data)
    {
        //...
        usedList.Remove(data);
    }
}
```

## 3.6 补充
现在这个代码的对象上限是我们手动传参设置的 (见上面的GetObj()方法) , 在协同开发中很不方便

1. 让使用者不用每次设置上限值
2. 初始化抽屉时，第一次就直接定好上限为多少，之后直接在内部判断即可

让缓存池对象挂载一个用于配置上限值的脚本
只需要在制作预设体时，将脚本挂好，设置好上限即可

- 新增脚本, 挂载到预设体上
```CSharp
public class PoolObj : MonoBehaviour
{
    public int maxNum;
}
```
- 修改代码
```CSharp
public class PoolData
{
    //容器上限 场景上同时存在的对象的上限个数
    private int maxNum;

    public bool NeedCreate => usedList.Count < maxNum;

    //和上面不同的是我把obj和poolObj这两个变量名换了
    public PoolData(string name,GameObject obj, GameObject usedObj)
    {
        //...

        PoolObj poolObj = usedObj.GetComponent<PoolObj>();
        if (obj == null)
        {
            Debug.LogError("请为使用缓存池功能的预设体对象挂载PoolObj脚本, 用于设置数量上限");
            return;
        }
        maxNum = poolObj.maxNum;
    }
}

public class PoolMgr : SingletonBaseManager<PoolMgr>
{
    public GameObject GetObj(string path)
    {
        //...

        if (!poolDict.ContainsKey(path) || 
            (poolDict[path].Count == 0 && poolDict[path].NeedCreate))
        {
            //...
        }
    }
}
```
***