[toc]

***
# 一. 3D数学
***
## 1. 数学计算公共类Mathf
***
### 1.1 Mathf和Math
- Math是C#中封装好的用于数学计算的工具类 —— 位于System命名空间中
- Mathf是Unity中封装好的用于数学计算的工具结构体 —— 位于UnityEngine命名空间中
- 他们都是提供来用于进行数学相关计算的
***
### 1.2 区别
Mathf 和 Math中的相关方法几乎一样
- Math 是C#自带的工具类 主要就提供一些数学相关计算方法
- Mathf 是Unity专门封装的，不仅包含Math中的方法，还多了一些适用于游戏开发的方法
- 所以我们在进行Unity游戏开发时, 使用Mathf中的方法用于数学计算即可
***
### 1.3 Mathf中的常用方法 -- 一次计算
**(1) π - PI**
```CSharp
print(Mathf.PI);
```
**(2)取绝对值 - Abs**
```CSharp
print(Mathf.Abs(-10));//10
print(Mathf.Abs(-20));//20
print(Mathf.Abs(1)); //1
```
**(3)向上取整 - CeilToInt**
```CSharp
float f = 1.3f;
int i = (int)f;
print(i);
print(Mathf.CeilToInt(f));
print(Mathf.CeilToInt(1.00001f));
```

**(4)向下取整 - FloorToInt**
```CSharp
print(Mathf.FloorToInt(9.6f));
```

**(5)钳制函数 - Clamp**
```CSharp
print(Mathf.Clamp(10, 11, 20));
print(Mathf.Clamp(21, 11, 20));
print(Mathf.Clamp(15, 11, 20));
```

**(6)获取最大值 - Max**
```CSharp
print(Mathf.Max(1, 2, 3, 4, 5, 6, 7, 8));
print(Mathf.Max(1, 2));
```

**(7)获取最小值 - Min**
```CSharp
print(Mathf.Min(1, 2, 3, 4, 545, 6, 1123, 123));
print(Mathf.Min(1.1f, 0.4f));
```

**(8)一个数的n次幂 - Pow**
```CSharp
print(Mathf.Min(1, 2, 3, 4, 545, 6, 1123, 123));
print(Mathf.Min(1.1f, 0.4f));
```

**(9)四舍五入 - RoundToInt**
```CSharp
print(Mathf.Min(1, 2, 3, 4, 545, 6, 1123, 123));
print(Mathf.Min(1.1f, 0.4f));
```

**(10)返回一个数的平方根 - Sqrt**
```CSharp
print("返回一个数的平方根" + Mathf.Sqrt(4));
print("返回一个数的平方根" + Mathf.Sqrt(16));
print("返回一个数的平方根" + Mathf.Sqrt(64));
```

**(11)判断一个数是否是2的n次方 - IsPowerOfTwo**
```CSharp
print("判断一个数是否是2的n次方" + Mathf.IsPowerOfTwo(4));
print("判断一个数是否是2的n次方" + Mathf.IsPowerOfTwo(8));
print("判断一个数是否是2的n次方" + Mathf.IsPowerOfTwo(3));
print("判断一个数是否是2的n次方" + Mathf.IsPowerOfTwo(1));
```

**(12)判断正负数 - Sign**
```CSharp
//返回的是1和-1
print("判断正负数" + Mathf.Sign(0));
print("判断正负数" + Mathf.Sign(10));
print("判断正负数" + Mathf.Sign(-10));
print("判断正负数" + Mathf.Sign(3));
print("判断正负数" + Mathf.Sign(-2));
```
***
### 1.4 Mathf中的常用方法 -- 循环计算
**(1)插值运算 - Lerp**
```CSharp
float start = 0;
float result = 0;
float time = 0;
//Lerp函数公式
result = Mathf.Lerp(start, end, t);

//t为插值系数，取值范围为 0~1
result = start + (end - start)*t
```

**(2)插值运算用法一**
每帧改变start的值——变化速度先快后慢，位置无限接近，但是不会得到end位置
```CSharp
start = Mathf.Lerp(start, 10, Time.deltaTime);
```

**(3)插值运算用法二**
每帧改变t的值——变化速度匀速，位置每帧接近，当t>=1时，得到结果
```CSharp
time += Time.deltaTime;
result = Mathf.Lerp(start, 10, time);
```
****
## 2. 三角函数
![alt text](/Unity/图片/Unity基础/Unity基础09-23_20-49-27.jpg)
***
### 2.1 弧度, 角度相互转化
- 弧度转角度
```CSharp
float rad = 1;
float anger = rad * Mathf.Red2Deg;
```
- 角度转弧度
```CSharp
float anger = 1;
float rad = anger * Mathf.Deg2rad;
```
***
### 2.2 三角函数
Mathf中的三角函数相关的方法, 传参需要用弧度值
```CSharp
print(Mathf.Sin(30 * Mathf.Deg2Rad));//0.5
print(Mathf.Cos(30 * Mathf.Deg2Rad));//0.5
```
***
### 2.3 反三角函数
反三角函数得到的结果是正弦或者余弦值对应的弧度
```CSharp
float rad = Mathf.Asin(0.5f);
print(rad * Rad2Deg);//30
```
****
## 3. 坐标系
***
### 3.1 世界坐标系
- 原点: 世界的中心点
- 三个轴向是固定的
```CSharp
//目前学习的和世界坐标系相关的
this.transform.position;
this.transform.rotation;
this.transform.eulerAngles;
this.transform.lossyScale;
```
***
### 3.2 局部坐标系
- 原点: 物体的中心点(建模时确定)
- 轴向: 右为+x, 上为+y, 前为+z
```CSharp
//相对父对象的物体坐标系的位置 本地坐标 相对坐标
this.transform.localPosition;
this.transform.localEulerAngles;
this.transform.localRotation;
this.transform.localScale;
```
***
### 3.3 屏幕坐标系
- 原点: 屏幕左下角
- 轴向: 右为+x, 上为+y
- 最大宽高: `Screen.width` / `Screen.height`
```CSharp
Input.mousePosition
Screen.width;
Screen.height;
```
***
### 3.4 视口坐标系
- 原点: 屏幕左下角
- 轴向: 右为+x, 上为+y
- 特点: 左下为(0,0), 右上为(1,1)
***
### 3.5 坐标转换
```CSharp
//世界转本地
this.transform.InverseTransformDirection
this.transform.InverseTransformPoint
this.transform.InverseTransformVector

//本地转世界
this.transform.TransformDirection
this.transform.TransformPoint  
this.transform.TransformVector

//世界转屏幕
Camera.main.WorldToScreenPoint
//屏幕转世界
Camera.main.ScreenToWorldPoint

//世界转视口
Camera.main.WorldToViewportPoint
//视口转世界
Camera.main.ViewportToWorldPoint

//视口转屏幕
Camera.main.ViewportToScreenPoint

//屏幕转视口
Camera.main.ScreenToViewportPoint;
```
***
## 4. 向量
***
### 4.1 向量
- 模长: `magnitude`
- 归一化: `normalized`

**补充**
调试画线
- 线段: `Debug.DrawLine();`,前两个参数, 起点和终点
- 射线: `Debug.DrawRay();`, 前两个参数, 起点和方向
***

### 4.2 向量点乘
```CSharp
Vector3.Dot(传入两个向量); //返回两个向量点乘的结果(float)
```
**几何意义**: 一个向量在自己向量上的投影长度
  - 点乘结果 > 0, 两个向量的夹角为锐角 
  - 点乘结果 = 0, 两个向量的夹角为直角 
  - 点乘结果 < 0, 两个向量的夹角为钝角

**计算向量A和向量B之间的夹角**
> β = Acos(单位向量A · 单位向量B)

- β: A与B之间的夹角
- Acos: 反余弦函数

现成的API: `Vector.Angle();`
***
### 4.3 向量的叉乘
```CSharp
Vector3.Cross(传入两个向量); 
```
**几何意义**: 得到的向量同时垂直于A和B所在平面, 这个向量就叫**法向量**
- 若向量A和向量B处于xz平面上
  - y > 0, B在A的右侧
  - y < 0, B在A的左侧
***
### 4.4 插值
#### 线性插值
```CSharp
Vector3.Lerp(start,end,t);
```
- 先快后慢: 每帧改变start值
- 匀速运动: 每帧改变t的值

#### 球形插值
```CSharp
Vector3.Slerp();
```
***
## 5. 四元数
***
### 5.1 为什么要用四元数
#### (1) 欧拉角
- **同一旋转表示不唯一**
  例如: (0, 90, 0) 和 (0, 450, 0)的旋转效果是一样的 
- **万向节死锁**
  当某个特定轴达到某个特殊值时, 绕一个轴转可能会覆盖主另一个轴的旋转, 从而失去一维的自由度
  在unity中欧拉角的优先级是`y-x-z`,所以当x为90时,y和z就处于一个平面, 便形成了万向锁, 也就是说优先级在中间的轴向就是形成万向节死锁的原因

#### (2) Quaternion
- 四元数Q = [cos(β/2),  sin(β/2)x, sin(β/2)y, sin(β/2)z]
```CSharp
Quaternion q = new Quaternion(Mathf.Sin(30 * Mathf.Deg2Rad), 0, 0, Mathf.Cos(30 * Mathf.Deg2Rad));
```
- 提供的轴角对 初始化 四元数的方法
```CSharp
Quaternion q = Quaternion.AngleAxis(60, Vector3.right);
```

#### (3) 四元数和欧拉角的互转
1. 欧拉角转四元数
```CSharp
Quaternion q2 = Quaternion.Euler(60, 0, 0);
```
2. 四元数转欧拉角
```CSharp
print(q2.eulerAngles);
```
#### 补充: 四元数相乘代表旋转四元数
```CSharp
//注意: 这里传入的轴是世界坐标的向上轴
this.transform.rotation *= Quaternion.AngleAxis(1, Vector3.up);
```
***
### 5.2 四元数常用方法
#### (1) 单位四元数
单位四元数表示没有旋转量(角位移), 当角度为 0 或者 360 度时, 对于给定轴都会得到单位四元数
```CSharp
Quaternion.identity;
```

#### (2) 插值运算
`Quaternion`也提供了`Lerp`和`Slerp`,
和`Vector3`不同的是,`Quaternion`中的`Lerp`的效果相比`Slerp`更快,但是旋转范围较大效果较差, 所以建议使用`Slerp`
```CSharp
Quaternion.Slerp();
```

#### (3) 向量指向转四元数
`LookRotation`方法可以将传入的面朝向量转换为对应的四元数角度信息
```CSharp
Quaternion.LookRotation(面朝向量);
```
例: 当人物面朝向想要改变时, 只需要把目标面朝向传入该函数, 便可以得到目标四元数角度信息, 之后将人物四元数角度信息改为得到的信息即可达到转向
***
### 5.3 四元数的计算
#### (1) 四元数相乘

- 两个四元数相乘得到一个新的四元数
- 代表两个旋转量的叠加, 相当于旋转
- 注意: 旋转相对的坐标系, 是物体自身坐标系
```CSharp
Quaternion q = Quaternion.AngleAxis(20, Vector3.up);
this.transform.rotation *= q;
```

#### (2) 四元数乘向量
- 四元数乘向量返回一个新的向量
- 可以将指定向量旋转对应四元数的旋转量, 相当于旋转向量
- 注意: 四元数乘向量一定是四元数在前向量在后的, 不能改变相乘的顺序

***
# 二. MonoBehaviour中的重要内容
***

## 6. 延时/延迟函数
就是会延时执行的函数, 我们可以自己设定延时要执行的函数和具体延时的时间
是MonoBehaviour基类中实现好的方法
***
### 6.1 延时函数的使用
#### ① 延时函数
```CSharp
//参数一：函数名 字符串
//参数二：延迟时间 秒为单位
Invoke("DelayDoSomething", 5);//过5秒后执行DelayDoSomething方法
private void DelayDoSomething()
{
  print("延时执行的函数");
}
```
- 延时函数第一个参数传入的是函数名字符串
- 延时函数没办法传入参数 只有包裹一层
- 函数名必须是该脚本上申明的函数

#### ② 延时重复执行函数
```CSharp
//参数一：函数名字符串
//参数二：第一次执行的延迟时间
//参数三：之后每次执行的间隔时间
InvokeRepeating("DelayDoSomething", 5, 1);//第一次等5s开始执行, 然后每间隔1秒执行一次
```

#### ③ 取消延时函数
- 取消该脚本上的所有延时函数执行
```CSharp
CancelInvoke();
```
- 指定函数名取消
  只要取消了指定延迟 不管之前该函数开启了多少次 延迟执行 都会统一取消
```CSharp
CancelInvoke("DelayDoSomething");
```
#### ④ 判断是否有延时函数
```CSharp
if( IsInvoking("DelayDoSomething") ){ }
```
***
### 6.2 延迟函数受对象失活销毁影响
1. 脚本依附对象失活 或者 脚本自己失活
延迟函数可以继续执行 不会受到影响的
</br>

2. 脚本依附对象销毁或者脚本移除
延迟函数无法继续执行

所以如果想让延时函数在激活时调用, 在失活时停止, 可以配合`OnEnable`和`OnDisable`使用
```CSharp
private void OnEnable()
{
    //对象激活 的生命周期函数中 开启延迟（重复执行的延迟）
}

private void OnDisable()
{
    //对象失活 的生命周期函数中 停止延迟
}
```
***

## 7. 协同程序
***
### 7.1 unity是否支持多线程
unity是支持多线程的
只是新开的线程无法访问unity相关对象的内容

注意: Unity中的多线程 要记住关闭

```CSharp
using System.Threading;

Thread t;

void Start()
{
  t = new Thread(Test);

  //开启线程
  t.Start();
}

//这段的意思是暂停1s, 打印1次123
private void Test() 
{
  while(true)
  {
    Thread.Sleep(1000);
    print("123");
  }
}
```

以上代码你运行时是正常的, 当你停止运行后你会发现, 它还在打印, 甚至你把这个脚本Remove后都还会打印, 所以需要手动去关闭

```CSharp
private void OnDestroy()
{
    t.Abort();
    t = null;
}
```

**那既然不能访问unity相关的对象,开启多线程又有什么意义呢?**

对于多个线程来说, 它们都可以访问同一内存区域, 那么我们可以另开一个线程去计算一些复杂逻辑, 比如A*,网络等, 然后把计算的结果放到指定内存, 处于unity中的主线程只要去查看该内存中有没有东西就行了, 有就拿来用 

```CSharp

Thread t;

//这里的队列就是两个线程的公共容器
private Queue<Vector3> queue = new Queue<Vector3>();

void Start()
{
  t = new Thread(Test);

  //开启线程
  t.Start();
}

void Update()
{
  //然后在unity中只看容器中有没有东西, 有就拿来用
  if( queue.Count > 0 )
  {
    this.transform.position = queue.Dequeue();
  }
}

private void Test()
{
  while(true)
  {
    Thread.Sleep(1000);
    //相当于模拟 复杂算法 算出了一个结果 然后放入公共容器中
    
    //一些巨复杂的运算...
    System.Random r = new System.Random();
    Vector3 vec = new Vector3(r.Next(-10, 10), r.Next(-10, 10), r.Next(-10, 10));
    
    //然后把结果压入队列
    queue.Enqueue(vec);
  }
}
```
**那又有一个问题, 我能理解Test()里用的都是C#里的东西, 可Vector3不是啊? 它是UnityEngine命名空间下的, 为什么它可以用?**

简单来说：Vector3 可以在子线程中使用，因为它只是一个普通的 C# 数据结构（结构体），而不是 Unity 的 “引擎对象”。

**核心区别：“数据容器” vs “引擎对象”**
- Vector3、Color、Mathf 这类属于 “数据容器 / 工具类”：
  - 它们只存储数据（如 x/y/z 值）或提供纯数学计算（如三角函数），不涉及 Unity 引擎的内部状态（比如场景中的物体、渲染管线、物理引擎等）。
  - 就像你自己定义的 public struct MyVector { public float x; public float y; } 一样，创建和修改它们只是在操作内存中的数值，完全不依赖 Unity 主线程的管理。
  </br>

- MonoBehaviour、Transform、Rigidbody 这类属于 “引擎对象”：
  - 它们是 Unity 引擎在内存中维护的 “活对象”，关联着场景数据、渲染状态、物理碰撞等核心逻辑。这些对象的创建、修改、销毁必须由主线程统一处理（否则会导致数据混乱）。
  - 比如 transform.position 看似是修改一个坐标，实际会触发引擎的渲染更新、碰撞体位置同步等一系列内部操作，这些都必须在主线程完成。

**总结规则**
- 判断一个 Unity 类能否在子线程中使用，最简单的标准是：
  - 如果它只是 “装数据的盒子” 或 “纯计算工具”（如 Vector3、Quaternion、Color、Mathf）：可以在子线程中使用。
  - 如果它关联着场景中的实体、渲染、物理等引擎状态（如 GameObject、Component、Camera、Light）：绝对不能在子线程中直接操作。

***
### 7.2 什么是协同程序
[协程的具体描述看我这个文件的第4点](/面试/八股,Lua,unity/八股/Unity.md)

它是"假"的多线程
主要作用:
- 将代码分时执行，不卡主线程
- 简单理解，是把可能会让主线程卡顿的耗时的逻辑分时分步执行

主要使用场景:
- 异步加载文件
- 异步下载文件
- 场景异步加载
- 批量创建时防止卡顿

***
### 7.3 协程和线程的区别
- 新开一个线程是独立的一个管道，和主线程并行执行
- 新开一个协程是在原线程之上开启，进行逻辑分时分步执行
***
### 7.4 协程的使用
IEnumerator和yield return在C#高阶的第10条中有提到过

继承MonoBehavior的类 都可以开启 协程函数

关键点一： 协同程序（协程）函数 返回值 **必须是 IEnumerator 或者继承它的类型** 
关键点二： 协程函数当中 **必须使用 yield return 进行返回**

第一步：声明协程函数
  - 返回值为 `IEnumerator` 类型及其子类
  - 函数中通过 `yield return` 返回值; 进行返回

第二步：开启协程函数
  - 直接调用没有任何效果
  - 常用开启方式
```CSharp
IEnumerator ie = MyCoroutine(1, "123");

StartCoroutine(ie);

Coroutine c1 = StartCoroutine( MyCoroutine(1, "123"));

IEnumerator MyCoroutine(int i, string str)
{
  yield return new WaitForSeconds(1f);
}

```
第三步：关闭协程
  - 关闭所有协程
  ```CSharp
  StopAllCoroutines();
  ```

  - 关闭指定协程
  ```CSharp
  StopCoroutine(c1);
  ```
***
### 7.5 yield return 不同内容的含义
1. 下一帧执行
```CSharp
yield return 数字;
yield return null;
//在Update和LateUpdate之间执行
```

2. 等待指定秒后执行
```CSharp
yield return new WaitForSeconds(秒);
//在Update和LateUpdate之间执行
```

3. 等待下一个固定物理帧更新时执行
```CSharp
yield return new WaitForFixedUpdate();
//在FixedUpdate和碰撞检测相关函数之后执行
```

4. 等待摄像机和GUI渲染完成后执行
```CSharp
yield return new WaitForEndOfFrame();
//在LateUpdate之后的渲染相关处理完毕后之后
```

5. 一些特殊类型的对象 比如异步加载相关函数返回的对象
  - 在 异步加载资源 异步加载场景 网络加载时再说
  一般在Update和LateUpdate之间执行

6. 跳出协程
```CSharp
yield break;
```
***
### 7.6 协程受对象和组件失活销毁的影响
协程开启后
- 组件和物体销毁，协程不执行
- 物体失活协程不执行，组件失活协程执行
***
## 8. 协程的原理
***
### 8.1 协程的本质
协程可以分成两部分
- 协程函数本体
- 协程调度器

协程本体就是一个能够中间暂停返回的函数
协程调度器是Unity内部实现的，会在对应的时机帮助我们继续执行协程函数

Unity只实现了协程调度部分
协程的本体本质上就是一个 C#的迭代器方法
***
### 8.2 协程本体是迭代器方法的体现
#### (1)协程函数本体
   - 如果我们不通过 开启协程方法执行协程 
   - Unity的协程调度器是不会帮助我们管理协程函数的
   - 但是我们可以自己执行迭代器函数内容
      - `MoveNext` 会执行函数中内容遇到 yield return为止的逻辑
      - `Current` 得到 yield return 返回的内容
```CSharp
IEnumerator Test()
{
    print("第一次执行");
    yield return 1;
    print("第二次执行");
    yield return 2;
    print("第三次执行");
    yield return "123";
    print("第四次执行");
    yield return new TestClass(10);
}

void Start()
{
    IEnumerator ie = Test();
    ie.MoveNext();//输出 第一次执行
    print(ie.Current);//输出 1
}
```
   - MoveNext返回的是一个bool值, 代表是否到达结尾, 到达为false, 所以也可以像这么写
```CSharp
//一次性执行完所有的协程函数代码
while(ie.MoveNext())
{
    print(ie.Current);
}
```
#### (2) 协程调度器
继承MonoBehavior后 开启协程
相当于是把一个协程函数（迭代器）放入Unity的协程调度器中帮助我们管理进行执行
具体的yield return 后面的规则 也是Unity定义的一些规则
***
# 三. Resources资源动态加载
***
## 9. Unity中的特殊文件夹
***
### 9.1 工程路径获取
注意: 该方式 获取到的路径 一般情况下 只在 **编辑模式** 下使用
我们不会在实际发布游戏后 还使用该路径, 游戏发布过后 该路径就不存在了 
```CSharp
print(Application.dataPath);//输出你的项目的Assets文件夹路径
```
***
### 9.2 Resources 资源文件夹
- 需要自己创建
- 一般不获取, 只能使用Resources相关API进行加载
- 如果硬要获取该路径 可以用工程路径拼接
```CSharp
print(Application.dataPath + "/Resources");
```

- 作用：
  - 资源文件夹
  - 需要通过Resources相关API动态加载的资源需要放在其中
  - 该文件夹下所有文件都会被打包出去
  - 打包时Unity会对其压缩加密
  - 该文件夹打包后只读 只能通过Resources相关API加载
***
### 9.3 StreamingAssets 流动资源文件夹
- 需要自己创建

- 路径获取：
```CSharp
print(Application.streamingAssetsPath);

//当你打包后,在不同平台下streamingAssetsPath都是不一样的
//所以不能像上面的Resources文件夹那样拼接路径
```
- 作用：
  - 流文件夹
  - 打包出去不会被压缩加密，可以任由我们摆布
  - 移动平台只读，PC平台可读可写
  - 可以放入一些需要自定义动态加载的初始资源
***
### 9.4 persistentDataPath 持久数据文件夹
- 不需要自己创建, 不同平台路径不同
- 路径获取：
```CSharp
print(Application.persistentDataPath);
//这是我输出的结果 C:/Users/asus/AppData/LocalLow/DefaultCompany/Unity Basics
```

- 作用：
  - 固定数据文件夹
  - 所有平台都可读可写
  - 一般用于放置动态下载或者动态创建的文件，游戏中创建或者获取的文件都放在其中
***
### 9.5 Plugins 插件文件夹
- 需要自己创建

- 路径获取：
  - 一般不获取
</br>

- 作用：
  - 插件文件夹
  - 不同平台的插件相关文件放在其中
  - 比如IOS和Android平台
***
### 9.6 Editor 编辑器文件夹
- 需要自己创建
- 路径获取：
  - 一般不获取
- 如果硬要获取 可以用工程路径拼接
```CSharp
print(Application.dataPath + "/Editor");
```
- 作用：
  - 编辑器文件夹
  - 开发Unity编辑器时，编辑器相关脚本放在该文件夹中
  - 该文件夹中内容不会被打包出去
***
### 9.7 Standard Assets 默认资源文件夹 
- 需要自己创建
- 路劲过去：
  - 一般不获取
</br>

- 作用：
  - 默认资源文件夹
  - 一般Unity自带资源都放在这个文件夹下
  - 代码和资源优先被编译
***
## 10. Resources同步加载
***
### 10.1 Resources资源动态加载的作用
- 通过代码动态加载Resources文件夹下指定路径资源
- 避免繁琐的拖曳操作
***
### 10.2 常用资源类型
1. 预设体对象 ——`GameObject`
2. 音效文件 —— `AudioClip`
3. 文本文件 —— `TextAsset`
4. 图片文件 —— `Texture`
5. 其它类型 —— 需要什么用什么类型

***
### 10.3 资源同步加载 普通方法
在一个工程当中 Resources 文件夹 可以有多个通过API加载时 它会自己去这些同名的 Resources 文件夹中去找资源
打包时 Resources 文件夹里的内容都会打包在一起

#### (1) 预设体对象
第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中)
```CSharp
Object obj = Resources.Load("Cube");
```
第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化
```CSharp
Instantiate(obj);
```
#### (2) 音效资源
第一步：加载数据
```CSharp
Object obj3 = Resources.Load("Music/BKMusic");
```
第二步：使用数据 我们不需要实例化 音效切片 我们只需要把数据 赋值到正确的脚本上即可
```CSharp
audioS.clip = obj3 as AudioClip;
audioS.Play();
```

#### (3) 文本资源
文本资源支持的格式
.txt, .xml, .bytes, .json, .html, .csv.....
```CSharp
TextAsset ta = Resources.Load("Txt/Test") as TextAsset;
//得到其中文本内容
print(ta.text);
//得到其中字节数据组
print(ta.bytes);
```

#### (4) 图片
```CSharp
tex = Resources.Load("Tex/TestJPG") as Texture;
```

#### (5) 另外的API
Resources.Load加载同名资源时 无法准确加载出你想要的内容
- 加载指定类型的资源
```CSharp
tex = Resources.Load("Tex/TestJPG", typeof(Texture)) as Texture;
```
- 加载指定名字的所有资源
```CSharp
Object[] objs = Resources.LoadAll("Tex/TestJPG");
foreach (Object item in objs)
{
    if (item is Texture) { }
    else if(item is TextAsset){ }
}
```
*** 
### 10.4 资源同步加载 泛型方法
```CSharp
TextAsset ta2 = Resources.Load<TextAsset>("Tex/TestJPG");
```
***
## 11. Resources异步加载
***
### 11.1 概念
使用同步加载时, 如果我们加载过大的资源可能会造成程序卡顿
卡顿的原因就是 从硬盘上把数据读取到内存中 是需要进行计算的
越大的资源耗时越长，就会造成掉帧卡顿

Resources异步加载 就是内部新开一个线程进行资源加载 不会造成主线程卡顿

*** 
### 11.2 Resources异步加载方法
异步加载 不能马上得到加载的资源 至少要等一帧

#### (1) 通过异步加载中的完成事件监听 使用加载的资源
```CSharp
//这句代码 可以理解 Unity 在内部 就会去开一个线程进行资源下载
//ResourceRequest 继承于 AsyncOperation
ResourceRequest rq = Resources.LoadAsync<Texture>("Tex/TestJPG");

//completed 是 AsyncOperation 类内部封装的事件, 当加载结束后会立即调用该事件
// 此时我们再对这个事件再加上一个函数进行处理
rq.completed += LoadOver;

private void LoadOver( AsyncOperation rq)
{
    print("加载结束");
}
```

通过以上代码加载完资源后, 我们需要使用该资源
```CSharp
private Texture tex;

private void LoadOver( AsyncOperation rq)
{
    print("加载结束");
    //asset 是资源对象 加载完毕过后 就能够得到它
    tex = (rq as ResourceRequest).asset as Texture;
    print(Time.frameCount);
}

private void OnGUI()
{
    //一定要判空, 因为异步加载不会立即获得资源
    if( tex != null)
        GUI.DrawTexture(new Rect(0, 0, 100, 100), tex);
}
```

#### (2) 通过协程 使用加载的资源
- `ResourceRequest` 往上找他的父类,会发现它继承于 `YieldInstruction`
- 而 `WaitForSeconds` 也是继承于 `YieldInstruction`
- 所以 `ResourceRequest` 本质上也是一个迭代器, `yield return ResourceRequest`是没有问题的
```CSharp
IEnumerator Load()
{
    //迭代器函数 当遇到yield return时  就会 停止执行之后的代码
    //然后 协程协调器 通过得到 返回的值 去判断 下一次执行后面的步骤 将会是何时
    ResourceRequest rq = Resources.LoadAsync<Texture>("Tex/TestJPG");

    //这里unity会清楚你在异步加载, 就会等待该资源加载完毕
    yield return rq;
}
```

我们其实可以通过另一种方式去判断资源是否加载完毕, 转到 `AsyncOperation` 的定义你会发现有一个 `IsDone` 属性, 它就可以来判断该资源是否加载完毕
```CSharp
IEnumerator Load()
{
    ResourceRequest rq = Resources.LoadAsync<Texture>("Tex/TestJPG");

    //判断资源是否加载结束
    while(!rq.isDone)
    {
        //打印当前的 加载进度 
        //该进度 不会特别准确 过渡也不是特别明显
        print(rq.priority);
        yield return null;
    }
    tex = rq.asset as Texture;
}
```

#### (3) 两种方法的优缺点
1. completed事件监听异步加载
     - 好处：写法简单
     - 坏处：只能在资源加载结束后 进行处理
     - “线性加载”
</br>

2. 协程异步加载
     - 好处：可以在协程中处理复杂逻辑，比如同时加载多个资源，比如进度条更新
     - 坏处：写法稍麻烦
     - “并行加载”

*** 
## 12. Resources资源卸载
***
### 12.1 Resources重复加载资源
- 其实Resources加载一次资源过后, 该资源就一直存放在内存中作为缓存
- 第二次加载时发现缓存中存在该资源, 会直接取出来进行使用
- 所以 多次重复加载不会浪费内存, 但是 会浪费性能（每次加载都会去查找取出，始终伴随一些性能消耗）

*** 
### 12.2 如何手动释放掉缓存中的资源

#### (1) 卸载指定资源
```CSharp
Resources.UnloadAsset()
```
注意：
- 该方法 不能释放 GameObject对象 因为它会用于实例化对象
- 它只能用于一些 不需要实例化的内容 比如 图片 和 音效 文本等等
- 一般情况下 我们很少单独使用它
#### (2) 卸载未使用的资源
一般在过场景时和GC一起使用
```CSharp
Resources.UnloadUnusedAssets();
GC.Collect();
```

#### 补充: Unity中的调试窗口快捷键: Ctrl + 7
***
# 四. 场景异步切换
***
## 13. LoadSceneAsync
***
### 13.1 场景同步切换
[在unity入门中的24条](/Unity/入门.md)
```CSharp
using UnityEngine.SceneManagement;

SceneManager.LoadScene("场景名");
```
**场景同步切换的缺点**

- 在切换场景时, **Unity会删除当前场景上所有对象**, 并且去加载下一个场景的相关信息
- 如果当前场景 对象过多或者下一个场景对象过多, 这个过程会非常的耗时 会让玩家感受到卡顿

***
### 13.2 场景异步切换
#### (1) 通过事件回调函数 异步加载
```CSharp
AsyncOperation ao = SceneManager.LoadSceneAsync("场景名");

//加载完后的逻辑处理
ao.completed += (a) =>
{
    print("加载结束");
};
```

#### (2) 通过协程异步加载
需要注意的是 加载场景会把当前场景上 没有特别处理的对象 都删除了
所以 协程中的部分逻辑 可能是执行不了的 

```CSharp
void Start()
{
   StartCoroutine(LoadScene("场景名"));
}

IEnumerator LoadScene(string name)
{
    AsyncOperation ao = SceneManager.LoadSceneAsync(name);

    //我们就可以在这个位置塞逻辑
    //比如在异步加载过程中 去更新进度条

    //第一种 就是利用 场景异步加载 的进度 去更新进度条, 但是 不是特别准确 一般也不会直接用

    //第二种 就是根据你游戏的规则 自己定义 进度条变化的条件
    //场景加载结束 更新20%进度
    //接着去加载场景中 的其它信息
    //比如 动态加载怪物
    //这时 进度条 再更新20%
    //动态加载 场景模型
    //这时 就认为 加载结束了 进度条顶满 
    //隐藏进度条

    print("异步加载过程中 打印的信息");

    yield return ao;

    print("异步加载结束后 打印的信息");
}
```
解决思路
- 让处理场景加载的脚本依附的对象 过场景时 不被移除

```CSharp
void Start()
{
    //该脚本依附的对象 过场景时 不会被 移除
    DontDestroyOnLoad(this.gameObject);

    StartCoroutine(LoadScene("场景名"));
}

```

#### (3) 分析
先回顾一下, unity在切场景的时候会删除场景里的所有对象, 然后再加载下一个场景

##### 第一个问题

第一种方法--通过事件回调函数, 是用unity自带的事件去保存了你要执行的加载完后的逻辑处理, 但是你想想, 你都执行`completed`这个事件了, 那不就意味着下一个场景加载好了吗? 那不就是把你这个场景里的对象都删完了吗? 那为什么还能执行呢这个函数? 

**解答**: `completed`事件中相当于你把你要处理的逻辑的函数的引用存了进去,然后需要搞清楚一件事, 在场景里把对象删除了不代表把它的内存也一同清了, 清理内存是GC该做的事, 你想要执行的函数被事件引用着, GC是不会去清理它的, 因为它还在被占用着

##### 第二个问题

第二种方法--通过协程异步加载, 当你运行上面的示例代码时, 你会发现只输出了"异步加载过程中 打印的信息" ,这是因为协程所在的脚本对象被场景切换删除了，导致协程 “断更”。

具体拆解：
- 协程 LoadScene 是挂载在 “当前场景的某个 GameObject” 上的脚本启动的
- 当执行 SceneManager.LoadSceneAsync(name) 时，Unity 会在加载完成后删除当前场景的所有对象
- 脚本对象被删除 → 依附于它的协程也会被强制终止，所以 yield return ao; 之后的代码（打印 “加载结束”）永远没机会执行。

***
# 五. 画线功能Linerenderer

***
## 14. Linerenderer
***
### 14.1 LineRenderer是什么
LineRenderer是Unity提供的一个用于画线的组件, 使用它我们可以在场景中绘制线段

一般可以用于
- 绘制攻击范围
- 武器红外线
- 辅助功能
- 其它画线功能
***
### 14.2 相关参数
![alt text](/Unity/图片/Unity基础/Unity基础09-27_20-07-08.jpg)
![alt text](/Unity/图片/Unity基础/Unity基础09-27_20-14-58.jpg)
![alt text](/Unity/图片/Unity基础/Unity基础09-27_20-17-38.jpg)
![alt text](/Unity/图片/Unity基础/Unity基础09-27_20-22-02.jpg)
![alt text](/Unity/图片/Unity基础/Unity基础09-27_20-23-26.jpg)

*** 
### 14.3 相关代码
1. **动态添加一个线段**
```CSharp
GameObject line = new GameObject();
line.name = "Line";
LineRenderer lineRenderer = line.AddComponent<LineRenderer>();
```

2. **首尾相连**
```CSharp
lineRenderer.loop = true;
```

3. **开始结束宽**
```CSharp
lineRenderer.startWidth = 0.02f;
lineRenderer.endWidth = 0.02f;
```
4. **开始结束颜色**
```CSharp
lineRenderer.startColor = Color.white;
lineRenderer.endColor = Color.red;
```

5. **设置材质**
```CSharp
private Material m;

m = Resources.Load<Material>("M");
lineRenderer.material = m;
```
6. **设置点**
- 一定注意 设置点 要 先设置点的个数
```CSharp
lineRenderer.positionCount = 4;
```
- 接着就设置 对应每个点的位置
```CSharp
lineRenderer.SetPositions(new Vector3[] { new Vector3(0,0,0),
                                          new Vector3(0,0,5),
                                          new Vector3(5,0,5)});
lineRenderer.SetPosition(3, new Vector3(5, 0, 0));
```

7. **是否使用世界坐标系**
- 决定了 是否随对象移动而移动
```CSharp
lineRenderer.useWorldSpace = false;
```

8. **让线段受光影响 会接受光数据 进行着色器计算**
```CSharp
lineRenderer.generateLightingData = true;
```
***
# 六. 核心系统
***
## 15. 范围检测
***
### 15.1 什么是范围检测
[就拿黑环来举例子](https://www.bilibili.com/video/BV1ZeemzPETM/?spm_id_from=333.337.search-card.all.click&vd_source=e5ff09f1c2b416e099232ca31ec5028d), 这里只是为了快速理解, 而范围检测和hitbox可不一样, 范围检测是一瞬的, 而hitbox是有延续时间的, 但是它们的作用是差不多的

游戏中瞬时的攻击范围判断一般会使用范围检测

举例：
   1. 玩家在前方5m处释放一个地刺魔法，在此处范围内的对象将受到地刺伤害
   2. 玩家攻击，在前方1米圆形范围内对象都受到伤害

类似这种并没有实体物体 只想要检测在指定某一范围是否让敌方受到伤害时 便可以使用范围判断

简而言之
在指定位置 进行 范围判断 我们可以得到处于指定范围内的 对象
目的是对 对象进行处理, 比如 受伤 减血等等


***
### 15.2 如何进行范围检测
必备条件：想要被范围检测到的对象 **必须具备碰撞器**
注意点：
  1. 范围检测相关API 只有当执行该句代码时 进行一次范围检测 它是瞬时的
  2. 范围检测相关API 并不会真正产生一个碰撞器 只是碰撞判断计算而已

#### 范围检测API
##### 1.盒状范围检测
**`Physics.OverlapBox`**
- 参数一：立方体中心点
- 参数二：立方体三边大小
- 参数三：立方体角度
- 参数四：检测指定层级（不填检测所有层）
- 参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal
- 返回值：在该范围内的触发器（得到了对象触发器就可以得到对象的所有信息）

```CSharp
Collider[] colliders = Physics.OverlapBox( Vector3.zero, Vector3.one, Quaternion.AngleAxis(45, Vector3.up), 
                    1 << LayerMask.NameToLayer("UI") | 1 << LayerMask.NameToLayer("Default"), 
                    QueryTriggerInteraction.UseGlobal);
```

这里不是特殊的写法, 而是位运算, `LayerMask.NameToLayer("UI")`的结果是5, 而`1 << LayerMask.NameToLayer("UI")`意为1左移5位

[相关题目](https://www.zhihu.com/question/19676641/answer/12613290)
讲到这里, 算法刷得多的就知道是怎么回事了, unity有32个层级, 而每一层用 `0` 和 `1` 就可以代表是否调用的两种状态

看到32位, 基础好的就又知道是怎么回事了, int表示的位数正好也是32位(1位是符号位), 也就是说一个int 就可以表示所有想要检测的层级信息以及可以表示多个层级被调用的情况

**全局设置**
> Edit -> project settings -> Physics -> Queries Hit Triggers

**另一种API**

**`Physics.OverlapBoxNonAlloc`**

- 返回值：碰撞到的碰撞器数量
- 参数：传入一个数组进行存储
```CSharp
if(Physics.OverlapBoxNonAlloc(Vector3.zero, Vector3.one, colliders) != 0) { }
```
##### 2. 球形范围检测

**`Physics.OverlapSphere`**

- 参数一：中心点
- 参数二：球半径
- 参数三：检测指定层级（不填检测所有层）
- 参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal
- 返回值：在该范围内的触发器（得到了对象触发器就可以得到对象的所有信息）
```CSharp
colliders = Physics.OverlapSphere(Vector3.zero, 5, 
          1 << LayerMask.NameToLayer("Default"));
```

**另一个API**

**`Physics.OverlapSphereNonAlloc`**

- 返回值：碰撞到的碰撞器数量
- 参数：传入一个数组进行存储

##### 3. 胶囊范围检测

**`Physics.OverlapCapsule`**

- 参数一：半圆一中心点
- 参数二：半圆二中心点
- 参数三：半圆半径
- 参数四：检测指定层级（不填检测所有层）
- 参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal
- 返回值：在该范围内的触发器（得到了对象触发器就可以得到对象的所有信息）

```CSharp
colliders = Physics.OverlapCapsule(Vector3.zero, 
            Vector3.up, 1, 
            1 << LayerMask.NameToLayer("UI"), 
            QueryTriggerInteraction.UseGlobal);
```

胶囊体相比于立方体来说API中没有角度是因为:
确定了两个半圆的中心, 就确定了这个胶囊体的角度

**另一个API**

**`Physics.OverlapSphereNonAlloc`**

- 返回值：碰撞到的碰撞器数量
- 参数：传入一个数组进行存储
***
## 16. 射线检测
***
### 16.1 概念
**回顾:** 
- 碰撞检测的必要条件: 两个物体都需要有碰撞器, 其中一个必须有刚体
- 范围检测的必要条件: 碰撞器
</br>

#### (1) 3D世界中的射线
假设有一条, 起点为坐标(1,0,0) ,方向为世界坐标Z轴正方向的射线

- 参数一：起点
- 参数二：方向（一定记住 不是两点决定射线方向，第二个参数 直接就代表方向向量）

```CSharp
Ray r = new Ray(Vector3.right, Vector3.forward);
```

#### (2) 摄像机发射出的射线
得到一条从屏幕位置作为起点, 摄像机视口方向为 方向的射线
```CSharp
Ray r2 = Camera.main.ScreenPointToRay(Input.mousePosition);
```

单独的射线对于我们来说没有实际的意义, 我们需要用它结合物理系统进行射线碰撞判断

***
### 16.2 碰撞检测函数
射线检测也是瞬时的, 执行代码时进行一次射线检测

#### (1) 最原始的射线检测

**`Physics.Raycast`**

进行射线检测 如果碰撞到对象 返回true
- 参数一：射线
- 参数二: 检测的最大距离 超出这个距离不检测
- 参数三：检测指定层级（不填检测所有层）
- 参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal
- 返回值：bool 当碰撞到对象时 返回 true 没有 返回false
```CSharp
Ray r3 = new Ray(Vector3.zero, Vector3.forward);

if (Physics.Raycast(r3, 
                    1000, 
                    1 << LayerMask.NameToLayer("Test"), 
                    QueryTriggerInteraction.UseGlobal)) { }
```

- 还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断
- 就是把 第一个参数射线 变成了 射线的 两个点 一个起点 一个方向

```CSharp
if (Physics.Raycast(Vector3.zero, 
                    Vector3.forward, 
                    1000, 
                    1 << LayerMask.NameToLayer("Test"), 
                    QueryTriggerInteraction.UseGlobal)  { }
```
#### (2) 获取相交的单个物体信息

物体信息类 **`RaycastHit`**

- 参数一：射线
- 参数二：RaycastHit是结构体 是值类型 Unity会通过out 关键在 在函数内部处理后 得到碰撞数据后返回到该参数中
- 参数三：距离
- 参数四：检测指定层级（不填检测所有层）
- 参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal
```CSharp
RaycastHit hitInfo;

if(Physics.Raycast(r3, 
                  out hitInfo, 
                  1000, 
                  1<<LayerMask.NameToLayer("Test"),
                  QueryTriggerInteraction.UseGlobal) ) { }
```
通过这个API, hitInfo 就已经被赋值了

```CSharp
//碰撞器信息
hitInfo.collider.gameObject.name;
//碰撞到的点
hitInfo.point;
//法线信息
hitInfo.normal;

//得到碰撞到对象的位置
hitInfo.transform.position;

//得到碰撞到对象 离自己的距离
hitInfo.distance;
```
注意: 碰撞到的点为射线与碰撞器相交的点

还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断

```CSharp
Physics.Raycast(Vector3.zero, 
                Vector3.forward, 
                out hitInfo, 
                1000, 
                1 << LayerMask.NameToLayer("Test"),
                QueryTriggerInteraction.UseGlobal)
```
#### (3) 获取相交的多个物体
可以得到碰撞到的多个对象, 如果没有 就是容量为0的数组
- 参数一：射线
- 参数二：距离
- 参数三：检测指定层级（不填检测所有层）
- 参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal

```CSharp
//这样存入的信息, 先检测的到的反而在数组的尾部
RaycastHit[] hits = Physics.RaycastAll(r3,
                                       1000, 
                                       1 << LayerMask.NameToLayer("Test"), 
                                       QueryTriggerInteraction.
                                       UseGlobal);
```
还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断
```CSharp
hits = Physics.RaycastAll(Vector3.zero, 
                          Vector3.forward, 
                          1000, 
                          1 << LayerMask.NameToLayer("Test"),
                          QueryTriggerInteraction.UseGlobal);
```
最后还有一种函数 返回的碰撞的数量 通过out得到数据
```CSharp
Physics.RaycastNonAlloc(r3, 
                        hits, 
                        1000, 
                        1 << LayerMask.NameToLayer("Test"),
                        QueryTriggerInteraction.UseGlobal);
```

### 16.3 需要注意的点
- 距离、层级两个参数 都是int类型
- 当我们传入参数时 一定要明确传入的参数代表的是距离还是层级