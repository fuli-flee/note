[toc]

***
# 一. 3D数学
***
## 1. 数学计算公共类Mathf
***
### 1.1 Mathf和Math
- Math是C#中封装好的用于数学计算的工具类 —— 位于System命名空间中
- Mathf是Unity中封装好的用于数学计算的工具结构体 —— 位于UnityEngine命名空间中
- 他们都是提供来用于进行数学相关计算的
***
### 1.2 区别
Mathf 和 Math中的相关方法几乎一样
- Math 是C#自带的工具类 主要就提供一些数学相关计算方法
- Mathf 是Unity专门封装的，不仅包含Math中的方法，还多了一些适用于游戏开发的方法
- 所以我们在进行Unity游戏开发时, 使用Mathf中的方法用于数学计算即可
***
### 1.3 Mathf中的常用方法 -- 一次计算
**(1) π - PI**
```CSharp
print(Mathf.PI);
```
**(2)取绝对值 - Abs**
```CSharp
print(Mathf.Abs(-10));//10
print(Mathf.Abs(-20));//20
print(Mathf.Abs(1)); //1
```
**(3)向上取整 - CeilToInt**
```CSharp
float f = 1.3f;
int i = (int)f;
print(i);
print(Mathf.CeilToInt(f));
print(Mathf.CeilToInt(1.00001f));
```

**(4)向下取整 - FloorToInt**
```CSharp
print(Mathf.FloorToInt(9.6f));
```

**(5)钳制函数 - Clamp**
```CSharp
print(Mathf.Clamp(10, 11, 20));
print(Mathf.Clamp(21, 11, 20));
print(Mathf.Clamp(15, 11, 20));
```

**(6)获取最大值 - Max**
```CSharp
print(Mathf.Max(1, 2, 3, 4, 5, 6, 7, 8));
print(Mathf.Max(1, 2));
```

**(7)获取最小值 - Min**
```CSharp
print(Mathf.Min(1, 2, 3, 4, 545, 6, 1123, 123));
print(Mathf.Min(1.1f, 0.4f));
```

**(8)一个数的n次幂 - Pow**
```CSharp
print(Mathf.Min(1, 2, 3, 4, 545, 6, 1123, 123));
print(Mathf.Min(1.1f, 0.4f));
```

**(9)四舍五入 - RoundToInt**
```CSharp
print(Mathf.Min(1, 2, 3, 4, 545, 6, 1123, 123));
print(Mathf.Min(1.1f, 0.4f));
```

**(10)返回一个数的平方根 - Sqrt**
```CSharp
print("返回一个数的平方根" + Mathf.Sqrt(4));
print("返回一个数的平方根" + Mathf.Sqrt(16));
print("返回一个数的平方根" + Mathf.Sqrt(64));
```

**(11)判断一个数是否是2的n次方 - IsPowerOfTwo**
```CSharp
print("判断一个数是否是2的n次方" + Mathf.IsPowerOfTwo(4));
print("判断一个数是否是2的n次方" + Mathf.IsPowerOfTwo(8));
print("判断一个数是否是2的n次方" + Mathf.IsPowerOfTwo(3));
print("判断一个数是否是2的n次方" + Mathf.IsPowerOfTwo(1));
```

**(12)判断正负数 - Sign**
```CSharp
//返回的是1和-1
print("判断正负数" + Mathf.Sign(0));
print("判断正负数" + Mathf.Sign(10));
print("判断正负数" + Mathf.Sign(-10));
print("判断正负数" + Mathf.Sign(3));
print("判断正负数" + Mathf.Sign(-2));
```
***
### 1.4 Mathf中的常用方法 -- 循环计算
**(1)插值运算 - Lerp**
```CSharp
float start = 0;
float result = 0;
float time = 0;
//Lerp函数公式
result = Mathf.Lerp(start, end, t);

//t为插值系数，取值范围为 0~1
result = start + (end - start)*t
```

**(2)插值运算用法一**
每帧改变start的值——变化速度先快后慢，位置无限接近，但是不会得到end位置
```CSharp
start = Mathf.Lerp(start, 10, Time.deltaTime);
```

**(3)插值运算用法二**
每帧改变t的值——变化速度匀速，位置每帧接近，当t>=1时，得到结果
```CSharp
time += Time.deltaTime;
result = Mathf.Lerp(start, 10, time);
```
****
## 2. 三角函数
![alt text](/Unity/图片/Unity基础/Unity基础09-23_20-49-27.jpg)
***
### 2.1 弧度, 角度相互转化
- 弧度转角度
```CSharp
float rad = 1;
float anger = rad * Mathf.Red2Deg;
```
- 角度转弧度
```CSharp
float anger = 1;
float rad = anger * Mathf.Deg2rad;
```
***
### 2.2 三角函数
Mathf中的三角函数相关的方法, 传参需要用弧度值
```CSharp
print(Mathf.Sin(30 * Mathf.Deg2Rad));//0.5
print(Mathf.Cos(30 * Mathf.Deg2Rad));//0.5
```
***
### 2.3 反三角函数
反三角函数得到的结果是正弦或者余弦值对应的弧度
```CSharp
float rad = Mathf.Asin(0.5f);
print(rad * Rad2Deg);//30
```
****
## 3. 坐标系
***
### 3.1 世界坐标系
- 原点: 世界的中心点
- 三个轴向是固定的
```CSharp
//目前学习的和世界坐标系相关的
this.transform.position;
this.transform.rotation;
this.transform.eulerAngles;
this.transform.lossyScale;
```
***
### 3.2 局部坐标系
- 原点: 物体的中心点(建模时确定)
- 轴向: 右为+x, 上为+y, 前为+z
```CSharp
//相对父对象的物体坐标系的位置 本地坐标 相对坐标
this.transform.localPosition;
this.transform.localEulerAngles;
this.transform.localRotation;
this.transform.localScale;
```
***
### 3.3 屏幕坐标系
- 原点: 屏幕左下角
- 轴向: 右为+x, 上为+y
- 最大宽高: `Screen.width` / `Screen.height`
```CSharp
Input.mousePosition
Screen.width;
Screen.height;
```
***
### 3.4 视口坐标系
- 原点: 屏幕左下角
- 轴向: 右为+x, 上为+y
- 特点: 左下为(0,0), 右上为(1,1)
***
### 3.5 坐标转换
```CSharp
//世界转本地
this.transform.InverseTransformDirection
this.transform.InverseTransformPoint
this.transform.InverseTransformVector

//本地转世界
this.transform.TransformDirection
this.transform.TransformPoint  
this.transform.TransformVector

//世界转屏幕
Camera.main.WorldToScreenPoint
//屏幕转世界
Camera.main.ScreenToWorldPoint

//世界转视口
Camera.main.WorldToViewportPoint
//视口转世界
Camera.main.ViewportToWorldPoint

//视口转屏幕
Camera.main.ViewportToScreenPoint

//屏幕转视口
Camera.main.ScreenToViewportPoint;
```
***
## 4. 向量
***
### 4.1 向量
- 模长: `magnitude`
- 归一化: `normalized`

**补充**
调试画线
- 线段: `Debug.DrawLine();`,前两个参数, 起点和终点
- 射线: `Debug.DrawRay();`, 前两个参数, 起点和方向
***

### 4.2 向量点乘
```CSharp
Vector3.Dot(传入两个向量); //返回两个向量点乘的结果(float)
```
**几何意义**: 一个向量在自己向量上的投影长度
  - 点乘结果 > 0, 两个向量的夹角为锐角 
  - 点乘结果 = 0, 两个向量的夹角为直角 
  - 点乘结果 < 0, 两个向量的夹角为钝角

**计算向量A和向量B之间的夹角**
> β = Acos(单位向量A · 单位向量B)

- β: A与B之间的夹角
- Acos: 反余弦函数

现成的API: `Vector.Angle();`
***
### 4.3 向量的叉乘
```CSharp
Vector3.Cross(传入两个向量); 
```
**几何意义**: 得到的向量同时垂直于A和B所在平面, 这个向量就叫**法向量**
- 若向量A和向量B处于xz平面上
  - y > 0, B在A的右侧
  - y < 0, B在A的左侧
***
### 4.4 插值
#### 线性插值
```CSharp
Vector3.Lerp(start,end,t);
```
- 先快后慢: 每帧改变start值
- 匀速运动: 每帧改变t的值

#### 球形插值
```CSharp
Vector3.Slerp();
```
***
## 5. 四元数
***
### 5.1 为什么要用四元数
#### (1) 欧拉角
- **同一旋转表示不唯一**
  例如: (0, 90, 0) 和 (0, 450, 0)的旋转效果是一样的 
- **万向节死锁**
  当某个特定轴达到某个特殊值时, 绕一个轴转可能会覆盖主另一个轴的旋转, 从而失去一维的自由度
  在unity中欧拉角的优先级是`y-x-z`,所以当x为90时,y和z就处于一个平面, 便形成了万向锁, 也就是说优先级在中间的轴向就是形成万向节死锁的原因

#### (2) Quaternion
- 四元数Q = [cos(β/2),  sin(β/2)x, sin(β/2)y, sin(β/2)z]
```CSharp
Quaternion q = new Quaternion(Mathf.Sin(30 * Mathf.Deg2Rad), 0, 0, Mathf.Cos(30 * Mathf.Deg2Rad));
```
- 提供的轴角对 初始化 四元数的方法
```CSharp
Quaternion q = Quaternion.AngleAxis(60, Vector3.right);
```

#### (3) 四元数和欧拉角的互转
1. 欧拉角转四元数
```CSharp
Quaternion q2 = Quaternion.Euler(60, 0, 0);
```
2. 四元数转欧拉角
```CSharp
print(q2.eulerAngles);
```
#### 补充: 四元数相乘代表旋转四元数
```CSharp
//注意: 这里传入的轴是世界坐标的向上轴
this.transform.rotation *= Quaternion.AngleAxis(1, Vector3.up);
```
***
### 5.2 四元数常用方法
#### (1) 单位四元数
单位四元数表示没有旋转量(角位移), 当角度为 0 或者 360 度时, 对于给定轴都会得到单位四元数
```CSharp
Quaternion.identity;
```

#### (2) 插值运算
`Quaternion`也提供了`Lerp`和`Slerp`,
和`Vector3`不同的是,`Quaternion`中的`Lerp`的效果相比`Slerp`更快,但是旋转范围较大效果较差, 所以建议使用`Slerp`
```CSharp
Quaternion.Slerp();
```

#### (3) 向量指向转四元数
`LookRotation`方法可以将传入的面朝向量转换为对应的四元数角度信息
```CSharp
Quaternion.LookRotation(面朝向量);
```
例: 当人物面朝向想要改变时, 只需要把目标面朝向传入该函数, 便可以得到目标四元数角度信息, 之后将人物四元数角度信息改为得到的信息即可达到转向
***
### 5.3 四元数的计算
#### (1) 四元数相乘

- 两个四元数相乘得到一个新的四元数
- 代表两个旋转量的叠加, 相当于旋转
- 注意: 旋转相对的坐标系, 是物体自身坐标系
```CSharp
Quaternion q = Quaternion.AngleAxis(20, Vector3.up);
this.transform.rotation *= q;
```

#### (2) 四元数乘向量
- 四元数乘向量返回一个新的向量
- 可以将指定向量旋转对应四元数的旋转量, 相当于旋转向量
- 注意: 四元数乘向量一定是四元数在前向量在后的, 不能改变相乘的顺序

***
# 二. MonoBehaviour中的重要内容
***

## 6. 延时/延迟函数
就是会延时执行的函数, 我们可以自己设定延时要执行的函数和具体延时的时间
是MonoBehaviour基类中实现好的方法
***
### 6.1 延时函数的使用
#### ① 延时函数
```CSharp
//参数一：函数名 字符串
//参数二：延迟时间 秒为单位
Invoke("DelayDoSomething", 5);//过5秒后执行DelayDoSomething方法
private void DelayDoSomething()
{
  print("延时执行的函数");
}
```
- 延时函数第一个参数传入的是函数名字符串
- 延时函数没办法传入参数 只有包裹一层
- 函数名必须是该脚本上申明的函数

#### ② 延时重复执行函数
```CSharp
//参数一：函数名字符串
//参数二：第一次执行的延迟时间
//参数三：之后每次执行的间隔时间
InvokeRepeating("DelayDoSomething", 5, 1);//第一次等5s开始执行, 然后每间隔1秒执行一次
```

#### ③ 取消延时函数
- 取消该脚本上的所有延时函数执行
```CSharp
CancelInvoke();
```
- 指定函数名取消
  只要取消了指定延迟 不管之前该函数开启了多少次 延迟执行 都会统一取消
```CSharp
CancelInvoke("DelayDoSomething");
```
#### ④ 判断是否有延时函数
```CSharp
if( IsInvoking("DelayDoSomething") ){ }
```
***
### 6.2 延迟函数受对象失活销毁影响
1. 脚本依附对象失活 或者 脚本自己失活
延迟函数可以继续执行 不会受到影响的
</br>

2. 脚本依附对象销毁或者脚本移除
延迟函数无法继续执行

所以如果想让延时函数在激活时调用, 在失活时停止, 可以配合`OnEnable`和`OnDisable`使用
```CSharp
private void OnEnable()
{
    //对象激活 的生命周期函数中 开启延迟（重复执行的延迟）
}

private void OnDisable()
{
    //对象失活 的生命周期函数中 停止延迟
}
```
***

## 7. 协同程序
***
### 7.1 unity是否支持多线程
unity是支持多线程的
只是新开的线程无法访问unity相关对象的内容

注意: Unity中的多线程 要记住关闭

```CSharp
using System.Threading;

Thread t;

void Start()
{
  t = new Thread(Test);

  //开启线程
  t.Start();
}

//这段的意思是暂停1s, 打印1次123
private void Test() 
{
  while(true)
  {
    Thread.Sleep(1000);
    print("123");
  }
}
```

以上代码你运行时是正常的, 当你停止运行后你会发现, 它还在打印, 甚至你把这个脚本Remove后都还会打印, 所以需要手动去关闭

```CSharp
private void OnDestroy()
{
    t.Abort();
    t = null;
}
```

**那既然不能访问unity相关的对象,开启多线程又有什么意义呢?**

对于多个线程来说, 它们都可以访问同一内存区域, 那么我们可以另开一个线程去计算一些复杂逻辑, 比如A*,网络等, 然后把计算的结果放到指定内存, 处于unity中的主线程只要去查看该内存中有没有东西就行了, 有就拿来用 

```CSharp

Thread t;

//这里的队列就是两个线程的公共容器
private Queue<Vector3> queue = new Queue<Vector3>();

void Start()
{
  t = new Thread(Test);

  //开启线程
  t.Start();
}

void Update()
{
  //然后在unity中只看容器中有没有东西, 有就拿来用
  if( queue.Count > 0 )
  {
    this.transform.position = queue.Dequeue();
  }
}

private void Test()
{
  while(true)
  {
    Thread.Sleep(1000);
    //相当于模拟 复杂算法 算出了一个结果 然后放入公共容器中
    
    //一些巨复杂的运算...
    System.Random r = new System.Random();
    Vector3 vec = new Vector3(r.Next(-10, 10), r.Next(-10, 10), r.Next(-10, 10));
    
    //然后把结果压入队列
    queue.Enqueue(vec);
  }
}
```
**那又有一个问题, 我能理解Test()里用的都是C#里的东西, 可Vector3不是啊? 它是UnityEngine命名空间下的, 为什么它可以用?**

简单来说：Vector3 可以在子线程中使用，因为它只是一个普通的 C# 数据结构（结构体），而不是 Unity 的 “引擎对象”。

**核心区别：“数据容器” vs “引擎对象”**
- Vector3、Color、Mathf 这类属于 “数据容器 / 工具类”：
  - 它们只存储数据（如 x/y/z 值）或提供纯数学计算（如三角函数），不涉及 Unity 引擎的内部状态（比如场景中的物体、渲染管线、物理引擎等）。
  - 就像你自己定义的 public struct MyVector { public float x; public float y; } 一样，创建和修改它们只是在操作内存中的数值，完全不依赖 Unity 主线程的管理。
  </br>

- MonoBehaviour、Transform、Rigidbody 这类属于 “引擎对象”：
  - 它们是 Unity 引擎在内存中维护的 “活对象”，关联着场景数据、渲染状态、物理碰撞等核心逻辑。这些对象的创建、修改、销毁必须由主线程统一处理（否则会导致数据混乱）。
  - 比如 transform.position 看似是修改一个坐标，实际会触发引擎的渲染更新、碰撞体位置同步等一系列内部操作，这些都必须在主线程完成。

**总结规则**
- 判断一个 Unity 类能否在子线程中使用，最简单的标准是：
  - 如果它只是 “装数据的盒子” 或 “纯计算工具”（如 Vector3、Quaternion、Color、Mathf）：可以在子线程中使用。
  - 如果它关联着场景中的实体、渲染、物理等引擎状态（如 GameObject、Component、Camera、Light）：绝对不能在子线程中直接操作。

***
### 7.2 什么是协同程序
[协程的具体描述看我这个文件的第4点](/面试/八股,Lua,unity/八股/Unity.md)

它是"假"的多线程
主要作用:
- 将代码分时执行，不卡主线程
- 简单理解，是把可能会让主线程卡顿的耗时的逻辑分时分步执行

主要使用场景:
- 异步加载文件
- 异步下载文件
- 场景异步加载
- 批量创建时防止卡顿

***
### 7.3 协程和线程的区别
- 新开一个线程是独立的一个管道，和主线程并行执行
- 新开一个协程是在原线程之上开启，进行逻辑分时分步执行
***
### 7.4 协程的使用
IEnumerator和yield return在C#高阶的第10条中有提到过

继承MonoBehavior的类 都可以开启 协程函数

关键点一： 协同程序（协程）函数 返回值 **必须是 IEnumerator 或者继承它的类型** 
关键点二： 协程函数当中 **必须使用 yield return 进行返回**

第一步：声明协程函数
  - 返回值为 `IEnumerator` 类型及其子类
  - 函数中通过 `yield return` 返回值; 进行返回

第二步：开启协程函数
  - 直接调用没有任何效果
  - 常用开启方式
```CSharp
IEnumerator ie = MyCoroutine(1, "123");

StartCoroutine(ie);

Coroutine c1 = StartCoroutine( MyCoroutine(1, "123"));

IEnumerator MyCoroutine(int i, string str)
{
  yield return new WaitForSeconds(1f);
}

```
第三步：关闭协程
  - 关闭所有协程
  ```CSharp
  StopAllCoroutines();
  ```

  - 关闭指定协程
  ```CSharp
  StopCoroutine(c1);
  ```
***
### 7.5 yield return 不同内容的含义
1. 下一帧执行
```CSharp
yield return 数字;
yield return null;
//在Update和LateUpdate之间执行
```

2. 等待指定秒后执行
```CSharp
yield return new WaitForSeconds(秒);
//在Update和LateUpdate之间执行
```

3. 等待下一个固定物理帧更新时执行
```CSharp
yield return new WaitForFixedUpdate();
//在FixedUpdate和碰撞检测相关函数之后执行
```

4. 等待摄像机和GUI渲染完成后执行
```CSharp
yield return new WaitForEndOfFrame();
//在LateUpdate之后的渲染相关处理完毕后之后
```

5. 一些特殊类型的对象 比如异步加载相关函数返回的对象
  - 在 异步加载资源 异步加载场景 网络加载时再说
  一般在Update和LateUpdate之间执行

6. 跳出协程
```CSharp
yield break;
```
***
### 7.6 协程受对象和组件失活销毁的影响
协程开启后
- 组件和物体销毁，协程不执行
- 物体失活协程不执行，组件失活协程执行
***
## 8. 协程的原理
***
### 8.1 协程的本质
协程可以分成两部分
- 协程函数本体
- 协程调度器

协程本体就是一个能够中间暂停返回的函数
协程调度器是Unity内部实现的，会在对应的时机帮助我们继续执行协程函数

Unity只实现了协程调度部分
协程的本体本质上就是一个 C#的迭代器方法
***
### 8.2 协程本体是迭代器方法的体现
#### (1)协程函数本体
   - 如果我们不通过 开启协程方法执行协程 
   - Unity的协程调度器是不会帮助我们管理协程函数的
   - 但是我们可以自己执行迭代器函数内容
      - `MoveNext` 会执行函数中内容遇到 yield return为止的逻辑
      - `Current` 得到 yield return 返回的内容
```CSharp
IEnumerator Test()
{
    print("第一次执行");
    yield return 1;
    print("第二次执行");
    yield return 2;
    print("第三次执行");
    yield return "123";
    print("第四次执行");
    yield return new TestClass(10);
}

void Start()
{
    IEnumerator ie = Test();
    ie.MoveNext();//输出 第一次执行
    print(ie.Current);//输出 1
}
```
   - MoveNext返回的是一个bool值, 代表是否到达结尾, 到达为false, 所以也可以像这么写
```CSharp
//一次性执行完所有的协程函数代码
while(ie.MoveNext())
{
    print(ie.Current);
}
```
#### (2) 协程调度器
继承MonoBehavior后 开启协程
相当于是把一个协程函数（迭代器）放入Unity的协程调度器中帮助我们管理进行执行
具体的yield return 后面的规则 也是Unity定义的一些规则
***
# 三. Resources资源动态加载
***
## 9. Unity中的特殊文件夹
***
### 9.1 工程路径获取
注意: 该方式 获取到的路径 一般情况下 只在 **编辑模式** 下使用
我们不会在实际发布游戏后 还使用该路径, 游戏发布过后 该路径就不存在了 
```CSharp
print(Application.dataPath);//输出你的项目的Assets文件夹路径
```
***
### 9.2 Resources 资源文件夹
- 需要自己创建
- 一般不获取, 只能使用Resources相关API进行加载
- 如果硬要获取该路径 可以用工程路径拼接
```CSharp
print(Application.dataPath + "/Resources");
```

- 作用：
  - 资源文件夹
  - 需要通过Resources相关API动态加载的资源需要放在其中
  - 该文件夹下所有文件都会被打包出去
  - 打包时Unity会对其压缩加密
  - 该文件夹打包后只读 只能通过Resources相关API加载
***
### 9.3 StreamingAssets 流动资源文件夹
- 需要自己创建

- 路径获取：
```CSharp
print(Application.streamingAssetsPath);

//当你打包后,在不同平台下streamingAssetsPath都是不一样的
//所以不能像上面的Resources文件夹那样拼接路径
```
- 作用：
  - 流文件夹
  - 打包出去不会被压缩加密，可以任由我们摆布
  - 移动平台只读，PC平台可读可写
  - 可以放入一些需要自定义动态加载的初始资源
***
### 9.4 persistentDataPath 持久数据文件夹
- 不需要自己创建, 不同平台路径不同
- 路径获取：
```CSharp
print(Application.persistentDataPath);
//这是我输出的结果 C:/Users/asus/AppData/LocalLow/DefaultCompany/Unity Basics
```

- 作用：
  - 固定数据文件夹
  - 所有平台都可读可写
  - 一般用于放置动态下载或者动态创建的文件，游戏中创建或者获取的文件都放在其中
***
### 9.5 Plugins 插件文件夹
- 需要自己创建

- 路径获取：
  - 一般不获取
</br>

- 作用：
  - 插件文件夹
  - 不同平台的插件相关文件放在其中
  - 比如IOS和Android平台
***
### 9.6 Editor 编辑器文件夹
- 需要自己创建
- 路径获取：
  - 一般不获取
- 如果硬要获取 可以用工程路径拼接
```CSharp
print(Application.dataPath + "/Editor");
```
- 作用：
  - 编辑器文件夹
  - 开发Unity编辑器时，编辑器相关脚本放在该文件夹中
  - 该文件夹中内容不会被打包出去
***
### 9.7 Standard Assets 默认资源文件夹 
- 需要自己创建
- 路劲过去：
  - 一般不获取
</br>

- 作用：
  - 默认资源文件夹
  - 一般Unity自带资源都放在这个文件夹下
  - 代码和资源优先被编译
***
## 10. Resources同步加载
***
### 10.1 Resources资源动态加载的作用
- 通过代码动态加载Resources文件夹下指定路径资源
- 避免繁琐的拖曳操作
***
### 10.2 常用资源类型
1. 预设体对象 ——`GameObject`
2. 音效文件 —— `AudioClip`
3. 文本文件 —— `TextAsset`
4. 图片文件 —— `Texture`
5. 其它类型 —— 需要什么用什么类型

***
### 10.3 资源同步加载 普通方法
在一个工程当中 Resources 文件夹 可以有多个通过API加载时 它会自己去这些同名的 Resources 文件夹中去找资源
打包时 Resources 文件夹里的内容都会打包在一起

#### (1) 预设体对象
第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中)
```CSharp
Object obj = Resources.Load("Cube");
```
第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化
```CSharp
Instantiate(obj);
```
#### (2) 音效资源
第一步：加载数据
```CSharp
Object obj3 = Resources.Load("Music/BKMusic");
```
第二步：使用数据 我们不需要实例化 音效切片 我们只需要把数据 赋值到正确的脚本上即可
```CSharp
audioS.clip = obj3 as AudioClip;
audioS.Play();
```

#### (3) 文本资源
文本资源支持的格式
.txt, .xml, .bytes, .json, .html, .csv.....
```CSharp
TextAsset ta = Resources.Load("Txt/Test") as TextAsset;
//得到其中文本内容
print(ta.text);
//得到其中字节数据组
print(ta.bytes);
```

#### (4) 图片
```CSharp
tex = Resources.Load("Tex/TestJPG") as Texture;
```

#### (5) 另外的API
Resources.Load加载同名资源时 无法准确加载出你想要的内容
- 加载指定类型的资源
```CSharp
tex = Resources.Load("Tex/TestJPG", typeof(Texture)) as Texture;
```
- 加载指定名字的所有资源
```CSharp
Object[] objs = Resources.LoadAll("Tex/TestJPG");
foreach (Object item in objs)
{
    if (item is Texture) { }
    else if(item is TextAsset){ }
}
```
*** 
### 10.4 资源同步加载 泛型方法
```CSharp
TextAsset ta2 = Resources.Load<TextAsset>("Tex/TestJPG");
```