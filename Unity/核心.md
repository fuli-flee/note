[toc]

***
# 一. 模型的制作过程

建模师:
① 建模 -> ② 展UV -> ③ 材质和纹理贴图
动作师:
④ 骨骼绑定 -> ⑥ 动画制作
***
# 二. 2D相关
***
## 1. 图片导入相关设置
### 1.1 概述
Unity支持的图片格式有很多
- BMP:是Windows操作系统的标准图像文件格式，特点是几乎不进行压缩，占磁盘空间大
</br>

- TIF:基本不损失图片信息的图片格式，缺点是体积大
</br>

- JPG:一般指JPEG格式，属于有损压缩格式，能够让图像压缩在很小的存储空间，一定程度上会损失图片数据，无透明通道
</br>

- PNG:无损压缩算法的位图格式，压缩比高，生成文件小，有透明通道
</br>

- TGA:支持压缩，使用不失真的压缩算法，还支持编码压缩。体积小，效果清晰，兼备BMP的图像质量和JPG的体积优势，有透明通道
</br>

- PSD:是PhotoShop（PS）图形处理软件专用的格式，通过一些第三方工具或自制工具可以直接将PSD界面转为UI界面
</br>

其它还支持
- EXR、GIF、HDR、IFF、PICT等等

其中Unity最常用的图片格式是
- JPG、PNG、TGA三种格式

***
#### 1.1.1 图片设置的6大部分

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_16-23-27.jpg)

</center>

1. 纹理类型
2. 纹理形状
3. 高级设置
4. 平铺拉伸
5. 平台设置
6. 预览窗口


***
### 1.2 纹理类型 (Texture Type)

#### 1.2.1 纹理类型主要是设置什么
设置纹理类型主要是为了让纹理图片有不同的主要用途, 指明其是用于哪项工作的纹理
***
#### 1.2.2 参数设置
<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_16-34-06.jpg)

</center>

**①Default**
默认纹理, 大部分导入的模型贴图都是该类型

名词解释:
[伽马颜色空间](https://docs.unity3d.org.cn/6000.0/Documentation/Manual/color-spaces.html)

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_16-36-14.jpg)
![alt text](/Unity/图片/Unity核心/Unity核心09-28_16-57-31.jpg)

</center>

`Alpha Source`

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_16-58-55.jpg)

</center>

**② Normal map**
法线贴图格式

法线贴图就是在原物体的凹凸表面的每个点上均作法线
法线就是垂直于某个点的切线的方向向量

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_17-07-19.jpg)
![alt text](/Unity/图片/Unity核心/Unity核心09-28_17-09-19.jpg)

</center>

**③ Editor GUI and Legacy GUI**
一般在编辑器中或者GUI上使用的纹理

**④ Sprite（2D and UI）**
2D游戏或者UGUI中使用的格式

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_17-14-40.jpg)

</center>

- **Sprite Mode**：图像中提取精灵图形的方式
  - Single：按原样使用精灵图像
  - Multiple：瓦片模式，如果是图集，使用该选项，可以在Sprite Editor编辑窗口自定义图片
  - Polygon：网格精灵模式
</br>

- **Pixels Per Unit**：世界空间中的一个距离单位对应多少像素
</br>

- **MeshType**：网格类型；只有Single和Multiple模式才支持
  - Full Rect：创建四边形，将精灵显示在四边形上
  - Tight：基于像素Alpha值来生成网格，更加贴合精灵图片的形状
    - 任何小于32*32的精灵都使用FullRect模式，即使设置成Tight模式也是
</br>

- Extrude Edges：使用滑动条确定生成的网格中精灵周围流出的区域大小
</br>

- **Pivot**：精灵图片的轴心点，Single模式才有此选项
  - 对应九宫格布局的九个点，还可以自定义
</br>

- **Generate Physics Shape**：启用此选项，Unity会自动根据精灵轮廓生成默认物理形状
  - 只有Single 和Multiple模式才可使用
</br>

- **Sprite Editor**：编辑Sprite，需要安装2D Sprite包

**⑤ Cursor**
自定义光标

**⑥ Cookie**
光源剪影格式

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_17-27-44.jpg)

</center>

- Light Type：应用的光源类型
    一般点光源的剪影需要设置为立方体纹理
    方向光和聚光灯的剪影设置为2D纹理

    - Spotlight：聚光灯类型，需要边缘纯黑色纹理
    - Directional：方向光，平铺纹理
    - Point：点光源，需要设置为立方体形状

**⑦ Lightmap**
光照贴图格式

**⑧ Single Channel**
纹理只需要单通道的格式

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_17-31-21.jpg)

</center>

- Channel：希望将纹理处理为Alpha还是Red通道
    - Alpha：使用Alpha通道，不允许进行压缩
    - Red：使用红色通道

*** 
### 1.3 纹理形状
纹理不仅可以用于模型贴图, 还可以用于制作天空盒与反射探针
纹理形状设置, 主要就是用于在两种模式之间进行切换

#### 1.3.1 参数

- ==Texture Shape==：纹理形状
  - ==2D==：2D纹理，最常用设置，这些纹理将使用到模型和GUI元素上
  - ==Cube==：立方体贴图，主要用于天空盒和反射探针

以下对于Cube的参数进行详细讲解
<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-29_08-56-55.jpg)

</center>

- Mapping：如何将纹理投影到游戏对象上
  - Auto：根据纹理信息创建布局
  - 6 Frames Layout：纹理包含标准立方体贴图布局之一排列的六个图像
  - Latitude-Longitude Layout：将纹理映射到2D维度/经度
  - Mirrored Ball：将纹理映射到类似球体的立方体贴图上
</br>

- Convolution Type：纹理的过滤类型
  - None：无过滤
  - Specular：将立方体作为反射探针
  - Diffuse：将纹理进行过滤表示辐照度，可作为光照探
</br>

- Fixup Edge Seams：Convolution Type 为None 和 Diffuse下才有用。解决低端设备上面之间立方体贴图过滤错误

***
### 1.4 纹理高级设置
<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-29_09-05-20.jpg)

</center>

***
#### 1.4.1 参数

>为什么纹理要设置为2的N次方？
>因为图形学规则，纹理必须是2的幂尺寸
- ==Non-Power of 2==：如果纹理尺寸非2的幂如何处理
  - ==None==：纹理尺寸大小保持不变
  - ==To nearest==：将纹理缩放到最接近2的幂的大小,（注意：PVRTC格式要求纹理为正方形）
  - ==To larger==：将纹理缩放到最大尺寸大小值的2的幂的大小
  - ==To smaller==：将纹理缩放到最小尺寸大小值的2的幂的大小
</br>

- ==Read/Write Enabled==：启用可以使用Unity中提供的一些方法从纹理中获取到数据（一般需要获取图片数据时才开启）
</br>

- Streaming Mipmaps：启用则可以使用纹理串流，主要用于在控制加载在内存中的Mipmap级别，用于减少Unity对于纹理所需的内存总量，用性能换内存
  - Mip Map Priority：Mipmap优先级，Unity根据优先级来确定分配资源时优先考虑哪些Mipmap
</br>

- ==Generate Mip Maps==：允许生成MipMap
  - Border Mip Maps：启用可避免颜色向外渗透到较低MIP级别的边缘
  - Mip Map Filtering：优化图像质量的过滤方法
    - Box：随着尺寸减小，级别更加平滑
    - Kaiser：随着Mipmap尺寸大小下降而使用的锐化算法，如果远处纹理太模糊，可以使用该算法
  - Mip Maps Preserve Coverage：Mipmap的Alpha通道在Alpha测试期间保留覆盖率
    - Alpha Cutoff Value：覆盖率参考值
  - Fadeout Mip Maps：级别递减时使Mipmap淡化为灰色

#### 1.4.2 什么是Mipmap?
先贴上我最喜欢的闫老师的课,讲的很清楚 [Lecture 09, 从43:24开始](https://www.bilibili.com/video/BV1X7411F744?spm_id_from=333.788.videopod.episodes&vd_source=e5ff09f1c2b416e099232ca31ec5028d&p=9)

开启MipMap功能后，Unity会帮助我们根据图片信息生成n张不同分辨率的图片
在场景中会根据我们离该模型的距离选择合适尺寸的图片用于渲染，提升渲染效率

***
### 1.5 平铺拉伸
<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-29_09-45-32.jpg)

</center>

#### 1.5.1 参数

- ==Wrap Mode==：平铺纹理时的方式
  - Repeat：在区块中重复纹理
  - Clamp：拉伸纹理的边缘
  - Mirror：在每个整数边界上镜像纹理以创建重复图案
  - Mirror Once：镜像纹理一次，然后将拉伸边缘纹理
  - Per-axis：单独控制如何在U轴和V轴上包裹纹理
</br>

- ==Filter Mode==：纹理在通过3D变化拉伸时如何进行过度
  - Point：纹理在靠近时变为块状
  - Bilinear：纹理在靠近时变得模糊
  - Trilinear：与Bilinear类似，但纹理也在不同的Mip级别之间模糊
</br>

- Aniso Level：以大角度查看纹理时提高纹理质量。性能消耗高

***
### 1.6 平台设置
<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-29_10-04-04.jpg)

</center>

平台设置主要设置纹理最终打包时在不同平台下的尺寸, 格式, 压缩方式
它影响了你包的大小和读取性能方面的问题, 所以非常重要
***
#### 1.6.1 参数

- ==Max Size==：设置导入的纹理的最大尺寸，即使美术出的很大的图，也可以通过这里把它们限制在一定范围内
</br>

- ==Resize Algorithm==：当纹理尺寸大于指定的Max Size时，使用的缩小算法
  - Mitchell：默认米切尔算法来调整大小，该算法是常用的尺寸缩小算法
  - Bilinear：使用双线性插值来调整大小。如果细节很重要的图片，可以使用它，它比米切尔算法保留的细节更多
</br>

- ==Format==：纹理格式, 各平台支持的格式有所不同, 如果选择Automatic, 会根据平台使用默认设置
  - [各平台纹理压缩格式, 这里贴了官方文档](https://docs.unity.cn/cn/2020.3/Manual/class-TextureImporterOverride.html)
  - IOS
    - 选择默认的纹理压缩设置 (PVRTC) 可获得更大的兼容性。
      如果您的应用程序不包含 OpenGL ES 2 支持，则可以选择一种 ASTC 格式。这些格式提供更好的质量和灵活性，并且压缩速度比 PVRTC 快。
  - Android
    - 由于安卓设备众多，设备标准都不同意，一般会根据不同的设备标准制作多个安装包
</br>

- ==Compression==：选择纹理的压缩类型，帮助Unity正确选择压缩格式, 会根据平台和压缩格式的可用性进行压缩
  - None：不压缩纹理
  - Low Quality：以低质量格式压缩纹理
  - Normal Quality：以标准格式压缩纹理
  - High Quality：以高质量格式压缩纹理
</br>

- ==Use Crunch Compression==：启用后，使用Crunch压缩。Crunch是一种基于DXT或ETC纹理压缩的有损压缩格式。压缩时间长，解压速度快。
  - 压缩质量，质量越高意味着纹理越大，压缩时间越长
</br>

- ==Split Alpha Channel==：Alpha通道分离，节约内存。会把一张图分成两张纹理。一张包含RGB数据，一张包含Alpha数据，在渲染时再合并渲染。
</br>

- ==Override ETC2 fallback==：不支持ETC2压缩的设备上，使用的格式
</br>

关于双线性插值, 还是闫老师的课, [还是Lecture 09, 22:45](https://www.bilibili.com/video/BV1X7411F744/?spm_id_from=333.788.videopod.episodes&vd_source=e5ff09f1c2b416e099232ca31ec5028d&p=9)

***
## 2. Sprite

> Packages Manager => 2D Sprite

### 2.1 Sprite Editor
精灵图片编辑器
它主要用于编辑2D游戏开发中使用的Sprite精灵图片
它可以用于编辑图集中提取元素, 设置精灵边框, 设置九宫格, 设置轴心(中心)点等功能 

如果你的项目是创建时是3D项目的话, 得在PackageManager里下载2D Sprite包
***
#### 2.1.1 Single图片编辑

左上角
<center>

![左上](/Unity/图片/Unity核心/Unity核心09-29_10-50-58.jpg)

</center>

**①Sprite Editor**
<center>

![右下](/Unity/图片/Unity核心/Unity核心09-29_10-43-29.jpg)

</center>

- Position：在图片中的偏移位置和宽高
- Border：边框，用于设置九宫格的4条边
- Pivot：轴心（中心）点位置
- Pivot Unit Mode：轴心点单位模式
  - Normalized：标准化模式，0~1
  - Pixels：像素模式
- Custom Pivot：自定义轴心点

**②Custom Outline (决定渲染区域)**
自定义边缘线, 自定义物理形状
<center>

![右下](/Unity/图片/Unity核心/Unity核心09-29_10-58-35.jpg)

</center>

- Snap：将控制点贴近在最近的像素
- Outline Tolerance：轮廓点的复杂性和准确性，0~1, 值越大轮廓点越多，越准确
- Generate：生成网格轮廓

**③ Custom Physics Shape (决定碰撞判断区域)**
自定义精灵图片的物理形状, 主要用于设置需要物理碰撞判断的2D图片
它决定了之后产生碰撞检测的区域

**④ Secondary Textures (为图片添加特殊效果)**
次要纹理设置, 可以将其他纹理和该精灵图片关联
着色器可以得到这些辅助纹理, 然后用于做一些效果处理, 让精灵应用其他效果

***
#### 2.1.2 Multiple图集元素分割
当我们的图片资源是图集时, 我们需要将其Sprite Mode设置为Multiple
这时就可以使用Sprite Editor自带的功能进行图集元素分割

**①自动分割**
Type 选中 Automatic

<center>

![右下](/Unity/图片/Unity核心/Unity核心09-29_11-13-44.jpg)

</center>

- Pivot：单张图片轴心点位置
- Custom Pivot：自定义轴心点
- Method：如何处理现有对象
  - Delete Existing：替换掉已经选择的任何矩形
  - Smart：尝试创建新矩形同时保留或调整现有矩形
  - Safe：添加新矩形而不更改任何已经存在的矩形

**②按单位大小分割**
Type 选中 Grid By Cell Size

<center>

![右下](/Unity/图片/Unity核心/Unity核心09-29_11-18-07.jpg)

</center>

- Pixel Size：单元格宽高
- Offset：偏移位置
- Padding：和边缘的偏移位置
- Keep Empty Rects：是否保留空矩形

**③按单元格数量分割**
Type 选中 Grid By Cell Count
<center>

![右下](/Unity/图片/Unity核心/Unity核心09-29_11-55-55.jpg)

</center>

- Column & Row：行列数

***
#### 2.1.3 Polygon多边形编辑

如果我们使用的资源时多边形资源 
我们可以在设置时将模式设置为Polygon
然后可以在Sprite Editor中进行快捷设置

这个很简单,只需要设置你要的多边形边数(0 ~ 128), 生成对应的多边形用来切割和设置渲染范围 

***
### 2.2 Sprite Renderer
Sprite Renderer是精灵渲染器
所有2D游戏中游戏资源（除UI外）都是通过Sprite Renderer让我们看到的
它是2D游戏开发中的一个极为重要的组件

#### 2.2.1 2D对象的创建
三种方式

1. 直接拖拽 Texture Type 为 Sprites(2D and UI) 的 Sprite 图片到场景中
2. 右键创建: 2D Object -> Sprite -> 关联一个Sprite
3. 创建一个空物体, 添加 Sprite Renderer


#### 2.2.2 参数
<center>

![右下](/Unity/图片/Unity核心/Unity核心09-29_14-46-24.jpg)

</center>

- ==Sprite==：渲染的精灵图片
</br>

- Color：定义着色，一般没有特殊需求不会修改
</br>

- Filp：水平或竖直翻转精灵图片
</br>

- ==Draw Mode==：绘制模式，当尺寸变化时的缩放方式
  - ==Simple==：简单模式，缩放时整个图像一起缩放
  - ==Sliced==：切片模式，9宫格切片模式，十字区域缩放，4个角不变化
    - 一般用于变化不大的纯色图（注意：需要把精灵的网格类型设置为Full Rect）
  - ==Tiled==：平铺模式，将中间部分进行平铺而不是缩放（注意：需要把精灵的网格类型设置为Full Rect）
    - ==Continuous==：当尺寸变化时，中间部分将均匀平铺
    - ==Adaptive==：当尺寸变化时，类似Simple模式，当更改尺寸达到Stretch Value时，中间才开始平铺
</br>

- ==Mask Interaction==：与精灵遮罩交互时的方式
  - ==None==：不与场景中任何精灵遮罩交互
  - ==Visible inside Mask==：精灵遮罩覆盖的地方可见，而遮罩外部不可见
  - ==Visible Outside Mask==：精灵遮罩外部的地方可见，而遮罩覆盖处不可见
</br>

- Sprite Sort Point：计算摄像机和精灵之间距离时，使用精灵中心Center还是轴心点Pivot，一般情况下不用修改
</br>

- Material：材质，可以使用一些自定义材质来显示一些特殊效果
  - 一般情况不修改。默认材质是不会受到光照影响的，如果想要受光照影响，可以选择Default-Diffuse
</br>

- ==Additional Settings==：高级设置
  - ==Sorting Layer==：排序层选择
  - ==Order in Laye==r：层级序列号，数值越大约会显示在前面
</br>


#### 2.2.3 代码设置

**① 获取Sprite Renderer**
```CSharp
GameObject obj = new GameObject();
SpriteRenderer sr = obj.AddComponent<SpriteRenderer>();
```

**② 动态的改变图片**
```CSharp
sr.sprite = Resources.Load<Sprite>("dead1");
//别忘了, 这种加载方式的前提是你把资源放在了Resources文件夹下了
```

**③ 动态的加载 图集中的图**

```CSharp
Sprite[] sprs = Resources.LoadAll<Sprite>("RobotBoyIdleSprite");
sr.sprite = sprs[10];
```

***
### 2.3. Sprite Mask
> Hierarchy窗口右键 => 2D Object => Sprite Mask


精灵遮罩, 它的主要作用就是对精灵图片产生遮罩
制作一些特殊的功能，比如只显示图片的一部分让玩家看到

想要遮罩生效, 需要设置Sprite Renderer中的Mask Interaction

<center>

![右下](/Unity/图片/Unity核心/Unity核心09-30_08-42-18.jpg)

</center>

- Sprite：遮罩图片
- Alpha Cutoff：如果Alpha包含透明区域和不透明区域之间的混合（半透明），则可以手动确定所显示区域的分界点（0~1）
- Custom Range：自定义遮罩范围, 开启后可以设置遮罩的范围，按照排序层来划分
  - 只有与 Mask 同 Sorting Layer，且 Order in Layer 落在 Front/Back 对应的范围内的 Sprite，才会被遮罩影响。
    - Front：遮罩「同层且 Order 比自己大」的 Sprite（前面的）
    - Back：遮罩「同层且 Order 比自己小」的 Sprite（后面的）

举个例子: 我设置了一个新的 Sorting Layer 叫 Test, 排在 Default 层以上
我设置了Mask中的front和back如下图

<center>

![右下](/Unity/图片/Unity核心/Unity核心09-30_09-27-45.jpg)

</center>

那么我在Sprite Renderer中分别将Sorting Layer和Order Layer设置为
- (Default, 0)是没有效果的, (Default, 1)是有效果的 
- (Test, 0)是有效果的, (Test, 1)是有效果的, (Test, 2)是没效果的

*** 

### 2.4 Sorting Group
排序分组, 它的主要作用就是对多个精灵图片进行分组排序
Unity会将同一个排序组中的精灵图片一起排序，就好像他们是单个游戏对象一样
主要作用是对于需要分层的2D游戏用于整体排序

- 注意事项
  1. 子排序组，先排子对象 再按父对象和别人一起排 （同层和同层比）
  2. 多个 挂载排序分组组件的预设体 之间 通过修改 排序索引号来决定前后顺序

***

### 2.5  Sprite Atlas 精灵图集

#### 2.5.1 图集
打图集的目的就是减少DrawCall 提高性能

#### 2.5.2 在Unity中打开自带的打图集功能
[同样的内容在UGUI.md中的第18条写得更加详细](/Unity/UGUI.md)

在工程设置面板中打开功能

> Edit——>Project Setting——>Editor

Sprite Packer(精灵包装器，可以通过Unity自带图集工具生成图集)
Disabled：默认设置，不会打包图集

- Enabled For Builds（Legacy Sprite Packer）：Unity仅在构建时打包图集，在编辑模式下不会打包图集
- Always Enabled（Legacy Sprite Packer）：Unity在构建时打包图集，在编辑模式下运行前会打包图集

- Legacy Sprite Packer传统打包模式 相对下面两种模式来说 多了一个设置图片之间的间隔距离
- Padding Power:选择打包算法在计算打包的精灵之间以及精灵与生成的图集边缘之间的间隔距离, 这里的数字 代表2的n次方

- Enabled For Build：Unity进在构建时打包图集，在编辑器模式下不会打包
- Always Enabled：Unity在构建时打包图集，在编辑模式下运行前会打包图集

#### 2.5.3 相关参数

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_11-17-43.jpg)

</center>

- Type：图集类型
  - Master：主图集

    - Include in Build：选中可以在当前构建中包含图集

    - Allow Rotation：选中此选项将在打包图集时对图片元素进行旋转，可以最大限度提高组合后的图集密度；注意！！！如果是UI图集，请禁用此选项，因为打包时会将场景中UI元素旋转

    - Tight Packing：选中此选项在打包图集时使用图片轮廓来打包而不是根据矩形，可以最大限度提高组合后的图集密度

    - Alpha Dilation（Alpha 扩张）是用于解决精灵边缘渲染异常的优化设置，主要作用是避免图集打包后精灵边缘出现黑边、透明像素或采样错误。

    - Padding：图集中各图片的间隔像素
  - Variant：变体类型的图集

    - Master Atlas：关联的主图集（图集类型必须是Master）

    - Include in Build：选中可以在当前构建中包含图集

    - Scale：设置变体图集的缩放因子（0~1），变体图集的大小是主图集乘以Scale的结果

变体图集的主要作用是以主图集为基础，对它进行缩放产生一个新的图集副本。如果想使用变体图集中的内容，只需要勾选变体图集的Include in build选项，而主图集禁用此选项即可

- Read/Write Enabled：允许通过脚本访问纹理数据。如果启用，会创建纹理数据的副本。会让内存翻倍，一般情况下不需要开启它
- Generate Mip Maps：勾选它会生成Mipmap；Mipmap是一种性能优化手段，用内存换性能。一般情况下不用开启
- SRGB：启用此属性可指定将纹理存储在伽马空间中。对于非 HDR 颜色纹理（例如反照率和镜面反射颜色），应始终选中此复选框。如果纹理存储了有特定含义的信息，并且您需要着色器中的确切值（例如，平滑度或金属度），请禁用此属性。默认情况下会启用此属性。
</br>

- Filter Mode：纹理在3D变化拉伸时如何进行过滤
  - Point：纹理靠近时变为块状
  - Bilinear：纹理靠近时变得模糊
  - Trilinear：与Bilinear类似，但是纹理在不同的MIP级别之间模糊
</br>

- Objects for Packing：关联需要打图集的图片们，注意：一定是Sprite类型的图片
</br>

- Default
  - Max Texture Size：纹理的最大尺寸，像素为单位
  - Format：指定纹理的内部表示，在不同平台上会有不同的参数
  - Compression：纹理压缩类型
    - 不压缩
    - 低质量
    - 普通质量
    - 高质量
    - 质量越高占用内存越多，不压缩质量最好
  - Use Crunch Compression：使用Crunch压缩，是一种有损压缩格式，压缩耗时长，但是运行时解压速度快
  - Compressor Quality：压缩质量，质量越高纹理越大，耗时越长
#### 2.5.4 代码控制
```CSharp
GameObject obj = new GameObject();
SpriteRenderer sr = obj.AddComponent<SpriteRenderer>();
//加载图集资源
SpriteAtlas spriteAtlas = Resources.Load<SpriteAtlas>("MyAtlas");
//加载图集资源中的某一张小图
sr.sprite = spriteAtlas.GetSprite("dead1");
```
***
## 3. 2D物理系统

### 3.1 刚体

#### 3.1.1 2D物理系统中的刚体组件
刚体是物理系统中用于帮助我们进行模拟物理碰撞中力的效果的

2D物理系统中的刚体和3D中的刚体基本是一样的
最大的区别是对象只会在XY平面中移动，并且只在垂直于该平面的轴上旋转

#### 3.1.2 相关参数
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_15-31-28.jpg)

</center>

- Dynamic：动态类型, 受重力和力的影响移动和旋转
  - Material：物理材质，在刚体上设置了物理材质，如果子物体有碰撞器但是没有设置材质则会通用刚体的物理材质
    - 如果不设置，将使用在Physics 2D窗口中设置的默认材质
      物理材质的使用优先级：
      1. 2D碰撞器上指定的2D物理材质
      2. 2D刚体上指定的2D物理材质
      3. Physics 2D窗口指定的2D默认物理材质
  - Simulated：如果希望2D刚体以及所有子对象2D碰撞器和2D关节都能模拟物理效果, 需要启用该选项
  - Use Auto Mass：是否使用自动质量
  - Mass：质量
  - Linear Dray：影响位置移动的阻力系数
  - Angular Drag：影响旋转移动的阻力系数
  - Gravity Scale：受重力影响的程度
  - Collision Detection：碰撞检测算法
    - Discrete：离散检测算法，只会用新位置进行计算，速度过快时会穿过
    - Continuous：连续检测算法，计算量更大，但是不会发生穿过的情况
  - Sleeping Mode：对象处于静止状态时进入睡眠模式
    - Never Sleep：从不休眠，会一直进行检测计算，性能消耗较大
    - Start Awake：最初处于唤醒状态
    - Start Asleep：最初处于睡眠状态，但是可以被碰撞唤醒
  - Interpolate：物理更新间隔之间的插值运算
    - None：不应用移动平滑
    - Interpolate：根据前一帧进行平滑处理
    - Extrapolate：根据后一帧位置进行平滑处理
  - Constraints：约束限制, 可以让某一个轴不受力影响位移或者旋转
</br>

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_15-31-58.jpg)

</center>

- Kinematic：运动学类型, 不受力的影响，只能通过代码让其动起来, 能和Dynamic 2D刚体产生碰撞，但是不会动，
  只会进入碰撞检测函数, 因此它没有了质量摩擦系数等属性
  因此它的性能能消耗较低，主要会通过代码来处理其移动旋转
  - Simulated：
    如果希望2D刚体以及所有子对象2D碰撞器和2D关节都能模拟物理效果, 需要启用该选项
    当启用时，会充当一个无限质量的不可移动对象，可以和所有2D刚体产生碰撞
    如果Use Full Kinematic Contacts禁用，它只会和Dynamic 2D刚体碰撞
  - Use Full Kinematic Contacts：如果希望能和所有2D刚体碰撞，启用它
    如果不启用，它不会和Kinematic 2D和Static 2D刚体碰撞
</br>

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_15-32-19.jpg)

</center>

- Static：静态类型
  完全不动的需要检测碰撞的对象
  相当于是无限质量不可移动的对象
  它的性能消耗最小，它只能和Dynamic 2D刚体碰撞

  和它类似的有只加碰撞器而不加刚体的物体, 它们会和刚体物体产生碰撞，但是自己不会动
</br>

#### 3.1.3 如何选择不同类型的刚体
- Dynamic动态刚体：受力的作用，要动要碰撞的对象

- Kinematic运动学刚体：通过刚体API移动的对象，不受力的作用，但是想要进行碰撞检测 

- Static静态刚体：不动不受力作用的静态物体，但是想要进行碰撞检测 

上面还是很抽象, 我来告诉他们会用在哪些场景
1. 动态刚体最常用, 像是《超级马里奥》这类平台跳跃游戏中，**马里奥**就是一个典型的 Dynamic 动态刚体。他会受到重力的影响而下落，当玩家按下跳跃键时，会给马里奥施加一个向上的力，使其能够跳跃。同时，当马里奥与场景中的平台、敌人等物体碰撞时，会根据物理规则产生相应的反应，如反弹、被击退等。
2. 运动学刚体, 在一些游戏中，**电梯**通常是用 Kinematic 运动学刚体来实现的。电梯本身不受重力和其他物理力的影响，它的运动是通过脚本控制其位置和速度来实现的，比如当玩家进入电梯后，按下上升或下降的按钮，电梯会按照预设的速度和路径进行移动。但电梯又需要与玩家和其他物体进行碰撞检测，以确保玩家能够正确地进入和离开电梯，以及避免其他物体穿过电梯。
3. 静态刚体, 在各种平台跳跃游戏中，固定的**平台**就是 Static 静态刚体。这些平台不会移动，也不受任何物理力的作用，但它们为 Dynamic 动态刚体的角色提供了支撑和碰撞检测的表面，角色可以在平台上站立、跳跃和行走，当角色与平台碰撞时，会按照物理规则进行交互。

#### 3.1.4 刚体API
[看 Unity入门.md 的22条](/Unity/入门.md)

- 加力
```CSharp
Rigidbody2D rigid = this.GetComponent<Rigidbody2D>();
rigid.AddForce(new Vector2(0, 100));
```

- 速度
```CSharp
rigid.velocity = new Vector2(1, 0);
```
***
### 3.2 碰撞器 

碰撞器是用于在物理系统中 表示物体体积的的（形状或范围）
刚体通过得到碰撞器的范围信息进行计算
判断两个物体的范围是否接触
如果接触 刚体就会模拟力的效果产生速度和旋转

#### 3.2.1 2D碰撞器
1. 圆形碰撞器

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_21-13-45.jpg)

</center>

- Material：一种物理材质，用于确定碰撞的属性，控制摩擦和弹性
- Is Trigger：是否是触发器
- Used By Effector：是否被附加的2D效应器使用
- Offset：圆心偏移位置
- Radius：圆形的半径

2. 盒状碰撞器

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_20-58-19.jpg)

</center>

- Used by Composite: 如果勾选, 则该碰撞器将附加到2D复合碰撞器中使用
- Auto Tiling: 如果精灵渲染器组件的Draw Mode设置为Tiled平铺模式, 勾选该选项后, 当改变精灵大小时将自动更新碰撞器的尺寸
- Size: 矩形的宽高
- Edge Radius: 使四个顶点为圆角

3. 多边形碰撞器

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_21-14-08.jpg)

</center>


- Points：多边形顶点
  虽然可以手动修改，但是一般情况下 我们通过数值编辑太复杂了
  都通过Edit Collider编辑，或者让Unity自动识别创建

4. 边界碰撞器

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_21-14-55.jpg)

</center>

边界碰撞器的编辑主要还是通过Edit Collider, 一般不会手动去通过数值加点


5. 胶囊碰撞器

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_21-15-35.jpg)

</center>

- Size：胶囊的宽高
- Direction：是竖直胶囊还是水平胶囊

6. 复合碰撞器

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_21-16-35.jpg)

</center>

- Geometry Type：几何学类型，合并碰撞体时，碰撞体顶点将组合为两种不同的几何体类型
  - Outlines：空心轮廓，类似边界碰撞器
  - Polygons：实心多边形，类似多边形碰撞器
- Generation Type：生成类型，复合碰撞器在何时生成新几何体
  - Synchronous：对2D复合碰撞器或使用的其它碰撞器修改时，Unity立即生成新几何体
  - Manual：手动生成新几何体，通过代码生成或者点击下发的Regenerate Geometry生成按钮
- Vertex Distance：从复合碰撞器收集顶点时允许的最小间距值

#### 3.2.2 碰撞检测函数
[详细的看Unity入门.md的21.2](/Unity/入门.md)

碰撞检测函数 和 3D碰撞检测函数除了名字不同外其他基本一致

***
### 3.3 物理材质
物理材质是用于决定在物体产生碰撞时这些物体之间的摩擦和弹性表现的
通过物理材质我们可以做出类似 斜坡不滑落，小球反弹等效果

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_11-36-42.jpg)

</center>

#### 3.3.1 相关参数
Friction：摩擦系数，为0表示没有摩擦力
Bounciness：反弹程度。0表示没有弹力，1表示完美弹力（没有能量损失一直弹）

***
### 3.4 恒定力
恒定力是一个特殊的脚本
它可以给一个2D刚体持续添加一个力
在做一些随着时间推移而加速的对象时很适用
比如类似火箭发射等效果

恒定力脚本会线性的为对象添加力和扭矩力 让其移动和旋转

#### 3.4.1 相关参数

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_16-26-02.jpg)

</center>

- Force：物理更新时施加于2D刚体上的线性力
- Relative Force：物理更新时施加的线性力（相对刚体对象坐标系）
- Torque：物理更新时施加于2D刚体的扭矩力

*** 
### 3.5 效应器

**使用效应器需要将 Collider 中的 Used By Effector 开启, Is Trigger 视情况开启**

2D效应器是配合2D碰撞器一起使用
可以让游戏对象在相互接触时产生一些特殊的物理作用力
可以通过2D效应器
快捷的实现一些
传送带 互斥 吸引 漂浮 单向碰撞等等效果

#### 3.5.1 区域效应器

主要作用：在一个区域内让游戏对象受到力和扭矩力的作用

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_16-41-19.jpg)

</center>

- Use Collider Mask：是否启用碰撞器遮罩，如果开启才会出现下面的Collider - Mask，可以通过选择层，决定该效应器只会作用于哪些层的对象

- Use Global Angle：勾选将使用世界坐标系角度，如果不勾选，角度为局部角度
- Force Angle：施加力的角度
- Force Magnitude：施加力的大小
- Force Variation：施加力的随机大小变化 会在Force Magnitude基础上根据该值进行随机变化

- ForceTarget：效应器在目标对象上施加力的作用点
	- Collider：以碰撞器的当前位置（如果碰撞器有偏移，没有位于质心，可能会产生扭矩力，带来旋转）
	- Rigidbody：以刚体的当前质心（不会产生扭矩力）

- Drag：阻力
- Angular Drag：扭矩阻力

#### 3.5.2 浮力效应器
主要作用：模拟流体行为，浮动和阻力相关设置，让玩家在该区域看起来像在水里移动
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_16-49-50.jpg)

</center>


- Density：流体密度，密度较大，碰撞体会下沉，密度越小碰撞体会上浮
密度和流体相同的碰撞体会浮在流体中

- Surface Level：定义浮力流体的表面位置，对象高于此线时，不会对其施加浮力，以下或者相交会施加浮力。沿世界Y轴偏移

- Linear Drag：影响对象在水中移动的阻力系数
- Angular Drag：影响对象在水中旋转的阻力系数

- Flow Angle：流体流动方向相对世界控件的角度，沿指定方向施加浮力
- Flow Magnitude：与FlowAngle结合使用，前者决定力的角度，该值确定浮力大小
- Flow Variation：随机改变流体力的值

#### 3.5.3 点效应器
主要作用：模拟磁铁 吸引或者排斥的效果

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_16-54-57.jpg)

</center>


- Force Magnitude：施加力的大小
- Force Variation：施加力的大小变化
- Distance Scale：效应器和目标之间举例的缩放。计算距离时，会按该比值对距离进行缩放

- Force Source：力源来自哪个位置，从该点计算距离。
	- Collider：碰撞器的位置
	- Rigidbody：刚体的位置

- Force Target：作用力目标位置，用改点计算位置
	- Collider：碰撞器的位置，如果碰撞器有偏移，可能会产生扭矩力
	- Rigidbody：刚体的位置，不会产生扭矩力

- Force Mode：计算力的模式
	- Constant：忽略源和目标之间相隔的距离
	- Inverse Linear：反线性距离计算，距离越远，力的大小呈线性减小
	- Inverse Squared：反平方距离计算，力的大小呈指数减小（按平方下降），类似现实世界重力

#### 3.5.4 平台效应器
主要作用：2D游戏当中的平台或可往上跳跃的墙壁

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_17-03-21.jpg)

</center>

- Rotational Offset：旋转偏移量，控制平台角度偏移

- Use One Way：是否使用单向碰撞行为
- Use One Way Grouping：当平台式有多个碰撞器组合时，可以通过它将所有碰撞器设置为单向碰撞行为
- Surface Arc：以局部坐标系下向上的方向为中心，填写一个角度值，定义不允许通过的表面，该角度外的其它地方视为单向碰撞

- Use Side Friction：是否应该在平台两侧使用摩擦
- Use Side Bounce：是否应该在平台两侧使用弹性
- Side Arc：用于定义左右两侧平台的响应弧度

#### 3.5.5 表面效应器

主要作用：模拟传送带

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_17-35-28.jpg)

</center>

- Speed：表面保持的速度
- Speed Variation：速度的随机增加值

- Force Scale：缩放沿表面移动时施加的力。如果是0表示不施加力，相当于禁用。值越低越慢，值越高越快，建议不要设置为1，因为当设置为1时可能会抵消施加在物体上的其它力，比如跳跃的力

- Use Contact Force：是否对接触物体表面的出点施加力，如果选择会让对象旋转，如果不开启则不会旋转
- Use Friction：是否使用摩擦力
- Use Bounce：是否使用弹力

***
## 4. SpriteShape

### 4.1 Sprite Shape Profile
精灵形状概述文件

它主要是方便我们以节约美术资源为前提, 制作2D游戏场景地形或者背景的

#### 4.1.1 导入SpriteShape工具
在Package Manager中导入相关工具
> Packages Manager => 2D Sprite Shape

#### 4.1.2 相关参数

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_18-01-21.jpg)
![alt text](/Unity/图片/Unity核心/Unity核心10-12_18-02-11.jpg)

</center>

- Use Sprite Borders：是否使用精灵边框，用于九宫格拉伸
- Texture：用于填充实心部分的纹理（使用的纹理的平铺模式必须是Repeat重复模式）
- Offset：纹理偏移量
</br>

  这里的设置主要用于封闭图形
  在不同角度范围内使用的图片不同
  可以达到一个封闭效果

- Angle Ranges：角度范围
- Start：起始角度
- End：结束角度
- Order：Sprite相交时的优先级，优先级高的显示在前面
</br>

- Sprites：指定角度范围内的精灵列表
  在该角度范围内，可以选择使用的图片资源
</br>

- Corners：指定角显示的精灵图片, 主要用于封闭图形
  外部四个角用的图片
  内部四个角用的图片

***
### 4.2 Sprite Shape Renderer与Sprite Shape Controller
精灵形状渲染器和控制器

#### 4.2.1 Sprite Shape Renderer相关参数
该控件主要是控制 材质 颜色 以及和其它Sprite交互时的排序等等信息
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_20-08-11.jpg)

</center>

- Color：颜色
- Mask Interaction：遮罩相互作用规则设置
- Fill Material和Edge Material：填充材质和边缘材质
- Sorting Layer和Order in Layer：排序相关

#### 4.2.2 Sprite Shape Controller相关参数

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_20-08-30.jpg)

</center>

- Profile：使用的精灵形状概述文件
- Detail：精灵形状的质量, 高中低三种质量
- Is Open Ended：是否是开放的，不封闭的
- Adaptive UV：自适应UV，如果开启，会自动帮助我们判断是平铺还是拉伸
  开启后只有宽度够才会平铺，如果宽度不够会拉伸
  不开启始终平铺，但是可能会出现裁剪效果
  一般根据你的实际效果进行选择
</br>

- Optimize Geometry：优化三角形数量，勾选后会最小化精灵图形中的三角形数量

- Enable Tangents：是否启用切线计算功能
  如果你的着色器中需要切线信息参与计算，则勾选
</br>

- Corner Threshold：角阈值，当拐角处的角度达到这个阈值时将使用角图片
- Stretch UV：是否拉伸UV，如果勾选纹理的UV将伸展到整个精灵形状的直线上
- Pixel Per Unit：禁用拉伸UV时才有，Unity单位对应多少像素，较高的值会较少纹理的大小
- Worldspace UV：根据世界控件的UV填充纹理
</br>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_20-12-01.jpg)**启用编辑状态后**
- Tangent Mode ：切线模式
  从左至右依次是：
  顶点模式-点两侧不构成曲线
  切线模式-点两侧构成曲线，并且可以控制切线弧度
  左右切线模式-点两侧构成曲线，并且可以分别控制左右两侧切线弧度
</br>

- Position：选中点的局部坐标位置
- Height：控制点左右两侧精灵图片的高度
- Corner：是否使用角度图片
  - Disabled：不使用角度图片
  - Automatic：自动
- Sprite Variant：选择使用的精灵图片
- Snapping：是否开启捕捉设置控制点

#### 4.2.3 生成碰撞器
1. 使用边界碰撞器
2. 使用多边形 碰撞器 配合复合碰撞器

***
## 5. Tilemap
> Package Manager => 2D Tilemap Editor

Tilemap一般称之为 瓦片地图或者平铺地图, 是Unity2017中新增的功能
主要用于快速编辑2D游戏中的场景
通过复用资源的形式提升地图多样性

工作原理就是用一张张的小图排列组合为一张大地图

**它和SpriteShape的异同**
- 共同点
他们都是用于制作2D游戏的场景或地图的
- 不同点
  1. SpriteShape可以让地形有弧度,TileMap不行
  2. TileMap可以快捷制作有伪“Z”轴的地图，SpriteShape不行


### 5.1 瓦片资源

#### 5.1.1 创建瓦片资源
方法一：
> Assets => Create => Tile

方法二：
在Tile Palette瓦片调色板窗口创建
1. 首先新建一个瓦片地图编辑文件
2. 将资源拖入到窗口中选择要保存的路径

#### 5.1.2 相关参数

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-00-50.jpg)

</center>

- Preview：预览图
- Sprite：瓦片关联的精灵纹理
- Color：瓦片色调颜色
- Collider Type：碰撞器类型
	- None：不生成碰撞器
	- Sprite：基于精灵轮廓生成碰撞器形状
	- Grid：基于瓦片单元格生成碰撞器形状

*** 
### 5.2 瓦片调色板窗口
> Window => 2D => Tile Palette

#### 5.2.1 创建新调色板相关参数

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-12-33.jpg)

</center>

- Name：瓦片调色器名称
- Grid：瓦片的网格布局
	- Rectangle：矩形瓦片
	- Hexagon：六边形瓦片
	- Isometric：等距瓦片，单元格为菱形
	- Isometric Z as Y：等距瓦片并且Unity将单元格Z轴转换为局部Y坐标
- Hexagon Type：六边形瓦片地图类型
	- Point Top：点朝顶部的六边形
	- Flat Top：面朝顶部的六边形
- Cell Size：瓦片绘制到单元格的大小
	- Automatic：基于瓦片资源的精灵大小自动设置
	- Manual：自定义大小


<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-05-27.jpg)

</center>

#### 5.2.2 基础操作 
- 单击瓦片 => 选择瓦片
- 在多个瓦片上移动 => 选择多个瓦片
- Alt+左键拖动 => 平移
- 滚轮键拖动 => 平移
- 旋转滚轮键 => 放大/缩小

#### 5.2.3 面板相关
- ![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-27-32.jpg)瓦片地图中有多层时，可以再这里选择层级进行绘制
- ![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-28-17.jpg)选择工具（S）
- ![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-29-03.jpg)移动工具（M）
- ![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-31-06.jpg)画笔工具（B）, 使用选取器后会自动切换到画笔工具，单个填充
- ![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-31-35.jpg)框填工具（U）, 使用选取器后再切换到框填工具，范围填充
- ![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-32-04.jpg)选取器工具（I）, 选取填充样本
- ![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-32-20.jpg)橡皮擦工具（D或者使用画笔工具时按住Shift）, 单个擦除
- ![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-32-37.jpg)填充工具（G）, 使用选取器后再切换到填充工具，批量填充

#### 5.2.4 编辑瓦片地图
方法一：通过瓦片调色板文件创建
方法二：直接在场景中进行创建(常用)

矩形瓦片地图用于做横版游戏地图
六边形瓦片地图用于做策略游戏地图
等距瓦片地图用于做有"Z"轴的2D游戏

注意：
在编辑等距瓦片地图时
1. 需要修改工程的自定义轴排序 以Y轴决定渲染顺序
> Edit => Project Settings => Graphics
> Transparency Sort Axis中的数值是官方推荐数值

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-56-13.jpg)

</center>

2. 如果地图存在前后关系需要修改TileRenderer的渲染模式
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_22-02-19.jpg)

</center>

3. 可以通过Z轴偏移来控制绘制单个瓦片时的高度

> 选中瓦片再在Scene窗口绘制时, 勾选调色板下方的 Can Change Z Position
> 此时按"+"和"-"来调节高度

4. 精灵纹理的中心点会影响最终的显示效果

***
### 5.3 瓦片地图关键脚本和碰撞器

#### 5.3.1 Grid

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_22-15-03.jpg)

</center>

- Cell Size：网格单元格的大小
- Cell Gap：网格之间的间隔大小
- Cell Layout：网格单元的形状和排列
  - Rectangle：矩形
  - Hexagon：六边形
  - Isometric：等距布局，单元格为菱形
  - Isometric Z as Y：等距布局，但Unity将单元格Z轴转换为局部Y坐标
- Cell Swizzle：Unity将XYZ单元格坐标重新排序为你选择的类型

#### 5.3.2 TileMap
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_22-21-39.jpg)

</center>

- Animation Frame Rate：Unity播放瓦片动画的速率。相当于倍速
- Color：瓦片色调颜色
- Tile Anchor：瓦片的锚点偏移
- Orientation：瓦片地图上瓦片的方向。相当于2D平面使用的是Unity中的哪两个轴

#### 5.3.3 TileMapRenderer

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_22-22-48.jpg)

</center>

- Sort Order：设置所选瓦片地图上的瓦片排序方向
- Mode：渲染器的渲染模式
	- Chunk：按位置对瓦片进行分组，并将瓦片精灵一起批处理进行渲染，性能较好
	- Individual：单独渲染每个瓦片，会考虑他们的位置和排序顺序。会让瓦片精灵和场景中其它渲染器或自定义排序轴进行交互
- Detect Chunk Culling：渲染器如何剔除瓦片地图的边界
	- Auto：自动检测
	- Manual：手动设置拓展边界
- Chunk Culling Bounds：当选择手动设置剔除拓展边界时，可以在这里自己填写拓展的值


#### 5.3.4 瓦片地图碰撞器
为挂载TilemapRenerer脚本的对象添加Tilemap Collider2D脚本, 会自动添加碰撞器
注意：想要生成碰撞器的瓦片Collider Type类型要进行设置

可以通过复合碰撞器合并碰撞器
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_22-42-39.jpg)
![alt text](/Unity/图片/Unity核心/Unity核心10-12_22-44-10.jpg)

</center>

#### 5.3.5 等距瓦片的排序相关问题

在绘制等距瓦片时, 一定需要将Tile Renderer的模式改为Individual, 不然会有排序问题

**(1) 轴心点问题**
如下图将轴心点设置为表面中心点, 这样在Tile Map中显示才是符合人眼观测的
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_10-09-25.jpg)
![alt text](/Unity/图片/Unity核心/Unity核心10-13_10-14-05.jpg)

</center>

**(2) 人物显示问题**
绘制好图片后发现人物在渲染时会出现如下排序问题(出人头地了, 不管怎么移动都看不到下半身)

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_10-17-05.jpg)

</center>

解决方案:
1. 将人物轴心点置于脚底中央位置
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_10-19-06.jpg)

</center>

2. 将人物的SpriteRenderer中的排序点设置为轴心点, 但是依然会出现问题(脚会被挡住)
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_10-40-08.jpg)

</center>

3. 将人物的排序顺序设置为高于TileMap
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_10-22-20.jpg)

</center>

**(3) 墙壁的伪z轴遮挡**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_10-47-03.jpg)

</center>

想实现这种效果, 就只需重新创建一个TileMap, 将其排序层设置为高于人物层级即可, 示例中的人物层级为1
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_10-50-25.jpg)

</center>

**(4) 树干的伪z轴遮挡**
根据以上第三点, 会使人物在柱子后的遮挡关系是正确的, 但是在柱子前的遮挡关系是错误的
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_11-09-49.jpg)
![alt text](/Unity/图片/Unity核心/Unity核心10-13_11-10-20.jpg)

</center>

解决方案:
1. 创建一个新的TileMap, 一定记住要将Tile Renderer的模式改为Individual
2. 将树干的轴心点设置为根部中心点
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_11-05-13.jpg)

</center>

3. 将TileMap的排序层设置为和人物一致就解决了

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_11-18-20.jpg)
![alt text](/Unity/图片/Unity核心/Unity核心10-13_11-10-50.jpg)

</center>

**(5) 树干的伪z轴遮挡2**
上面的方法是用TileMap去排序, 也可以用精灵图片直接排序
先说区别: 
- 用TileMap方便编辑, 但是一个菱形网格只能有一个图片显示
- 用精灵图片不方便编辑, 但是你可以随意摆放, 任意重叠

以下为设置方法
1. 设置轴心为树根中心点

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_11-46-13.jpg)

</center>

2. 更改其排序层顺序, 使其处于TileMap之上, 与角色人物一致

此时就能看到正确的遮挡关系了

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_11-49-12.jpg)
![alt text](/Unity/图片/Unity核心/Unity核心10-13_11-50-29.jpg)
![alt text](/Unity/图片/Unity核心/Unity核心10-13_11-50-57.jpg)

</center>

#### 5.3.6 等距瓦片地图的玩家控制相关问题

**(1) 玩家移动相关问题**
这种2D地图如何表现角色移动呢?

1. 将角色角色设置为无重力影响

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_12-01-36.jpg)

</center>

2. 其次将角色能够行走的地方设置为无碰撞器
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_12-03-51.jpg)

</center>


3. 将墙壁或地图边界等的碰撞器设置为Grid

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_12-04-28.jpg)

</center>

4. 再为相应TileMap添加Tilemap Collider 2D, 此时就可以产生正确的碰撞了

**(2)玩家跳跃相关**
如何表现角色跳跃呢? 这里只讲思路

1. 先设置一个角色根物体, 将角色精灵图片设置为根物体的子类
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_12-23-20.jpg)

</center>

2. 按下相应按键后, 用代码控制其精灵图片的y轴上下移动, 来表示其跳跃
    (按下空格后, 精灵图片会向+y轴移动, 然后又落回根物体的位置)

***
### 5.4 官方拓展包
[下载链接](https://github.com/Unity-Technologies/2d-extras)
***
### 5.5 新增瓦片

#### 5.5.1 规则瓦片 RuleTile

定义不同方向是否存在连接图片的规则
让我们更加快捷的进行地图编辑

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_20-24-36.jpg)

</center>

**相关参数**

- Default Sprite：默认图片
- Default GameObject ：默认游戏对象
- Default Collider：默认碰撞器规则
- Tiling Rules：平铺规则 可以自己添加删除

#### 5.5.2 动画瓦片 AnimatedTile
可以指定序列帧
产生可以播放序列帧动画的瓦片
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_20-32-13.jpg)

</center>

**相关参数**
- Number Of Animated Sprites：动画有多少张图构成
- Minimum Speed：最小播放速度
- Maximum Speed：最大播放速度
- Start Time：开始播放的时间
- Strat Frame：从那一帧开始播放

#### 5.5.3 管道瓦片 PipelineTile
根据自己相邻瓦片的数量更换显示的图片
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_20-35-39.jpg)

</center>

**相关参数**
- None：一个都不相邻时使用的图片
- One——Four：相邻1~4个时使用的图片

#### 5.5.4 随机瓦片 RandomTile
根据你设置的图片，随机从中选一个进行绘制
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_20-36-18.jpg)

</center>

**相关参数**
- Number Of Sprites：随机图片数量（之后会随机取一个图片来使用）

#### 5.5.5 地形瓦片 TerrainTile
有点类似规则瓦片，只不过地形瓦片是帮助你定好的规则
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_20-45-35.jpg)

</center>

**相关参数**
- Filled:填满
- Three Sides:三个面
- Two Sides and One Corner:两面一角
- Two Adjacent Sides:相邻两侧
- Two Opposite Sides:两个相对的侧面
- One Side and Two Corners:一侧和两个角
- One Side and One Upper Corner:一边和上角
- One Side:一面
- Four Corners:四个角
- Three Corners:三个角
- Two Adjacent Corners:两个相邻角
- Two Opposite Corners：两个相反的角
- One Corner：一个角
- Empty：空

#### 5.5.6 权重随机瓦片 WeightedRandomTile
可以不平均随机选择图片的瓦片
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_20-51-23.jpg)

</center>

#### 5.5.7 (高级)规则覆盖瓦片 (Advanced)Rule Override Tile
在规则瓦片的基础上 改变图片或者指定启用的规则
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_21-05-25.jpg)
![alt text](/Unity/图片/Unity核心/Unity核心10-13_21-07-06.jpg)

</center>

***
### 5.6 新增笔刷

#### 5.6.1 新建自定义笔刷
1. 预设体笔刷——用于快捷刷出想要创建的精灵
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_21-20-52.jpg)

</center>

2. 预设体随机笔刷——用于快捷随机刷出想要创建的精灵

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_21-24-13.jpg)

</center>

3. 随机笔刷——可以指定瓦片进行关联，随机刷出对应瓦片

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_21-27-31.jpg)

</center>

#### 5.6.2 拓展笔刷
1. Coordinate Brush 坐标笔刷 —— 可以实时看到格子坐标
2. GameObject Brush 游戏对象笔刷 —— 可以在场景中选择和擦除游戏对象仅限于选定的游戏对象的子级
3. Group Brush 组合笔刷 —— 可以设置参数 当点击一个瓦片样式时 会自动取出一个范围内的瓦片
4. Line Brush 线性笔刷 —— 决定起点和终点画一条线出来
5. Random Brush 随机笔刷 —— 和之前的自定义随机画笔类似，可以随机画出瓦片
6. Tint Brush 着色笔刷 —— 可以给瓦片着色 瓦片的颜色锁要开启（Inspector窗口切换Debug模式 修改Flags）
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-13_21-42-14.jpg)

</center>

7. Tint Brush(Smooth) 光滑着色笔刷 —— 可以给瓦片进行渐变着色，需要按要求改变材质

***
### 5.7 代码控制

#### 5.7.1 获取Tilemap和TileBase和Grid
- Tilemap组件：用于管理瓦片地图
- TileBase组件：瓦片资源对象基类
- Grid组件：用于坐标转换

```CSharp
//瓦片地图信息 可以通过它得到瓦片格子
public Tilemap map;
//格子位置相关控制 可以通过它 进行坐标转换
public Grid grid;
//瓦片资源基类通过它可以得到瓦片资源
public TileBase tileBase;
```

#### 5.7.2 重要API
1. 清空瓦片地图
```CSharp
map.ClearAllTiles();
```
2. 获取指定坐标格子
```CSharp
TileBase tmp = map.GetTile(Vector3Int.zero);
```
3. 设置和删除瓦片
```CSharp
map.SetTile(new Vector3Int(0, 2, 0), tileBase);

map.SetTile(new Vector3Int(1, 0, 0), null);

//设置多张
map.SetTiles()
```
4. 替换瓦片
```CSharp
map.SwapTile(tmp, tileBase);
```

5. 世界坐标转格子坐标

>屏幕坐标转世界坐标
>世界坐标转格子坐标


传入的参数是世界坐标
```CSharp
grid.WorldToCell()
```

***

# 三. 动画基础

## 6. Animation动画窗口

> Window => Animation => Animation

### 6.1 认识Animation动画窗口

它主要用于在Unity内部创建和修改动画
所有在场景中的对象都可以通过Animation窗口为其制作动画

原理：
- 制作动画时：记录在固定时间点对象挂载的脚本的变量变化
- 播放动画时：将制作动画时记录的数据在固定时间点进行改变，产生动画效果

#### 6.1.2 名词解释
- 动画时间轴：
每一个动画文件都有自己的一个生命周期，从动画开始到结束
我们可以在动画时间轴上编辑每一个动画生命周期中变化
</br>

- 动画中的帧：
假设某个动画的帧率为60帧每秒，意味着该动画1秒钟最多会有60次改变机会
每一帧的间隔时间是 1s/60 ≈ 16.67毫秒
也就是说 我们最快可以每16.67毫秒改变一次对象状态
</br>

- 关键帧：
动画在时间轴上的某一个时间节点上处于的状态

#### 6.1.3 面板功能
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_09-03-12.jpg)

</center>

从左至右：
1. 预览模式（开关）
2. 录制模式（开关）打开后预览模式默认开启
3. 回到动画开头
4. 上一关键帧（快捷键：键盘逗号）
5. 播放动画（快捷键：键盘Alt+逗号）
6. 下一关键帧（快捷键：键盘句号）
7. 回到动画结尾（快捷键：键盘Alt+句号）
8. 当前处于第几帧

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_09-04-50.jpg)

</center>

- Dopesheet：关键帧模式
- Curves：曲线模式

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_09-05-14.jpg)

</center>

从左至右：
- 按选择筛选
- 添加关键帧
- 添加事件

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_09-06-14.jpg)

</center>

动画时间轴面板
当编辑动画时，会在该面板上编辑关键帧等信息

### 6.2 创建编辑动画

#### 6.2.1 创建动画
1. 在场景中选中想要创建动画的对象
2. 在Animation窗口中点击创建
3. 选择动画文件将要保存到的位置

保存动画文件时，Unity会帮助我们完成以下操作
1. 创建一个 Animator Controller（动画控制器或称之为动画状态机） 资源（新动画系统）
2. 将新创建的动画文件添加到Animator Controller中
3. 为动画对象添加Animator组件
4. 为Animator组件关联创建的Animator Controller文件

#### 6.2.2 面板变化
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_09-18-07.jpg)

</center>

多出一个可以选择当前动画的下拉列表
可以在这里创建新动画和切换动画

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_09-19-31.jpg)

</center>

多出一个可以添加变化属性的按钮
在这里你可以任意添加你想要在动画中变化的脚本变量

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_09-21-34.jpg)

</center>

时间轴可以拖动

注意：
时间轴上的单位为n秒n帧, 一格代表一帧（并不是秒）


<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_11-37-59.jpg)

</center>

选择关键帧右键
  - Add Key：添加关键帧
  - Delete Key：删除关键帧
  - Clamped Auto：切线模式，自动设置切线
  - Auto：旧版切线模式，和Clamped Auto基本类似，主要用于老动画系统，建议不使用除非是老动画
  - Free Smooth：自由设置切线
  - Flat：切线设置为水平
  - Broken：单独控制左右曲线切线
</br>

  - Free：自由设置
  - Linear：直线
  - Constant：常量切换
  - Weighted：权重切换

#### 6.2.2 动画文件界面参数
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_09-56-50.jpg)

</center>

- Loop Time：是否是循环动画（在动画结尾时重新开始）
- Loop Pose：无缝循环运动
- Cycle Offset：循环动画在其他时间开始时的周期偏移

### 6.3 代码控制动画（老动画系统）
Unity中有两套动画系统
- 新：Mecanim动画系统——主要用Animator组件控制动画
- 老：Animation动画系统——主要用Animation组件控制动画（Unity4之前的版本可能会用到）

目前我们为对象在Animation窗口创建的动画都会被新动画系统支配
有特殊需求或者针对一些简易动画，才会使用老动画系统

#### 6.3.1 老动画系统控制动画播放
注意：
在创建动画之前为对象添加Animation组件之后再制作动画
这时制作出的动画和之前的动画格式是有区别的

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_10-17-48.jpg)

</center>

- Default：读取设置得更高的默认重复模式
- Once：播放一次就停止
- Loop：从头到尾不停循环播放
- PingPong：从头到尾从尾到头不停播放
- ClampForever：播放结束会停在最后一帧，并且会一直播放最后一帧（相当于状态不停止），表现效果和Once一样，但是逻辑处理上不同

#### 6.3.2 代码控制播放
1. 播放动画
```CSharp
Animation animation = this.GetComponent<Animation>();

animation.Play("动画名");
```

2. 淡入播放,自动产生过渡效果
```CSharp
//当你要播放的动画的开始状态 和当前的状态 不一样时 
//就会产生过渡效果
animation.CrossFade("动画名2");
```

3. 前一个播完再播放下一个
```CSharp
animation.PlayQueued("动画名2");
animation.CrossFadeQueued("动画名2");
```
4. 停止播放所有动画
```CSharp
animation.Stop();
```

5. 是否在播放某个动画
```CSharp
if( animation.IsPlaying("动画名") ) { }
```
6. 播放模式设置
```CSharp
animation.wrapMode = WrapMode.Loop;
```

7.其它（了解即可，新动画系统中会详细讲解）
层级和权重以及混合（老动画系统需要通过代码来达到动画的遮罩、融合等效果）
```CSharp
//设置层级
animation["动画名"].layer = 1;
//设置权重
animation["动画名"].weight = 1;
//混合模式 叠加还是混合
animation["动画名"].blendMode = AnimationBlendMode.Additive;
//设置混组相关骨骼信息
animation["动画名"].AddMixingTransform();
```

#### 6.3.3 动画事件
动画事件主要用于处理 当动画播放到某一时刻想要触发某些逻辑
比如进行伤害检测、发射子弹、特效播放等等

***
## 7. Animator动画状态机
### 7.1 概念
#### 7.1.1 什么是有限状态机
有限状态机（Finite - state machine, FSM）
又称有限状态自动机，简称状态机
是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型

有限：表示是有限度的不是无限的
状态：指所拥有的所有状态

举例说明：
假设我们人会做很多个动作，也就是有很多种状态
这些状态包括 站立、走路、跑步、攻击、防守、睡觉等等
我们每天都会在这些状态中切换，而且这些状态虽然多但是是有限的
当达到某种条件时，我们就会在这些状态中进行切换
而且这种切换时随时可能发生的

#### 7.1.2 意义
游戏开发中有很多功能系统都是有限状态机
最典型的状态机系统
动作系统 —— 当满足某个条件切换一个动作，且动作是有限的
AI（人工智能）系统 —— 当满足某个条件切换一个状态，且状态时有限的

所以状态机是游戏开发中一个必不可少的概念
***
### 7.2 Animator Controller 动画控制器（状态机）
#### 7.2.1 创建动画状态机
1. 通过为场景中物体创建动画时自动创建
2. 手动创建动画状态机文件

#### 7.2.2 面板讲解

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_15-02-09.jpg)

</center>

- Layers：动画层级页签，为动画添加更多的层级，层级高的动画播放会覆盖层级低的
- Parameters：参数页签，为动画状态机添加控制状态切换的参数
眼睛图标：显隐左侧面板


<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_15-04-08.jpg)

</center>

网格化布局区域：
主要用于编辑状态之前的切换关系
1. 窗口中的每一个矩形表示一个状态
2. 窗口中的每一个箭头表示一个切换条件

矩形说明：
默认三大矩形：
- 绿色Entry矩形：进入状态机流程- 
- 红色Exit矩形：退出状态机流程
- Any State：任意状态，代表状态机中的任意状态

人为添加矩形：
- 橙色矩形：一开始的默认状态动画，和Entry相连, 表示一开始播放的动画
- 灰色矩形：自己添加的某一种动作状态

#### 7.2.3 基础使用——添加动画
1. 自动添加——为对象创建动画后会自动将动画添加到状态机中
2. 手动添加1——将动画文件拖入到状态机中（注意：老动画拖入会有警告）
3. 手动添加2——右键创建状态，再关联动画

#### 7.2.4 基础使用——添加切换条件
在左侧面板点击参数页签
可以在这里添加4种类型的切换条件

### 7.3 代码控制动画状态机切换

#### 7.3.1 相关参数
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_15-28-30.jpg)

</center>

- Controller：对应的动画控制器（状态机）

- Avatar：对应的替身配置信息（之后讲解3D模型时详细讲解）

- **Apply Root Motion**：是否启用动画位移更新

- UpdateMode：更新模式（一般不修改它）
	- Normal：正常更新
	- Animate Physics：物理更新
	- Unscaled Time：不受时间缩放影响

- Culling Mode：裁剪剔除模式
	- Always Animate：始终播放动画，即使在屏幕外也不剔除
	- Cull Update Transforms：摄像机没有渲染该物体时，停止位置、IK的写入
	- Cull Completely：摄像机没有渲染物体时，整个动画被完全禁用

#### 7.3.2 API
我们用代码控制状态机切换主要使用的就是Animator提供给我们的API
我们知道一共有四种切换条件 int float bool trigger
所以对应的API也是和这四种类型有关系的
```CSharp
animator = this.GetComponent<Animator>();
```

1. 通过状态机条件切换动画
```CSharp
animator.SetFloat("条件名", 1.2f);
animator.SetInteger("条件名", 5);
animator.SetBool("条件名", true);
animator.SetTrigger("条件名");

animator.GetFloat("条件名");
animator.GetInteger("条件名");
animator.GetBool("条件名");
```

2. 直接切换动画 除非特殊情况 不然一般不使用
```CSharp
animator.Play("状态名");
```
***
# 四. 2D动画

***
## 8. 序列帧动画
以固定时间间隔 按序列切换图片 就是 序列帧动画的本质
当固定时间间隔足够短时 我们肉眼就会认为图片是连续动态的 进而形成动画（会动的画面）

它的本质和游戏的帧率概念有点类似

原理就是在一个循环中按一定时间间隔不停的切换显示的图片

### 8.1 Animation窗口制作序列帧动画
方法一：
1. 创建一个空物体
2. 创建一个动画
3. 直接将某一个动作的序列帧拖入窗口中

方法二：
直接将图片拖入Hierarchy层级窗口中(只适用于第一次创建动画)

注意：需要修改动画帧率 来控制动画的播放速度

***
## 9. 2D骨骼动画
传统的序列帧动画为了达到好的动画效果
理论上来说，图片越多，动作越流畅
往往需要较多的美术资源，虽然效果好但是资源占用较多

而2D骨骼动画是利用3D骨骼动画的制作原理进行制作的
将一张2D图片分割成n个部位，为每个部位绑上骨骼，控制骨骼旋转移动
达到用最少的2D美术资源做出流畅的2D动画效果

### 9.1 2D Animation

#### 9.1.1 Unity中如何制作2D骨骼动画
主要方式有两种
1. 使用Unity2018新加功能 2D Animation 工具制作
2. 使用跨平台骨骼动画制作工具 Spine 制作

#### 9.1.2 骨骼动画制作基础—单张图片编辑

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_22-24-23.jpg)

</center>

**相关参数**

**①Bone骨骼相关**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_22-34-15.jpg)

</center>

- Preview Pose: 预览模式，可以预览动作并不会真正的改变设置
- Edit Bone: 编辑骨骼，可以改变骨骼的位置、长度、方向、名称等等
- Create Bone: 创建骨骼
- Split Bone: 拆分骨骼，将一个骨骼一分为二

**②Geometry蒙皮相关**
蒙皮决定了骨骼主要控制哪一部分
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_22-39-04.jpg)

</center>

- Auto Geometry: 自动蒙皮
  <center>

  ![alt text](/Unity/图片/Unity核心/Unity核心10-14_22-39-35.jpg)

  </center>

  - Outline Detail: 边缘细节，值越大，轮廓越细致
  - Alpha Tolerance: 阿尔法公差值，控制蒙皮细节
  - Subdivide: 细化程度，控制蒙皮细节
  - Weights: 是否自动设置权重，一般勾选

- Edit Geometry: 编辑蒙皮
- Create Vertex: 创建顶点
- Create Edge: 创建边线
- Split Edge: 拆分边，用一个新的顶点分离一个边

**③Weights权重相关**
决定了当骨骼动时如何印象顶点和边
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_23-08-58.jpg)

</center>

- Auto Weights: 自动赋予权重
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_23-11-24.jpg)

</center>

- Weight Slider: 编辑顶点和边的权重
  <center>

  ![alt text](/Unity/图片/Unity核心/Unity核心10-14_23-12-27.jpg)

  </center>

  - Mode：计算模式
    - Add And Subtract：加减法
    - Grow And Shrink：增长和收缩
    - Smooth：平滑
  - Bone：设置权重的骨骼
  - Normalize：标准化设置
  - Amount：数量级
  - Vertex Weight：顶点权重对应的骨骼

- Weight Brush: 用笔刷赋予权重
  <center>

  ![alt text](/Unity/图片/Unity核心/Unity核心10-14_23-15-58.jpg)

  </center>

  - Size：笔刷大小
  - Hardness：笔刷强度，越大效果越明显
  - Step：步数

- Bone Influence: 选择骨骼用的Sprite
  主要用于在psb图片中使用
  骨骼控制点的图片关联
  <center>

  ![alt text](/Unity/图片/Unity核心/Unity核心10-14_23-21-49.jpg)

  </center>

**④Visibility切换选定精灵或骨骼的可见性**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-14_23-22-34.jpg)

</center>

- 左侧拖动条: 控制编辑时骨骼透明度
- 右侧拖动条: 控制编辑时权重透明度
- 下方列表: 浏览各骨骼名和骨骼层级信息

**⑤骨骼动画的使用**
为创建好的精灵挂载 Sprite Skin 组件, 选择 Create Bones 就能使用骨骼动画了
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-15_08-48-47.jpg)

</center>

#### 9.1.3 骨骼动画制作基础—图集编辑
1. 设置Sprite为图集模式
2. 对图集图片进行切片

#### 9.1.4 骨骼动画制作基础—PSB图集编辑

> Packages Manager => 2D PSD Importer

**(1) 认识PSB文件**
[详情看官方文档](https://docs.unity3d.com/Packages/com.unity.2d.psdimporter@7.0/manual/PSD-importer-properties.html)

PSD和PSB两种格式，都是PS用于保存图像处理数据的文件格式

PSD和PSB两种格式并没有太大的区别
最大的区别是PSD格式兼容除PS以外的其它一些软件
而PSB只能用PS打开

在Unity中官方建议使用psb格式

**(2) 相关参数**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-15_09-40-30.jpg)

</center>

- Extrude Edges：图片边缘延伸网格
- Reslice：从导入层重新生成Sprite，并清除对Sprite的任何更改，只有启用 Mosaic后又用
- Import Hidden：是否导入psb文件中隐藏的图层 
- Keep Duplicate Name：让Sprite名称保留PSB文件中的名字
- Use Layer Group：使用psb文件中的层分组
- Mosaic：启用后，将图层生成Sprite，并将他们合并成单个纹理
- Character Rig：是否使用人物已经绑定的骨骼
- Pivot：轴心点位置

**(3) 编辑相关**
1. 打开PSB文件的 Sprite Editor , 选中 Skinning Editor ,会发现上方会多出一个选项![alt text](/Unity/图片/Unity核心/Unity核心10-15_09-47-01.jpg)
它是用来切换图集和成品图的

2. Visibility窗口也会发生改变
选择 Sprite 可以直接使用PSB文件拆分好的层级进行骨骼编辑
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-15_09-58-24.jpg)

</center>

3. 在自动生成蒙皮时, 会将不需要的骨骼也参与到计算中
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-15_10-11-53.jpg)

</center>

此时就需要使用 weight 当中的(以下只会讲解Bone Influence, Sprite Influence同理)
![alt text](/Unity/图片/Unity核心/Unity核心10-15_10-13-59.jpg)
将选中的骨骼进行删减

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-15_10-16-17.jpg)

</center>

当不需要骨骼的Sprite也想要正常的骨骼效果时, 就可以使用 Bone Influence 增加骨骼, 比如这里的围巾和项链

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-15_10-18-19.jpg)

</center>

#### 9.1.5 反向动力学IK
>在Unity2019版本中需要 Packages Manager => Advanced => Show preview package => 2D IK


>在Unity2021中*2D IK*工具包已经集成到*2D Animation*包中

**(1)什么是IK？**
在骨骼动画中，构建骨骼的方法被称为正向动力学
它的表现形式是，子骨骼（关节）的位置根据父骨骼（关节）的旋转而改变
用我们人体举例子
当我们抬起手臂时，是肩部关节带动的整个手臂的运动，用父子骨骼理解的话就是父带动了子

而IK全称是Inverse Kinematics，翻译过来的意思就是反向动力学的意思
它和正向动力学恰恰相反
它的表现形式是，子骨骼（关节）末端的位置改变会带动自己以及自己的父骨骼（关节）旋转
用我们人体举例子
当我们拿起一个杯子的时候是用手掌去拿，以杯子为参照物，我们移动杯子的位置，手臂会随着杯子一起移动
用父子骨骼理解的话就是子带动了父

**(2) 脚本与参数**
**`IK Manager 2D`**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-15_11-05-02.jpg)

</center>

- IK Solvers：IK解算器，在这里添加IK
  - Chain（CCD）：可以自定义影响N个关节点，不能反向
  - Chain（FABRIK）：可以自定义影响N个关节点，可以反向
  - Limb：只会影响3个关节点
- Weight：权重，当有多个IK控制同一点时权重会影响控制的百分比
- Restore Default Pose：回复默认位置

**`Limb Solver 2D`**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-15_11-07-13.jpg)

</center>

- Effector：默认的IK点位置
- Target：会根据IK点位置生成真正的IK点对象
- Flip：反向
- Constrain Rotation：约束旋转程度
- Solve from Default Pose：从默认姿势进行求解计算
- Weight：权重

**`CCD Solver 2D`**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-15_11-08-53.jpg)

</center>

- Chain Length：IK影响的骨骼数量
- Iterations：算法运行的次数
- Tolerance：容错程度
- Velocity：速度

**(3) 意义**
1. 瞄准功能
2. 头部朝向功能
3. 拾取物品功能

等等有指向性的功能时 我们都可以通过IK来达到目的

最大的作用，可以方便我们进行动画制作

#### 9.1.6 换装

**(1) 同一个文件换装**

**①如何在同一个psb文件中制作换装资源**
1. 在ps中制作美术资源时，将一个游戏对象的所有换装资源都摆放好位置
2. 当我们导入该资源时，要注意是否导入隐藏的图层

**②编辑换装资源的骨骼信息以及分组类别**
注意事项：
每个部位 关联的骨骼要明确设置
为同一个部位的不同装备分组

**③如何换装**
- 两个关键组件
  - SpriteLibrary——精灵资料库，确定类别分组信息(父对象)
  <center>

  ![alt text](/Unity/图片/Unity核心/Unity核心10-16_14-44-58.jpg)

  </center>

  - SpriteResolver——精灵解算器，用于确定部位类别和使用的图片(各个子对象)
  <center>

  ![alt text](/Unity/图片/Unity核心/Unity核心10-16_14-46-06.jpg)

  </center>

- 一个数据文件
  - SpriteLibraryAsset——精灵资料库资源，具体记录类别分组信息的文件
  <center>

  ![alt text](/Unity/图片/Unity核心/Unity核心10-16_14-43-35.jpg)

  </center>

**④代码控制**
1. 获取各部位的SpriteResolver（需要引用命名空间）
2. 使用SpriteResolver的API进行装备切换
`GetCategory()` 获取当前部位默认的类别名
`SetCategoryAndLabel` 设置当前部位想要切换的图片信息
```CSharp
private Dictionary<string, SpriteResolver> dic = new Dictionary<string, SpriteResolver>();

public SpriteResolver sr;
private void Start()
{
    //sr.SetCategoryAndLabel(sr.GetCategory(), "CASK 1");
    SpriteResolver[] srs = this.GetComponentsInChildren<SpriteResolver>();
    for (int i = 0; i < srs.Length; ++i)
    {
        print(srs[i].GetCategory());
        dic.Add(srs[i].GetCategory(), srs[i]);
    }
    
    ChangeEquip("Cask","CASK 1");
}

private void ChangeEquip(string category, string label)
{
    if (dic.ContainsKey(category))
    {
        dic[category].SetCategoryAndLabel(category, label);
    }
}

```
***

**(2) 不同文件换装**


**①如何在不同psb文件中制作换装资源**
1. 保证个部位在PS文件中的统一
2. 基础部位可选择性隐藏

**②编辑换装资源的骨骼信息**
注意事项：
不同文件的骨骼信息必须统一,所以我们直接使用复制的方式

**③手动添加关键组件和数据文件**
1. 首先创建SpriteLibraryAsset数据文件
2. 为根对象添加SpriteLibrary并关联数据文件
3. 为换装部位关联SpriteResolver

**④如何选择 同一文件和 不同文件 制作换装资源两种方案**
- 换装较少的游戏 比如只有面部表情更换 可以使用同一psb文件方案
- 换装较多的游戏 比如各部位有n种装备 可以使用不同psb文件方案
不同psb文件 拓展性更强

一切根据需求而定

***
### 9.2 Spine
[官方网站](http://zh.esotericsoftware.com/)

Spine是一个收费的跨平台的2D骨骼动画制作工具
它支持Unity，UE，Cocos2D，Cocos2D-x等等游戏引擎
相对Unity2018才推出的 2D Animation
Spine是目前商业游戏中较为常用的骨骼动画制作方案 稳定且高效

#### 9.2.1 Spine导出的Unity资源
Spine导出的资源有3个文件
- .json 存储了骨骼信息
- .png  使用的图片图集
- .atlas.txt    图片在图集中的位置信息

当我们把这三个资源导入到已经引入了Spine运行库的Unity工程后, 会自动为我们生成
- _Atlas    材质和.atlas.txt文件的引用配置文件
- _Material 材质文件
- _SkeletonData json和_Atlas资源的引用配置文件

#### 9.2.2 使用Spine导出的骨骼动画
1. 直接将_SkeletonData文件 拖入到场景中
   选择创建 SkeletonAnimation对象
2. 创建空对象 然后手动添加脚本进行关联

#### 9.2.3 Spine骨骼动画相关参数

##### 9.2.3.1 骨骼数据文件
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-16_17-11-50.jpg)

</center>

- SkeletonData JSON:骨骼数据文件
- Scale：缩放大小
- Skeleton Data Modifiers：骨骼数据修改器
- Blend Mode Materizls：混合模式材质
- Apply Additive Material：是否使用叠加材质
- Additive Materials：叠加材质
- Multiply Materials：相乘材质
- Screen Materials：屏幕材质
- Atlas Assets：图集资源
- Mix Settings：混合设置
  - Animation State Data：动画状态数据
  - Default Mix Duration：默认混合持续时间
  - Add Custom Mix：添加自定义混合（可以指定某两个动画之间的持续时间）

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-16_17-13-17.jpg)

</center>

- Animations：动画
- Setup Pose：设置姿势（还原到默认姿势）
- Create Animation Reference Assets：创建动画参考资源
- Slots：插槽相关（一个部位有多张图片构成，可以在这预览）
- SkeletonMecanim：骨骼机制
- Controller：关联动画控制器

SkeletonMecanim是SkeletonAnimation的替代品，它不是必须的

##### 9.2.3.2 脚本组件
`SkeletonAnimation`
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-16_17-23-07.jpg)

</center>

- SkeletonData Asset：关联的骨骼动画信息
- Animation Name：当前播放的动画名
- Loop：是否循环
- Initial Skin：初始蒙皮
- 美术在制作时可能有几套蒙皮
- 一般情况下只有一套 不需要修改
- Time Scale：时间缩放，值越大动画播放的越快
- Root Motion：是否添加根运动的脚本, 一般情况下不添加

`高级设置`
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-16_17-25-17.jpg)

</center>

- Initial Flip X/Y：初始翻转X和Y
- Update When Invisible：不可见时是否更新
  - Nothing：不更新
  - Only Animation Status：仅动画状态
  - Only Event Timelines：仅事件
  - Everything Except Mesh：除了网格其它都更新
  - Full Update：更新所有
- Use Single Submesh：使用单个子网格
- Fix Draw Order：固定提取顺序
- Immutable Triangles：不变三角形
- Clear State On Disable：禁用时清除状态
- Separator Slot Names：分隔符插槽名称
- Z Spacing：Z间距
- Vertex Data：顶点数据
  - PMA Vertex Colors：PMA顶点颜色
  - Tint Black：淡黑色
  - Add Normals：添加法线
  - Solve Tangents：求解切线
- Add Skeleton Utility：添加骨骼公共程序

`debug(在高级设置的右边)`
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-16_17-25-17.jpg)

</center>

- Show Bone Names：显示骨骼名字
- Show Paths：显示路径
- Show Shapes：显示形状
- Show Constraints：显示约束条件
- ScaleX/Y：XY的缩放
- RGBA：颜色
- Bone：骨骼
- Show Bone Names：显示骨骼名字
- Slots：插槽
- Constraints：约束条件
- Draw Order and Separators：提取顺序和分离器相关
- Events：事件
- Data Counts：数据数量
  - Bones：骨骼数量
  - Slots：插槽数量
  - Skins：蒙皮数量
  - Events：事件数量
  - IK Constraints：IK约束数量
  - Transform Constraints：位置约束数量
  - Path Constraints：路径约束数量

#### 9.2.4 Spine骨骼动画代码控制

**① 动画播放**
- 方法一：直接改变SkeletonAnimation中参数
```CSharp
sa = this.GetComponent<SkeletonAnimation>();

//这里必须是先关闭循环再设置动画
sa.loop = false;
sa.AnimationName = "jump";
```

- 方法二：使用SkeletonAnimation中动画状态改变的函数
```CSharp
//马上播放
sa.AnimationState.SetAnimation(0, jumpName, false);
//排队播放
sa.AnimationState.AddAnimation(0, "walk", true, 0);
```
**② 转向**
```CSharp
sa.skeleton.ScaleX = -1;
```
**③ 动画事件**
```CSharp
//动画开始播放
sa.AnimationState.Start += (t) =>
{
    print( sa.AnimationName +  "动画开始播放");
};
//动画被中断或者清除
sa.AnimationState.End += (t) =>
{
    print(sa.AnimationName + "动画中断或者清除");
};
//播放完成
sa.AnimationState.Complete += (t) =>
{
    print(sa.AnimationName + "动画播放完成");
};
//做动画时添加的自定义事件
sa.AnimationState.Event += (t, e) =>
{
    print(sa.AnimationName + "自定义事件");
};
```
**④ 便捷特性**
-  动画特性
```CSharp
[SpineAnimation]
```
-  骨骼特性
```CSharp
[SpineBone]
```
-  插槽特性
```CSharp
[SpineSlot]
```
-  附件特性
```CSharp
[SpineAttachment]
```

**⑤ 获取骨骼、设置插槽附件**
- 获取骨骼
```CSharp
Bone b = sa.skeleton.FindBone(boneName);
```

- 设置插槽附件
```CSharp
sa.skeleton.SetAttachment(slotName, attachmentName);
```

**⑥ 在UI中使用**
用`SkeletonGraphic（UnityUI）`
***
# 五. 模型导入相关设置
Unity支持很多模型格式
比如
- .fbx
- .dae
- .3ds
- .dxf
- .obj等等

99%的模型都不是在Unity中制作的，都是美术人员在建模软件中制作
如 3DMax、Maya等等
当他们制作完模型后，虽然Unity支持很多模型格式
但是官方建议是将模型在建模软件中导出为FBX格式后再使用

使用FBX模型格式的优势
1. 减少不必要数据，提升导入效率
2. 不需要再每台计算机上安装建模软件的授权副本
3. 对Unity版本无要求，使用原始3D模型格式可能会因为版本不同导致错误或意外

如果美术不知道如何导出FBX格式的模型和导出规范
可以参考Unity官网文档或者百度谷歌
美术在导出模型时需要注意
1. https://docs.unity.cn/cn/2019.4/Manual/CreatingDCCAssets.html
2. 坐标轴，人物面朝向为Z轴正方向，Y轴正方向为头顶方向，X轴正方向为人物右侧

**如何在Unity中设置模型相关内容**

在Project窗口选中导入的模型
在Inspector窗口进行相关设置
4个页签分别是
1. Model 模型页签
2. Rig 操纵（骨骼）页签
3. Animation 动画页签
4. Materials 材质纹理页签
***
## 10. Model模型页签
该页签主要是用于设置, 比如
- 模型比例设置
- 是否导入模型中的摄像机和光源
- 网格压缩方式 

等等相关信息

修改模型中存储的各种元素和属性
最终会影响在Unity中使用模型时的一些表现

### 10.1 相关参数
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_10-05-20.jpg)

</center>

**`Scene场景相关设置`**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_10-06-10.jpg)

</center>

- **Scale Factor**
  当模型中的比例不符合项目中的预期比例时
  可以修改此值来改变该模型的全局比例
  Unity的物理系统希望游戏世界中的1米在导入模型文件中为1个单位
</br>

- **Convert Units**
  启用可将模型文件中定义的模型比例转换为Unity的比例
  不同的格式的比例如下
  - .fbx .max .jas = 0.01
  - .3ds = 0.1
  - .mb .ma .lxo .dxf .blend .dae = 1
</br>

- Import BlendShapes
是否允许Unity随网格一起导入混合形状
当导入包含混合形状的网格时，将使用Skinned MeshRenderer组件
  - 注意：
    1. 导入混合形状发现需要在FBX文件中具有平滑组
    2. 如果想要导入具有法线的混合形状
       - 把下方的Blend Shape Normals属性设置为Import，将使用FBX文件的发现
       - 把下方的Blend Shape Normals属性设置为Calculate，Unity使用相同的逻辑来计算网格和混合形状上的法线
</br>

- Import Visibility
  是否导入可见性
  开启后可以从FBX文件中读取可见性属性。
  比如模型动作里 有些动作是要隐藏模型形象的，开启后才会生效

  - 一些3D建模软件对可见性属性不支持或者有限制
  比如Maya和Blender就对可见性有限制
  所以一般这个选项要根据你使用的建模软件决定
  一般可以不勾选
  </br>

- Import Cameras
  是否导入摄像机
  是否把FBX文件中的摄像机也导入，但是Unity支持FBX中摄像机的部分属性，比如正交或透视，是否支持动画，物理属性，远近裁剪面等等
  一般不勾选
</br>

- Import Lights
  是否导入光源
  支持的光源类型
  全局光、聚光灯、方向光、面光源
  支持的光源属性
  范围、颜色、强度、角度
  一般不使用
</br>

- **Preserve Hierarchy**：
  始终创建一个显示预制体根
  通常在导入的时候，FBX会将模型中的空根节点进行优化去掉它
  但是如果多个FBX文件中包含同一层级的空根对象，可以勾选它来保留他们

  - 主要作用是：比如有两个fbx文件，1包含骨骼和网格，2只包含骨骼动画。如果不启用它导入2，那么Unity将剥离根节点，会让层级不匹配让动画不能正常播放
</br>

- Sort Hierarchy By Name
  在层级窗口中根据名字排序子物体
  如果不启用，会保留FBX文件中定义的层级顺序
</br>

**`Meshes网格相关设置`**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_10-07-04.jpg)

</center>

- **Mesh Compression**: 网格压缩
设置压缩比级减小网格的文件大小
提高压缩比会降低网格的精度

  - 调整该参数可以优化游戏包的大小
    - Off：不使用压缩
    - Low：低压缩比
    - Medium：中等压缩比
    - High：高压缩比
</br>

- **Read/Write Enabled**: 是否开启读写网格信息
  - 如果开启，Unity将网格数据传给GPU后，在CPU中还会保留可寻址内存，意味着我们可以通过代码访问网格数据进行处理
  - 如果不开启，Unity将网格数据传个GPU后，会将CPU中的可寻址内存中网格数据删除，我们无法再得到网格数据
  - 开启时，会增加内存占用，关闭时，可以节约运行时内存使用量

  - 何时开启？
    1. 需要在代码中读取或写入网格数据
    2. 需要运行时合并网格
    3. 需要使用网格碰撞器时
    4. 需要运行时使用NavMesh构建组件来烘焙NavMesh时

    等等
</br>

- Optimize Mesh
确定三角形在网格中列出的顺序以提高GPU性能
  - Nothing：无优化
  - Everything：对顶点以及多边形顶点索引进行重新排序
  - Polygon Order：仅对多边形重新排序
  - Vertex Order：仅对顶点重新排序
</br>

- Generate Colliders
生成碰撞器
启用后会自动附加网格碰撞器的情况下导入你的网格
建议不移动的环境几何体可以开启它，但是需要移动的几何体建议不要开启它
</br>

**`Geometry几何体相关设置`**

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_10-07-35.jpg)

</center>

- Keep Quads
保留四边形
启用后，Unity不会将4个顶点的多边形转为三角形
当使用曲面细分着色器时可能需要启用此选项，因为四边形的曲面周色漆比多边形的效率更高
  - Unity 可以导入任意类型的多边形（三角形到 N 边形）。顶点数量超过四个的多边形将始终转换为三角形，无论此设置如何。
    - 如果一个网格有四边形和三角形（或者转换为三角形的 N 边形），那么 Unity 会创建两个子网格来分离四边形和三角形。每个子网格要么只包含三角形，要么只包含四边形。
</br>

- **Weld Vertices**
合并在空间中共享相同位置的顶点，前提是这些顶点总体上共享相同的属性（UV，法线，切线等等）
开启后相当于会通过减少网格的总数量来优化网格的顶点计数

  - 一般都开启，除非你想有意保留这些重复顶点，之后想通过代码去获取他们来进行处理
</br>

- Index Format
网格索引缓冲区的大小
  一般都选择16bits，Auto可以会默认选择16bits
  只有在必要时使用32bit
  16bits即通用又节约内存
</br>

- Legacy Blend Shape Normals
启用后会基于Smoothing Angle值来计算法线
</br>

- Normals
定义如何计算法线
  - Import：从文件中导入法线，如果文件中不包含发现信息，将使用Calculate模式计算法线
  - Calculate：根据Normals Mode、Smoothness Source和Smoothing Angle属性来计算发现
  - None：不计算法线
</br>

- Blend Shape Normals
定义如何为混合形状计算法线
只有当Legacy Blend Shape Normals禁用时出现
</br>

- Normals Mode
计算法线的模式，只有当上方的Normals设置为Import和Calculate才会出现
  - Unweighted Legacy：2017.1版本之前计算法线的方式，如果是在该版本之前导入的所有FBX模型，默认设置为该模式
  - Unweighted：法线不加权重
  - Area Weighted：法线按照图面面积加权重
  - Angle Weighted：法线按照每个图面上的顶角加权重
  - Area And Angle Weighted：法线按照每个图面上的图面面积和顶角加权重，这是默认选项
</br>

- Smoothness Source
如何确定平滑，哪些边应该平滑，哪些应该粗糙
只有当Legacy Blend Shape Normals 禁用时出现
  - Prefer Smoothing Groups：尽可能使用模型文件中的平滑组
  - From Smoothing Groups：仅使用模型文件中的平滑组
  - From Angle：使用Smoothing Angle值来确定哪些边应该是平滑的
  - None：不拆分硬边的任何顶点
</br>

- Smoothing Angle
控制是否为硬边拆分顶点
通常，值越大，产生的顶点越少
仅当Normals设置为Calculate时才可用
注意：此设置仅用于非常光滑的或者非常复杂的模型，否则，最好在3D建模软件中手动平滑然后导入，始终建议建模的时候就做好，更加准确
</br>

- Tangents
定义如何导入或计算顶点切线
仅当Normals设置为Calculate或Import时，此属性才可用
  - Import：如果Normals设置为Import，则从FBX文件中导入顶点切线，如果网格没有切线，那么将无法使用法线贴图着色器
  - Calculate Legacy：使用旧版算法计算切线
  - Calculate Legacy With Split Tangents：使用旧版算法计算切线，并在UV图表上进行拆分。如果网格上的接缝碰坏了法线贴图光照，请使用此属性
  - Calculate Mikktspace：使用米克特空间计算切线
</br>

- Swap UVs：在网格中交换UV通道。如果漫反射纹理使用光照贴图中的UV，请使用此选项
</br>

- Generate Lightmap UVs：为光照贴图创建第二个UV通道
</br>

***
### 记录一个赛博灯泡
这是下一节Rig页签中遇到的
当你点击Rig中`Configure...`是能看到Scene窗口会多出来化身系统的窗口的, 然后人物当然也显示正常
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-18_10-07-48.jpg)

</center>

但是当你将渲染模式从`Shaded`切换至`Shadow Cascades`再切回来的时候, 你会发现模型全黑了, 纹理和阴影都没了, 删meta文件不好使, 甚至把资源删完再重新导入都不好使

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-18_10-08-31.jpg)
![alt text](/Unity/图片/Unity核心/Unity核心10-18_10-11-02.jpg)

</center>


可能是我的技术没到家, 我没搜到相关的解决方案, 我也不了解这其中的原理
**在学rig时千万不要这样做**

***
## 11. Rig操纵（骨骼）页签
该页签主要是用于设置
如何将骨骼映射到导入模型中的网格，以便能够将其动画化
对于人形角色模型，需要分配或创建Avatar（替身信息）
对于非人形角色模型，需要在骨骼中确定根骨骼

简单来说Rig页签主要是设置骨骼和替身系统相关信息的
设置了他们，动画才能正常的播放

### 11.1 相关参数


**`Animation Type动画类型`**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_10-20-02.jpg)

</center>

- None
不存在动画
主要用于一些环境静态模型

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_10-18-43.jpg)

</center>

- Humanoid
人形模型
一般情况下，有头和四肢（一个头两条腿两只手）为人形
人形模型需要使用Avatar化身系统
绑定人主要关节的映射关系

  - **Avatar Definition**：选择获取Avatar定义的位置
    - **No Avatar**：没有化身系统信息
    - **Create From This Model**：根据此模型创建Avatar化身信息
    - **Copy from Other Avatar**：指向另一个模型上设置的Avatar化身信息

  - **Source**：复制另一个具有相同骨架的Avatar化身信息以导入其动画剪辑, 使用Copy From Other Avatar时才有

  - **Configure...**：打开Avatar化身配置
  使用Create From This Model时才有


  - Skin Weights：设置影响单个顶点的最大骨骼数量
    - Standard（4 Bones）：使用最多4个骨骼来产生影响。默认值，处于对性能考虑，建议使用此设置
    - Custom：设置自定义的最大骨骼数，选择后会出现下方的两个选项
    - Max Bones/Vertex：定义每个顶点的最大骨骼数，值越大性能消耗越大
    - Max Bone Weight：设置考虑骨骼权重的最低阈值，权重计算时将忽略小于此值的内容

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_10-30-05.jpg)

</center>

  - Optimize Game Objects：在Avatar化身系统和Animator动画组件中删除和存储所导入角色的游戏对象骨骼层级信息。如果启用会出现下方的Extra Transforms to Expose选项。角色将使用Unity动画系统的内部骨架，可以提高动画角色的性能

  - Extra Transforms to Expose：要公开的骨骼层级，在下方打钩将公开该骨骼层级信息
  放大镜：通过名称搜索对应骨骼信息
    - Toggle All：全选或者反选
    - Collapse All：全部折叠
    - Expand All：全部展开

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_10-22-48.jpg)

</center>

- Generic
通用模型，非人形模型
不是标准的人形模型，可以是任意形状，可能有8只腿两个头等等
这种模型主要需要设置骨骼根节点
  - **Root Node**：选择用于此Avatar的根节点的骨骼（仅当选择Create From This Model才会出现）

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_10-23-24.jpg)

</center>

- Legacy
旧版动画类型
与Unity3.x及更早版本导入和使用动画
一般不使用
  - **Generation**：动画导入方法
    - Don't Import：不导入动画
    - 第2~4个选项：已禁用，勿使用
    - Store in Root（New）：导入动画将其存储在模型的根节点中

### 11.2 Avatar化身系统是什么
理解化身系统首先要知道骨骼动画是什么
通过我们之前基础知识的讲解和2D骨骼动画的讲解
相信大家已经了解骨骼动画是什么
3D动画的本质 也是骨骼动画
为制作好的模型绑定骨骼制作动画是模型动画的制作流程

形象的理解
对于人来说
人的整体结构都是一致的
另一个人能做的动作理论上来说我们是完全可以模仿出来的
而化身系统的本质，就是动作的模仿（复用）
我们可以把一个标准人形动作通过化身系统复用到其它人形模型上
只要保证他们的关节点对应关系是一致的

### 11.3 Avatar化身信息设置
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_10-36-31.jpg)

</center>

**`Mapping：关节映射信息设置`**
我们需要在这个页签对模型关节进行映射设置
因为人物动画无非就是改变这些关节的角度
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_10-37-27.jpg)

</center>

- 身体,头部,左右手,关节映射信息设置

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_10-40-56.jpg)

</center>

- 关节点映射关系

  <center>

  ![alt text](/Unity/图片/Unity核心/Unity核心10-17_11-46-33.jpg)

  </center>

  - Clear：清空映射
  - AutoMap：自动映射
  - Load：从文件中读取
  - Save：保存映射信息

  <center>

  ![alt text](/Unity/图片/Unity核心/Unity核心10-17_11-47-19.jpg)

  </center>

  - Reset：重置姿势
  - Sample Bind-Pose：绑定姿势示例
  - Enforce T-Pose：强制T姿势

**`Muscles&Settings：肌肉和设置`**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_11-49-53.jpg)

</center>

- Muscle Group Preview
肌肉群预览
可以在这里预览在不同姿势的旋转变化
用来观察之前的关联映射关系是否合理
主要起到预览作用

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_11-52-33.jpg)

</center>

- Per-Muscle Settings
肌肉设置
用于设置各骨骼在旋转时的范围限制
因为如果不设置限制，在一些极限角度时会非常奇怪
我们可以在这里单独设置限制范围

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_11-53-51.jpg)

</center>

- Additional Settings：高级设置
可以设置手脚的扭转和伸展值
一般不会修改他们

  - 其中Translation DoF比较重要
  如果启用，将启用人形角色的移动动画
  如果禁用，Unity仅使用旋转对骨骼进行动画化
  但是启用后，会提升性能消耗，因为动画需要执行额外步骤来重定向人形动画，除非动画包含角色某些骨骼的动画式移动才会启用
  一般情况下禁用即可

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_11-54-22.jpg)

</center>

- 重置所有设置

## 12. Animation 动画页签
当我们选中包含动画剪辑的的模型时
该页签将显示动画设置相关的内容

动画剪辑是Unity动画的最小构成元素
代表一个单独的动作

当美术做好动画导出时建议将模型和动画文件分别导出
1. 导出包含网格信息不包含动作信息模型
2. 导出不包含网格信息包含动作信息的动作（模型）文件

具体的导出规则可以参考
- [如何导入外部创建的模型资源](https://docs.unity.cn/cn/2019.4/Manual/CreatingDCCAssets.html)
- [使用多个模型文件来导入动画](https://docs.unity.cn/cn/2019.4/Manual/Splittinganimations.html)

### 12.1 Animation动画页签的4大部分
1. 基础信息设置
2. 动画剪辑属性基本设置
3. 动画剪辑属性其它设置
4. 预览窗口

#### 12.1.1 基础信息设置
**(1)不包含动画剪辑的模型**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_15-47-30.jpg)

</center>

**(2)包含动画剪辑的模型**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_15-48-09.jpg)

</center>

- Import Constraints：从此资源导入约束
启用后，Unity会自动添加相应的约束组件将其关联到正确的游戏对象
</br>

- **Import Animation**：从此资源导入动画
如果禁用，下面的都没有，并且不会导入任何动画
</br>

- Bake Animations：通过反向动力学（IK）或模拟创建的动画以便推进运动关键帧，仅用于Maya、3Dmax和Cinema4D文件
</br>

- **Anim.Compression**：导入动画时使用的压缩类型
  - Off：禁用动画压缩，在导入时Unity不会减少关键帧数量，效果最好性能较低，文件较大，运行时内存占用也大。通常不建议使用
  - Keyframe Reduction：减少冗余关键帧，仅适用于Generic通用动画类型
  - Keyframe Reduction and Compression：减少关键帧并在文件中存储动画时压缩关键帧，会影响文件大小，但是内存大小和Keyframe Reduction相同，仅适用于Legacy旧版动画类型
  - Optimal：让Unity决定如何压缩，仅适用Generic通用和Humanoid人形动画类型
</br>

- Rotation Error：设置旋转曲线压缩容错度（百分比），原始旋转值和减小值之间的最小角度
- Position Error：设置位置曲线压缩容错度（百分比）
- Scale Error：设置缩放曲线压缩容错度（百分比）
  如果原始值和消减值之间的差小于原始值乘以容错百分比，会删除关键帧
  这些内容仅在Keyframe Reduction或Optimal压缩时可用
</br>

- Animated Custom Properties：导入你指定为自定义用户属性的任何FBX属性
</br>


**(3)动画剪辑选择列表**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_15-51-05.jpg)

</center>

在这里可以看到所有的动画剪辑
可以通过+或-来新增剪辑或者删除所选的剪辑

在这里选择一个动画剪辑后
可以在下方编辑具体的相关属性信息
</br>

#### 12.1.2 动画剪辑属性基本设置
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_15-57-10.jpg)

</center>

**(1)动画剪辑名称**
可编辑修改
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_15-57-48.jpg)

</center>

**(2)时间轴**
Start动画剪辑的开始帧
End动画剪辑的结束帧
我们可以在时间轴中定义每个动画剪辑的帧范围
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_15-59-09.jpg)

</center>

**(3)相关参数**
- Loop Time：播放动画剪辑时是否循环播放，到结尾时重新开始
  - Loop Pose：无缝循环运动
    - Loop Match：循环匹配
  - Cycle Offset：循环动画在其他时间开始时的周期偏移
</br>

- Root Transform Rotation：根位置的角度相关
  - Bake Into Pose：将根旋转烘焙到骨骼移动，禁用此选项将存储为根运动
  - Based Upon：根旋转的基础
    - Original：保持源文件中的原始旋转
    - Root Node Rotation：使用根节点的旋转（仅适用Generic通用动画类型）
    - Body Orientation：保持上半身朝前（仅适用于Humanoid人形动画类型）
  - Offset：根旋转偏移（单位：度）
</br>

- Root Transform Position（Y）：根垂直位置（Y轴方向）
  - Bake Into Pose：将垂直根运动烘焙到骨骼移动。禁用此选项将会存储为根运动
  - Based Upon（at Start）：垂直方向根位置的基础
    - Original：保持源文件中的垂直位置
    - Root Node Position：使用垂直根位置（仅适用Generic通用动画类型）
    - Center Of Mass：保持质心与根位置对其（仅适用Humanoid人形动画类型）
    - Feet：保持双脚与根变换位置对齐（仅适用Humanoid人形动画类型）
  - Offset：垂直根位置偏移
</br>

- Root Transform Position（XZ）：根水平位置（XZ平面）
  - Bake Into Pose：将水平根运动烘焙到骨骼移动。禁用此选项将会存储为根运动
  - Based Upon：水平根位置的基础
    - Original：保持源文件中的水平位置
    - Root Node Position：使用水平根位置（仅适用Generic通用动画类型）
    - Center Of Mass：保持与根位置对其（仅适用Humanoid人形动画类型）
</br>

- Mirror：在此剪辑中进行左右镜像（仅Humanoid人形动画类型才显示）
</br>

- Additive Reference Pose：启用后可以设置附加动画层基础参考姿势的帧。在时间轴中可以看到蓝色标记
  附加动画层：在动画控制器（状态机）中可以添加新的动画层

  - Pose Frame：当启用参考姿势帧时，该项就是选择的具体是哪一帧
</br>

#### 12.1.3 动画剪辑属性其它设置
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_15-59-54.jpg)

</center>

**(1)Curves**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_16-17-53.jpg)

</center>

曲线可以配合Animator作为参数，通过加入曲线值可以利用他标记重要的点
可以修改曲线的名字，名字就类似参数名
可以通过加减来添加或删除曲线信息

  <center>

  ![alt text](/Unity/图片/Unity核心/Unity核心10-17_16-18-22.jpg)

  </center>

  曲线中的值
  - X轴代表标准化时间（0~1）代表动画的开始和结尾
  - Y轴的值可以根据需求自己设置

  也可以使用下方提供的预设曲线

**(2)Events**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_16-19-22.jpg)

</center>

动画事件
类似之前我们学习的Animation窗口中的动画事件
可以在这里为动画剪辑添加一个事件，当动画播放到事件处时会自动找对象脚本中的同名函数
当我们希望在动画某一时刻进行逻辑处理时非常常用
比如某一时刻进行伤害判断

**(3)Mask**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_16-22-54.jpg)

</center>

动画遮罩
主要作用是当播放该动画时，可以指定哪一部分或者哪些骨骼排除在外不受动作影响
- Humanoid（人形动画的快捷设置）
我们分别可以控制
头、左右臂、左右手、左右腿、根等
点击他们让他们变成红色，就代表做该动作时不影响该部位

- Transform（明确指定哪些骨骼关节点不受影响）


**(4)Motion**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_16-25-44.jpg)

</center>

当导入的动画剪辑包含根运动时
我们可以在这里手动设置特定骨骼关节点作为我们的根运动节点

展开后看到的都是骨骼关节节点


**(5)Import Messages**
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_16-26-10.jpg)

</center>

当我们导入动画出现问题，看到黄色的警告符号时
你可以将 Generate Retargeting Quality Report 选中
Unity会帮我们生成更多的有关重定向问题的具体信息
我们便可以看到具体的一些问题

只有看到警告动画不正确时才启用，可以帮助我们排查问题

#### 12.1.4 预览窗口
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_16-33-36.jpg)

</center>

- ![alt text](/Unity/图片/Unity核心/Unity核心10-17_16-31-35.jpg)动画剪辑名称
- ![alt text](/Unity/图片/Unity核心/Unity核心10-17_16-31-53.jpg)
  - IK：是否开启脚步反向动力学预览
  - 2D：2D模式预览
  - 箭头：是否显示轴心和质心辅助图标
- ![alt text](/Unity/图片/Unity核心/Unity核心10-17_16-33-59.jpg)切换预览操作的游戏对象
- ![alt text](/Unity/图片/Unity核心/Unity核心10-17_16-34-59.jpg)播放暂停键, 时间轴（可拖动预览）
- ![alt text](/Unity/图片/Unity核心/Unity核心10-17_16-35-22.jpg)播放速度
- ![alt text](/Unity/图片/Unity核心/Unity核心10-17_16-35-44.jpg)播放状态标记, 秒、百分比、帧编号显示当前播放到的位置
- ![alt text](/Unity/图片/Unity核心/Unity核心10-17_16-36-46.jpg)可以为资源添加标签Tag
- ![alt text](/Unity/图片/Unity核心/Unity核心10-17_16-41-25.jpg)AB包相关设置

## 13. Materials 材质纹理页签
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_16-40-48.jpg)

</center>

### 13.1 相关参数
- Material Creation Mode：定义希望Unity如何为模型生成或导入材质
  - None：不使用此模型中嵌入的任何材质，改用Unity的默认漫反射材质
  - Standard：导入时，Unity使用默认规则来生成材质
  - Import via MaterialDescription（Experimental）：导入时，Unity使用FBX文件中嵌入的材质描述来生成材质。
    与Standard相比，该方法结果更准确，并且支持更广泛的材质类型。
</br>

- sRGB Albedo Colors：是否在伽马空间中使用反射率颜色
  对于使用线性颜色控件的项目，禁用此选项
  如果上面的选项选择的是
  - Import via MaterialDescription（Experimental）该属性不可用
</br>

- Location：定义如何访问材质和纹理
  - Use Embedded Materials：将导入的材质保持在导入的资源中
  - Use External Materials（Legacy）：将导入的材质提取为外部资源。旧版材质处理方式，适用于2017.1或更早的Unity版本创建的项目
</br>

- Extract Textures/Materials：当选择Use Embedded Materials后会出现的内容。这两个按钮可以提取导入的资源中嵌入的所有材质和纹理。
  如果没有需要提取的子资源，这两个按钮会显示为灰色
</br>

- Naming：定义材质的命名规则
  - By Base Texture Name：使用导入材质的漫反射纹理名称来命名材质。如果未将漫反射纹理分配给材质，Unity将使用导入材质的名称
  - From Model's Material：使用导入材质的名称来命名材质
  - Model Name + Model's Material：使用模型文件的名称与导入材质的名称相结合来命名材质
</br>

- Search：定义在使用Naming选项定义的名称时查找现有材质的位置规则
  - Local Materials Folder：在本地Materials材质子文件夹（模型文件所在的同一文件夹）中查找现有材质
  - Recursive-Up：在所有父文件夹（一直向上追溯到Assets文件夹）中所有Materials子文件夹中查找现有材质
  - Project-Wide：在所有Unity项目文件夹中查找现有材质
</br>

- EthanWhite: 重新映射的材质
  如果找到了，Unity会自动关联
  如果没有找到，我们可以手动进行关联
</br>
***

# 六. 3D动画

## 14. 3D动画的使用

### 14.1 使用导入的3D动画
1. 将模型拖入场景中
2. 为模型对象添加Animator脚本
3. 为其撞见Animator Controller动画控制器（状态机）
4. 将想要使用的相关动作 拖入Animator Controller动画控制器（状态机）窗口
5. 在Animator Controller动画控制器（状态机）窗口编辑动画关系（使用之前学习的状态机相关知识）
6. 代码控制状态切换

### 14.2 状态设置相关参数
我们可以选中状态机窗口中的某一个状态为其设置相关参数
我们可以称之为动画状态设置
主要设置的是 当前状态的播放速度等等细节
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_18-58-25.jpg)

</center>

- Motion：分配给此状态的动画剪辑
- Speed：动画的默认速度
- Multiplier：控制速度的乘数，如果要使用需要勾选的Parameter选中配合的参数float类型
- Motion Time：运动的时间，如果要使用需要勾选的Parameter选中配合的参数float类型
- Mirror：是否为状态生成镜像，仅适用于人形动画，如果要配合参数使用选中旁边的Parameter关联参数，参数是bool类型
- Cycle Offset：循环偏移时间，如果要配合参数使用选中旁边的Parameter关联参数，参数是float类型
- Foot IK：是否遵循Foot IK，适用于人形人形动画
- Write Defaults：AnimatorStates 是否为其运动执行未动画化的属性写回默认值。
- Solo：仅播放该过渡
- Mute：禁用过渡
  - Solo和Mute如果一起选择，Mute优先执行
- Add Behaviour：添加状态机行为脚本

### 14.3 连线设置相关参数
我们可以选中状态机窗口中的某一条箭头为其设置相关参数
我们可以称之为动画过渡设置
主要设置的是 从一个状态切换到另一个状态时 的表现效果和切换条件
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_19-23-34.jpg)

</center>

#### 14.3.1 动作和动作之间连线
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_19-26-42.jpg)

</center>

可以在这里为动画过渡改名，如果不改
对应的名字就是
"某一状态名"->"某一状态名"
</br>

- Has Exit Time：是否有退出时间，如果勾选，当切换动画时，动画一定是播放到下方的Exit Time（百分比）的时间时才过渡到下一个动画
</br>

- Exit Time：退出时间，当选择上方的Has Exit Time时，该值决定了过渡生效的确切时间。该值可以大于1，如果小于1，比如0.85，表示当动画播放到了85%的动画时，就会过渡。如果大于1，比如4.5，那么动画将循环4.5次后过渡到下一个动画
</br>

- Fixed Duration：选中后，下方的Trnaition Duration过渡持续时间将以秒为单位解读过渡时间，如果不选中，则以百分比解读过渡时间
</br>

- Transition Duration(s/%)：过渡持续时间，相当于从该状态切换到下一状态的过渡动画持续的时间，对应下方两个蓝色箭头包裹区域
</br>

- Transition Offset：过渡到目标状态的起始播放的时间偏移。如果是0则从目标状态开头开始播放，如果是0.5则从目标状态的一半开始播放
你可以理解为切入下一个状态的切入点
</br>

- Interruption Source：该过渡中断的情况
  - None：不在添加任何过渡
  - Current State：将当前状态过渡排队
  - Next State：使下一个状态的过渡进行排队
  - Current State Then Next State：将当前状态的过渡和下一个状态的过渡都依次排队
  - Next State Thne Current State：将下一状态的过渡和当前状态的过渡依次排队
</br>

- Ordered Interruption：当前过渡是否可在不考虑顺序的情况下被其它过渡中断
选中时，找到有效过渡或当前过渡时，会中断
不选中时，找到有效过渡，会中断
</br>

- Conditions：过渡条件
如果没有过渡条件，只会考虑Exit Time
</br>

#### 14.3.1 AnyState和动作之间连线
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_19-41-54.jpg)

</center>

- Can Transition To self：是否可以过渡到自己
- Preview source state：预览各种过渡状态
  可以查看从任意状态切换到当前状态的过渡效果

### 14.4 注意点
1. Has Exit Time是否启用 如果希望瞬间切换动画不需过多等待，取消该选项
2. Can Transition To self是否启用 如果希望自己不要打断自己，取消该选项

***
## 15. 动画分层和遮罩

### 15.1 主要目的
动画分层的作用
游戏中会有这样的需求
人物健康状态时播放正常动画
人物非健康状态时播放特殊动画
比如血量低于一定界限，人物的大部分动作将表现为虚弱状态
我们可以利用动画分层来快速实现这样的功能

动画分层和动画遮罩结合使用
3D游戏中我们常常会面对这样的需求
人物站立时会有开枪动作
人物跑动时会有开枪动作
人物蹲下时会有开枪动作
从表现上来看光是开枪动作可能就有3种
如果要让美术同学做3种开枪动作费时又费资源

我们是否可以这样做
比如开枪动画只影响上半身
下半身根据实际情况播放站立，跑动，蹲下动作
通过上下半身播放不同的动画就可以达到动画的组合播放

动画分层的主要就是达到这两个目的
1. 两套不同层动作的切换
2. 结合动画遮罩让两个动画叠加在一起播放

提升动画多样性，节约资源

### 15.2 如何使用动画分层
1. 新建一个动画层
2. 设置动画层参数
3. 在该层中设置状态机（注意：结合遮罩使用时默认状态一般为Null状态）
4. 根据需求创建动画遮罩
```CSharp
private Animator animator;

animator = this.GetComponent<Animator>();
animator.SetLayerWeight(animator.GetLayerIndex("MaskLayer"), 1);
```

### 15.3 相关参数
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-17_22-39-16.jpg)

</center>

- Weight：权重，当动画同时播放时，如果选择的是叠加状态，会根据权重决定叠加的比例
- Mask：动画遮罩，该层动画全部都会受该遮罩的影响
- Blending：混合方式
  - Override：覆盖方式，播放该层动画时忽略其他层信息
  - Additive：叠加方式，会和其它层动画叠加播放
- Sync：是否同步其它层
  主要用于直接从另一个层复制状态过来，在该层中进行修改
  适用于比如正常状态下有待机走路跑步等等动作，但是受伤状态下动作会改变，可以利用同步层方便我们进行编辑
  选择后会多一个Source Layer表示你要复制哪一层的状态
- Timing：当选中Sync同步其它层时，该参数激活
  - 选中，会采用折中方案调整同步层上的动画时长（基于权重计算）
  - 不选中，动画时长将使用原始层做为母版
- IK Pass：反向动力学，之后讲解IK的时候再讲解

### 15.4 遮罩

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-18_09-46-37.jpg)
![alt text](/Unity/图片/Unity核心/Unity核心10-18_09-47-06.jpg)

</center>

- Humanoid用于人型骨骼
- Transform用于异形

***
## 16. 动画1D混合

> Animator Controller窗口 => 右键 => Create State => From New Blend Tree

### 16.1 概念
游戏动画中常见的功能就是在两个或者多个相似运动之间进行混合
比如
1. 根据角色的速度来混合行走和奔跑动画
2. 根据角色的转向来混合向左或向右倾斜的动作

你可以理解是高级版的动画过渡

之前我们学习的动画过渡是处理两个不同类型动作之间切换的过渡效果
而动画混合是允许合并多个动画来使动画平滑混合

### 16.2 相关参数

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-18_10-30-57.jpg)

</center>

- Parameter
参数，用于控制混合的参数，在参数列表中的参数
</br>

- 蓝色图像
可以在这里控制n个动画的阈值
</br>

- Motion
关联的动画列表，可以用鼠标改变顺序
</br>

- Threshold
对应动作的临界阈值 当等于这个值时动作权重最大（完全播放该动作）
这个值可以完全自由控制，数值范围不定
</br>

- ![alt text](/Unity/图片/Unity核心/Unity核心10-18_10-31-18.jpg)控制动作的播放速度
</br>

- ![alt text](/Unity/图片/Unity核心/Unity核心10-18_10-31-36.jpg)是否镜像动作
</br>

- Automate Thresholds
是否自动设置阈值，它会在取值范围内平均分
一般可以取消勾选我们手动控制更准确
</br>

- Compute Thresholds
计算阈值的方式
  会从动画剪辑的根运动中获去数据
  - Speed：速度
  - Velocity X、Y、Z：xyz上的分速度
  - Angular Speed（Rad 、Deg）：角度或者弧度表示的角速度

  举例：
  比如你的动画剪辑行走动画时Speed速度是1.5个单位每秒
  慢跑是2.3个单位每秒，快跑是4个单位每秒，阈值就会根据这些值来进行设置进行混合
</br>

- Adjust Time Scale
调整时间刻度
  - Homogeneous Speed：均匀速度
  - Reset Time Scale：重置时间刻度
</br>

***

## 17. 动画2D混合

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-18_16-23-37.jpg)

</center>


### 17.1 1D混合和2D混合
- 1D混合是用一个参数控制动画的混合，之所以叫1D是因为一个参数可以看做是1维线性的
- 2D混合你可以简单理解是用两个参数控制动画的混合，之所以叫2D是因为两个参数可以看做是2维平面xy轴的感觉

### 17.2 2D混合的种类
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-18_15-59-43.jpg)

</center>

1. `2D Simple Directional`     2D简单定向模式  运动表示不同方向时使用 比如向前、后、左、右走
2. `2D Freeform Directional`   2D自由形式定向模式   同上 运动表示不同方向时使用 但是可以在同一方向上有多个运动 比如向前跑和走
3. `2D Freeform Cartesian`     2D自由形式笛卡尔坐标模式  运动不表示不同方向时使用 比如向前走不拐弯 向前跑不拐弯 向前走右转 向前跑右转
4. `Direct`                    直接模式   自由控制每个节点权重，一般做表情动作等

前三种方式只是针对动作的不同采用不同的算法来进行混合的
第四种可以用多个参数进行融合

混合树中还可以再嵌入混合树，使用上是一致的，根据实际情况选择性使用

### 17.3 使用


***
## 18. 子状态机
>Animator Controller窗口 => 右键 => Create Sub-State Machine

### 18.1 概念
子状态机顾名思义就是在状态机里还有一个状态机
它的主要作用就是某一个状态是由多个动作状态组合而成的复杂状态
比如某一个技能它是由3段动作组合而成的，跳起，攻击，落下
当我们释放这个技能时会连续播放这3个动作
那么我们完全可以把他们放到一个子状态机中

### 18.2 编辑子状态机
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-18_17-13-57.jpg)

</center>

在子状态机中与选择状态与外部状态连线可以选择连接方式
- States: 选择外部状态的指定状态
- StateMachine: 选择指定外部状态机的默认状态

***
## 19. 动画IK

IK的概念: 看本篇的9.1.5

### 19.1 如何进行IK控制
1. 在状态机的层级设置中 开启 IK 通道
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-18_17-42-24.jpg)

</center>

2. 继承MonoBehavior的类中
  Unity定义了一个IK回调函数:`OnAnimatorIK`
  我们可以在该函数中调用Unity提供的IK相关API来控制IK
</br>

3. Animator中的IK相关API

```
SetLookAtWeight     设置头部IK权重
SetLookAtPosition   设置头部IK看向位置
```

```plaintext
SetIKPositionWeight 设置IK位置权重
SetIKRotationWeight 设置IK旋转权重
SetIKPosition       设置IK对应的位置
SetIKRotation       设置IK对应的角度
```

```plaintext
AvatarIKGoal枚举    四肢末端IK枚举
```

#### 19.1.1 头部IK相关
```CSharp
private Animator animator;
public Transform pos;
public Transform pos2;

private void Start()
{
    animator = this.GetComponent<Animator>();
}

private void OnAnimatorIK(int layerIndex)
{
    //weight:LookAt全局权重0~1
    //bodyWeight:LookAt时身体的权重0~1
    //headWeight:LookAt时头部的权重0~1
    //eyesWeight:LookAt时眼镜的权重0~1
    //clampWeight:0表示角色运动时不受限制，1表示角色完全固定无法执行LookAt，0.5表示只能够移动范围的一半
    animator.SetLookAtWeight(1, 1f, 1f);
    animator.SetLookAtPosition(pos.position);
}
```

#### 19.1.2 四肢IK相关
```CSharp
private void OnAnimatorIK(int layerIndex)
{
    //这里分别设置了IK点看向的位置和角度
    //而位置和角度设置的需求需要具体情况具体分析
    animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, 1);
    animator.SetIKRotationWeight(AvatarIKGoal.RightFoot, 1);
    animator.SetIKPosition(AvatarIKGoal.RightFoot, pos2.position);
    animator.SetIKRotation(AvatarIKGoal.RightFoot, pos2.rotation);
}
```

### 19.2 关于OnAnimatorIK和OnAnimatorMove两个函数的理解
我们可以简单理解这两个函数是两个和动画相关的特殊生命周期函数
他们在Update之后LateUpdate之前调用, 他们会在每帧的状态机和动画处理完后调用

- OnAnimatorIK在OnAnimatorMove之前调用
- OnAnimatorIK中主要处理 IK运动相关逻辑
- OnAnimatorMove主要处理 动画移动以修改根运动的回调逻辑

他们存在的目的只是多了一个调用时机，当每帧的动画和状态机逻辑处理完后再调用

***
## 20. 动作目标匹配
动画目标匹配主要指的是
当游戏中角色要以某种动作移动，该动作播放完毕后，人物的手或者脚必须落在某一个地方
比如：角色需要跳过踏脚石或者跳跃并抓住房梁
那么这时我们就需要动作目标匹配来达到想要的效果

### 20.1 如何实现动画目标匹配
Unity中的Animator提供了对应的函数来完成该功能
使用步骤是
1. 找到动作关键点位置信息（比如起跳点，落地点，简单理解就是真正可能产生位移的动画表现部分）
2. 将关键信息传入MatchTargetAPI中

### 20.2 代码控制
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-19_10-17-31.jpg)

</center>

```CSharp
private void MatchAction()
{
    animator.MatchTarget(targetPos.position, 
                          targetPos.rotation, 
                          AvatarTarget.RightFoot, 
                          new MatchTargetWeightMask(Vector3.one, 1), 
                          0.4f, 
                          0.64f);
    //参数一：目标位置
    //参数二：目标角度
    //参数三：匹配的骨骼位置
    //参数四：位置角度权重
    //参数五：开始位移动作的百分比
    //参数六：结束位移动作的百分比
}
```
### 20.3 注意点
调用匹配动画的时机有一些限制
1. 必须保证动画已经切换到了目标动画上
2. 必须保证调用时动画并不是处于过度阶段而真正在播放目标动画

如果发现匹配不正确，往往都是这两个原因造成的
解决方案就是设置动画的事件, 调用的时机置于过渡状态之后

3. 需要开启Apply Root Motion

***
## 21. StateMachineBehaviour 状态机行为脚本
状态机行为脚本时一类特殊的脚本,继承指定的基类
它主要用于关联到状态机中的状态矩形上
我们可以按照一定规则编写脚本
当进入、退出、保持在某一个特定状态时我们可以进行一些逻辑处理
简单解释就是为Animator Controller状态机窗口中的某一个状态添加一个脚本
利用这个脚本我们可以做一些特殊功能

比如
1. 进入或退出某一状态时播放声音
2. 仅在某些状态下检测一些逻辑，比如是否接触地面等等
3. 激活和控制某些状态相关的特效

### 21.1 使用
1. 新建一个脚本继承StateMachineBehaviour基类
2. 实现其中的特定方法进行状态行为监听
```
  OnStateEnter            进入状态时，第一个Update中调用
  OnStateExit             退出状态时，最后一个Update中调用
  OnStateIK               OnAnimatorIK后调用
  OnStateMove             OnAnimatorMove后调用
  OnStateUpdate           除第一帧和最后一帧，每个Update上调用
  OnStateMachineEnter     子状态机进入时调用，第一个Update中调用
  OnStateMachineExit      子状态机退出时调用，最后一个Update中调用
```

3. 处理对应逻辑

```CSharp
public class Test: StateMachineBehaviour
{
    public string stateName;
    public string musicName;
    public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
    {
        if( stateInfo.IsName(stateName) )
            Debug.Log(".....");
    }
}
```

### 21.2 状态机行为脚本和动画事件如何选择
状态机行为脚本相对动画事件来说更准确
但是使用起来稍微麻烦一些

根据实际需求选择使用

***
## 22. 状态机复用
> Project窗口 => 右键 => Create => Animator Override Controller

游戏开发时经常遇到这样的情况
有n个玩家和n个怪物，他们的动画状态机行为都是一致的，只是对应的动作不同而已
这时如果我们为他们每一个对象都创建一个状态机进行状态设置和过渡设置无疑是浪费时间的
所以状态机复用就是解决这一问题的方案
主要用于为不同对象使用共同的状态机行为
减少工作量 提升开发效率

### 22.1 如何复用状态机
1. 在Project窗口右键Create->Animator Override Controller
2. 为Animator Override Controller文件在Inspector窗口关联基础的Animator Controller文件
3. 关联需要的动画

***

# 七. 角色控制器
角色控制器是让角色可以受制于碰撞，但是不会被刚体所牵制
如果我们对角色使用刚体判断碰撞，可能会出现一些奇怪的表现

比如：
1. 在斜坡上往下滑动
2. 不加约束的情况碰撞可能让自己被撞飞

等等

而角色控制器会让角色表现的更加稳定
Unity提供了角色控制器脚本专门用于控制角色

注意：
添加角色控制器后，不用再添加刚体
能检测碰撞函数
能检测触发器函数
能被射线检测

## 23. 使用

## 23.1 相关参数
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-19_11-05-00.jpg)

</center>

- Slope Limit: 坡度度数限制，大于该值的斜坡上不去
- Step Offset：台阶偏移值，单位为米，低于这个值的台阶才能上去，该值不能大于角色控制器的高度
- Skin Width：皮肤的宽度，两个碰撞体可以穿透彼此最大的皮肤宽度，较大的值可以减少抖动，较小的值可能导致角色卡住，建议设置为半径的10%
- MinMoveDistance：最小移动距离，大多数情况下为0，可以用来减少抖动

## 23.2 相关代码
```CSharp
private CharacterController cc;

void Start()
{
    cc = this.GetComponent<CharacterController>();
    //1. 关键参数
    //是否接触了地面
    if ( cc.isGrounded )
    {
        print("接触地面了");
    }
}

void Update()
{
    //2. 关键方法
    //受重力作用的移动
    cc.SimpleMove(Vector3.forward * 80 * Time.deltaTime * Input.GetAxisRaw("Vertical"));
    //不受重力作用的移动
    cc.Move(Vector3.forward * 10 * Time.deltaTime);
}

//当角色控制器想要判断和别的碰撞器产生碰撞时 使用该函数
private void OnControllerColliderHit(ControllerColliderHit hit)
{
    print(hit.collider.gameObject.name);
}

//对角色控制器没用 
private void OnCollisionEnter(Collision collision)
{
    print("碰撞触发");
}

//可以检测触发器
private void OnTriggerEnter(Collider other)
{
    print("触发器触发");
}
```
***
# 八. 导航寻路系统

Unity中的导航寻路系统是能够让我们在游戏世界当中
让角色能够从一个起点准确的到达另一个终点
并且能够自动避开两个点之间的障碍物选择最近最合理的路径进行前往

Unity中的导航寻路系统的本质
就是在A星寻路算法的基础上进行了拓展和优化

## 24. 概述
1. 导航网格(NavMesh)的生成——要想角色能够在场景中自动寻路产生行进路径，那么必须得先有场景地形数据，导航网格生成就是生成用于寻路的地形数据
2. 导航网格寻路组件(NavMesh Agent)——寻路组件就是帮助我们根据地形数据计算路径让角色动起来的关键
3. 导航网格连接组件(Off-Mesh Link)——当地形中间有断层，想让角色能从一个平面跳向另一个平面，网格连接组件时关键
4. 导航网格动态障碍物组件(NavMesh Obstacle)——地形中可能存在的可以移动或动态销毁的障碍物需要挂载的组件

***
## 25. 导航网格生成
> Window => AI => Navigation
### 25.1 相关参数
1. Object页签——设置参与寻路烘焙的对象
2. Bake页签——导航数据烘焙页签，设置寻路网格具体信息
3. Areas页签——导航地区页签，设置对象的寻路消耗
4. Agents页签——代理页签，设置寻路代理信息

### 25.1.1 Ojbect场景对象设置页签
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-19_18-26-24.jpg)

</center>

- Sceme Filter：场景过滤器，配合Hierarchy窗口使用
  - All：显示场景上所有对象
  - MeshRenderers：显示挂载的网格渲染器的对象
  - Terrains：显示挂载了地形脚本的对象
- Navigation Static: 导航静态物体开关
- Generate OffMeshLinks: 生成网格连接点开关
- Navigation Area: 导航区域选择，配合Areas页签使用

### 25.1.2 Bake导航数据烘焙页签

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-19_18-31-37.jpg)

</center>


- Agent Radius
代理半径
决定了烘焙边缘精确度
控制平台可行走区域和边缘可行走区域
</br>

- Agent Height
代理高度
决定了烘焙高度精确度
控制拱桥是否可以穿越
</br>

- Max Slope
最大坡度
斜坡度数
决定了斜坡是否可以行走
</br>

- Step Height
最小楼梯高度
决定了台阶是否可以行走
</br>

- Generated off mesh Links
生成非网格连接
两个分开的网格之间连接相关设置
  - Drop Height
  掉落高度
  可以从这个高度掉下来
  - Jump Distance
  跳跃距离
  决定不同平面上的跳跃距离
</br>

- Advanced
  - Manual Voxel Size: 手动设置立体像素大小
    - Voxel Size
    开启前者后可以在这里设置立体像素大小
    可以控制烘焙的准确度
    立体像素大小描述了生成的导航网格表示场景几何体的准确程度
</br>

    - 注意：立体像素大小减半会使内存使用量增加4倍，构建时间也增加4倍
    一般情况下不需要修改这个值
    除非想要极其准确的导航网格
</br>

  - Min Region Area
  最小区域面积
  当面积小于此处值的导航网格区域会被移除
</br>

  - Height Mesh
  高度网格构建开关
    主要用来解决楼梯烘焙为斜坡时
    希望在楼梯表面的位置准确的放置在楼梯平面上
    而不是斜坡上

    启用它会增加烘焙时间
### 25.1.3 Areas导航地区页签
配合Object页签使用

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-19_18-43-18.jpg)

</center>

- Name: 区域名字
- Cost: 寻路消耗

### 25.1.4 Agents代理页签
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-19_18-47-36.jpg)

</center>

用于配置寻路代理信息

***
## 26. 导航网格寻路组件
寻路组件的作用就是帮助我们让角色可以在地形上准确的移动起来

寻路组件的本质就是根据烘焙出的寻路网格信息
通过基于A星寻路的算法计算出行进路径让我们在该路径上移动起来

### 26.1 相关参数
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-20_08-42-30.jpg)

</center>

- Agent Type: 代理类型, 配合Agents页签使用
</br>

- Base Offset: 基础偏移值，相对对象轴心点的高度偏移
</br>

- Steering: 移动设置
  - Speed: 寻路时的最大移动速度（世界单位/秒）
  - Angular Speed: 寻路时转身的最大旋转速度（度/秒）
  - Acceleration: 最大加速度（世界单位/平方秒）
  - Stopping Distance: 当靠近目标点多少距离时，停止运动
  - Auto Braking: 自动制动（减速）
    启用后，当到达目标时将减速，如果存在连续移动（比如巡逻移动）建议不要开启该选项
</br>

- Obstacle Avoidance: 避障设置
  - Radius: 半径，用于计算障碍物和其它寻路对象之间的碰撞
  - Height: 高度，通过头顶障碍物时用于计算高度间隙使用
  - Quality: 障碍躲避品质，越高躲避障碍越准确，但是性能消耗较大，如果不想主动避开其它动态障碍，可以设置为无，则只会解析碰撞
  - Priority: 优先级，0~99， 避障时，数字较小的障碍物表示较高的优先级
    优先级低的会忽略避障
</br>

- Path Finding: 路径寻找规则
  - Auto Traverse OffMesh Link: 是否开启自动遍历网格外的其它网格连接
    如果要自定义判断，则关闭此功能
  - Auto Repath: 是否开启自动重设路线
    如果开启，当到达路径后段时会再次尝试寻路，当没有到达目标的路径时，会生成一条到达与目标位置最近的可达点
  - Area Mask: 寻路时，考虑的区域
    如果寻路时不想考虑某些区域，则取消选中
    塔防游戏中常见的功能
</br>

### 26.2 代码控制
使用网格相关脚本需要引用命名空间 `UnityEngine.AI`

#### 26.2.1 常用内容

```CSharp
void Start()
{
    //自动寻路设置目标点
    agent.SetDestination()

    //停止寻路
    agent.isStopped = true;
}
```

#### 26.2.2 不常用内容

- 变量

```CSharp
void Start()
{
    //关键变量
    //1.面板参数相关 速度 加速度 旋转速度等等
    agent.speed
    agent.acceleration
    agent.angularSpeed

    //2.其它重要属性
    //2-1当前是否有路径
    agent.hasPath

    //2-2代理目标点 可以设置 也可以得到
    agent.destination

    //2-3是否停止 可以得到也可以设置
    agent.isStopped

    //2-4当前路径
    agent.path

    //2-5路径是否在计算中
    agent.pathPending

    //2-6路径状态
    agent.pathStatus

    //2-7是否更新位置
    agent.updatePosition = true;

    //2-8是否更新角度
    agent.updateRotation = true;

    //2-9代理速度
    agent.velocity
}
```

- 方法
```CSharp
void Start()
{
    //手动寻路
    //计算生成路径
    NavMeshPath path = new NavMeshPath();
    if( agent.CalculatePath(Vector3.zero, path) )
    {

    }

    //设置新路径
    if(agent.SetPath(path))
    {

    }

    //清除路径
    agent.ResetPath();

    //调整到指定点位置
    agent.Warp(Vector3.zero);
}
```
***
## 27. 导航网格外连接组件
我们在烘焙地形数据的时候
可以生成网格外连接
但是它是满足条件的都会生成
而且是要在编辑模式下生成

如果我们只希望两个未连接的平面之间只有有限条连接路径可以跳跃过去
并且运行时可以动态添加
就可以使用网格外连接组件
达到“指哪打哪”的效果

### 27.1 使用
1. 使用两个对象作为两个平面之间的连接点（起点和终点）
2. 添加Off Mesh Link脚本进行关联
3. 设置参数

### 27.2 相关参数
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-20_10-35-12.jpg)

</center>

- Start
起始点
</br>

- End
结束点
</br>

- Cost Override
覆盖消耗值
负数或0则使用所属Area区域中的消耗值
如果为正数，则使用Area区域寻路消耗值*正数代表该连接点的寻路消耗
相当于我们可以自定义连接点的寻路消耗
主要用来解决当有"步行"和连接点都可以到达某一个目标时，希望优先选择步行区域，但是步行路径明显更远时修改该值
</br>

- Bi Directional
是否开启双向连接点
开启后可以从Start到End，反之也可以
如果关闭，则只能Start到End
</br>

- Activated
是否启用该连接点
如果关闭，则自动寻路时相当于失效
</br>

- Auto Update Positions
是否自动更新位置
如果启用
当开始和结束位置改变时，导航网格也将更新
如果不启用，即使改变了开始结束位置，也会按照刚开始的位置进行计算

***
## 28. 导航网格动态障碍组件
在游戏中常常会有这样的一个功能
场景中有一道门，如果这道门没有被破坏是不能自动导航到门后场景的
只有当这道门被破坏了，才可以通过此处前往下一场景
而类似这样的物体本身是不需要进行寻路的所以没有必要为它添加NavMeshAgent脚本
这时就会使用动态障碍组件实现该功能

### 28.1 使用
1. 为需要进行动态阻挡的对象添加NavMeshObstacle组件
2. 设置相关参数
3. 代码逻辑控制其的移动或者显隐

### 28.2 相关参数
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-20_10-55-36.jpg)

</center>

- Shape: 动态障碍的形状
  - Capsule：胶囊
  - Box：盒状
</br>

- Carve：
是否开启雕刻功能
开启后，障碍物会在导航网格中挖一个孔，所谓挖孔就是会生成对应的网格信息，认为这篇区域无法前往
  如果动态障碍物是固定不动的，建议开启，比如阻碍物门木桶栅栏等等
  如果动态障碍物是频繁移动的，建议不开启该功能，比如汽车和玩家
  - Move Threshold：
  移动阈值
  当障碍物移动超过该距离时，会认为其为移动状态，会更新移动的孔
  - Time To Stationary：
  障碍物作为静止状态需要等待的时间，单位为秒
  当静止时间超过该值会认为真正静止了
  - Carve Only Stationary：
  只有在静止状态时才会计算孔