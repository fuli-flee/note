[toc]

***
# 一. 模型的制作过程

建模师:
① 建模 -> ② 展UV -> ③ 材质和纹理贴图
动作师:
④ 骨骼绑定 -> ⑥ 动画制作
***
# 二. 2D相关
***
## 1. 图片导入相关设置
### 1.1 概述
Unity支持的图片格式有很多
- BMP:是Windows操作系统的标准图像文件格式，特点是几乎不进行压缩，占磁盘空间大
</br>

- TIF:基本不损失图片信息的图片格式，缺点是体积大
</br>

- JPG:一般指JPEG格式，属于有损压缩格式，能够让图像压缩在很小的存储空间，一定程度上会损失图片数据，无透明通道
</br>

- PNG:无损压缩算法的位图格式，压缩比高，生成文件小，有透明通道
</br>

- TGA:支持压缩，使用不失真的压缩算法，还支持编码压缩。体积小，效果清晰，兼备BMP的图像质量和JPG的体积优势，有透明通道
</br>

- PSD:是PhotoShop（PS）图形处理软件专用的格式，通过一些第三方工具或自制工具可以直接将PSD界面转为UI界面
</br>

其它还支持
- EXR、GIF、HDR、IFF、PICT等等

其中Unity最常用的图片格式是
- JPG、PNG、TGA三种格式

***
#### 1.1.1 图片设置的6大部分

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_16-23-27.jpg)

</center>

1. 纹理类型
2. 纹理形状
3. 高级设置
4. 平铺拉伸
5. 平台设置
6. 预览窗口


***
### 1.2 纹理类型 (Texture Type)

#### 1.2.1 纹理类型主要是设置什么
设置纹理类型主要是为了让纹理图片有不同的主要用途, 指明其是用于哪项工作的纹理
***
#### 1.2.2 参数设置
<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_16-34-06.jpg)

</center>

**①Default**
默认纹理, 大部分导入的模型贴图都是该类型

名词解释:
[伽马颜色空间](https://docs.unity3d.org.cn/6000.0/Documentation/Manual/color-spaces.html)

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_16-36-14.jpg)
![alt text](/Unity/图片/Unity核心/Unity核心09-28_16-57-31.jpg)

</center>

`Alpha Source`

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_16-58-55.jpg)

</center>

**② Normal map**
法线贴图格式

法线贴图就是在原物体的凹凸表面的每个点上均作法线
法线就是垂直于某个点的切线的方向向量

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_17-07-19.jpg)
![alt text](/Unity/图片/Unity核心/Unity核心09-28_17-09-19.jpg)

</center>

**③ Editor GUI and Legacy GUI**
一般在编辑器中或者GUI上使用的纹理

**④ Sprite（2D and UI）**
2D游戏或者UGUI中使用的格式

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_17-14-40.jpg)

</center>

- **Sprite Mode**：图像中提取精灵图形的方式
  - Single：按原样使用精灵图像
  - Multiple：瓦片模式，如果是图集，使用该选项，可以在Sprite Editor编辑窗口自定义图片
  - Polygon：网格精灵模式
</br>

- **Pixels Per Unit**：世界空间中的一个距离单位对应多少像素
</br>

- **MeshType**：网格类型；只有Single和Multiple模式才支持
  - Full Rect：创建四边形，将精灵显示在四边形上
  - Tight：基于像素Alpha值来生成网格，更加贴合精灵图片的形状
    - 任何小于32*32的精灵都使用FullRect模式，即使设置成Tight模式也是
</br>

- Extrude Edges：使用滑动条确定生成的网格中精灵周围流出的区域大小
</br>

- **Pivot**：精灵图片的轴心点，Single模式才有此选项
  - 对应九宫格布局的九个点，还可以自定义
</br>

- **Generate Physics Shape**：启用此选项，Unity会自动根据精灵轮廓生成默认物理形状
  - 只有Single 和Multiple模式才可使用
</br>

- **Sprite Editor**：编辑Sprite，需要安装2D Sprite包

**⑤ Cursor**
自定义光标

**⑥ Cookie**
光源剪影格式

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_17-27-44.jpg)

</center>

- Light Type：应用的光源类型
    一般点光源的剪影需要设置为立方体纹理
    方向光和聚光灯的剪影设置为2D纹理

    - Spotlight：聚光灯类型，需要边缘纯黑色纹理
    - Directional：方向光，平铺纹理
    - Point：点光源，需要设置为立方体形状

**⑦ Lightmap**
光照贴图格式

**⑧ Single Channel**
纹理只需要单通道的格式

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_17-31-21.jpg)

</center>

- Channel：希望将纹理处理为Alpha还是Red通道
    - Alpha：使用Alpha通道，不允许进行压缩
    - Red：使用红色通道

*** 
### 1.3 纹理形状
纹理不仅可以用于模型贴图, 还可以用于制作天空盒与反射探针
纹理形状设置, 主要就是用于在两种模式之间进行切换

#### 1.3.1 参数

- ==Texture Shape==：纹理形状
  - ==2D==：2D纹理，最常用设置，这些纹理将使用到模型和GUI元素上
  - ==Cube==：立方体贴图，主要用于天空盒和反射探针

以下对于Cube的参数进行详细讲解
<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-29_08-56-55.jpg)

</center>

- Mapping：如何将纹理投影到游戏对象上
  - Auto：根据纹理信息创建布局
  - 6 Frames Layout：纹理包含标准立方体贴图布局之一排列的六个图像
  - Latitude-Longitude Layout：将纹理映射到2D维度/经度
  - Mirrored Ball：将纹理映射到类似球体的立方体贴图上
</br>

- Convolution Type：纹理的过滤类型
  - None：无过滤
  - Specular：将立方体作为反射探针
  - Diffuse：将纹理进行过滤表示辐照度，可作为光照探
</br>

- Fixup Edge Seams：Convolution Type 为None 和 Diffuse下才有用。解决低端设备上面之间立方体贴图过滤错误

***
### 1.4 纹理高级设置
<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-29_09-05-20.jpg)

</center>

***
#### 1.4.1 参数

>为什么纹理要设置为2的N次方？
>因为图形学规则，纹理必须是2的幂尺寸
- ==Non-Power of 2==：如果纹理尺寸非2的幂如何处理
  - ==None==：纹理尺寸大小保持不变
  - ==To nearest==：将纹理缩放到最接近2的幂的大小,（注意：PVRTC格式要求纹理为正方形）
  - ==To larger==：将纹理缩放到最大尺寸大小值的2的幂的大小
  - ==To smaller==：将纹理缩放到最小尺寸大小值的2的幂的大小
</br>

- ==Read/Write Enabled==：启用可以使用Unity中提供的一些方法从纹理中获取到数据（一般需要获取图片数据时才开启）
</br>

- Streaming Mipmaps：启用则可以使用纹理串流，主要用于在控制加载在内存中的Mipmap级别，用于减少Unity对于纹理所需的内存总量，用性能换内存
  - Mip Map Priority：Mipmap优先级，Unity根据优先级来确定分配资源时优先考虑哪些Mipmap
</br>

- ==Generate Mip Maps==：允许生成MipMap
  - Border Mip Maps：启用可避免颜色向外渗透到较低MIP级别的边缘
  - Mip Map Filtering：优化图像质量的过滤方法
    - Box：随着尺寸减小，级别更加平滑
    - Kaiser：随着Mipmap尺寸大小下降而使用的锐化算法，如果远处纹理太模糊，可以使用该算法
  - Mip Maps Preserve Coverage：Mipmap的Alpha通道在Alpha测试期间保留覆盖率
    - Alpha Cutoff Value：覆盖率参考值
  - Fadeout Mip Maps：级别递减时使Mipmap淡化为灰色

#### 1.4.2 什么是Mipmap?
先贴上我最喜欢的闫老师的课,讲的很清楚 [Lecture 09, 从43:24开始](https://www.bilibili.com/video/BV1X7411F744?spm_id_from=333.788.videopod.episodes&vd_source=e5ff09f1c2b416e099232ca31ec5028d&p=9)

开启MipMap功能后，Unity会帮助我们根据图片信息生成n张不同分辨率的图片
在场景中会根据我们离该模型的距离选择合适尺寸的图片用于渲染，提升渲染效率

***
### 1.5 平铺拉伸
<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-29_09-45-32.jpg)

</center>

#### 1.5.1 参数

- ==Wrap Mode==：平铺纹理时的方式
  - Repeat：在区块中重复纹理
  - Clamp：拉伸纹理的边缘
  - Mirror：在每个整数边界上镜像纹理以创建重复图案
  - Mirror Once：镜像纹理一次，然后将拉伸边缘纹理
  - Per-axis：单独控制如何在U轴和V轴上包裹纹理
</br>

- ==Filter Mode==：纹理在通过3D变化拉伸时如何进行过度
  - Point：纹理在靠近时变为块状
  - Bilinear：纹理在靠近时变得模糊
  - Trilinear：与Bilinear类似，但纹理也在不同的Mip级别之间模糊
</br>

- Aniso Level：以大角度查看纹理时提高纹理质量。性能消耗高

***
### 1.6 平台设置
<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-29_10-04-04.jpg)

</center>

平台设置主要设置纹理最终打包时在不同平台下的尺寸, 格式, 压缩方式
它影响了你包的大小和读取性能方面的问题, 所以非常重要
***
#### 1.6.1 参数

- ==Max Size==：设置导入的纹理的最大尺寸，即使美术出的很大的图，也可以通过这里把它们限制在一定范围内
</br>

- ==Resize Algorithm==：当纹理尺寸大于指定的Max Size时，使用的缩小算法
  - Mitchell：默认米切尔算法来调整大小，该算法是常用的尺寸缩小算法
  - Bilinear：使用双线性插值来调整大小。如果细节很重要的图片，可以使用它，它比米切尔算法保留的细节更多
</br>

- ==Format==：纹理格式, 各平台支持的格式有所不同, 如果选择Automatic, 会根据平台使用默认设置
  - [各平台纹理压缩格式, 这里贴了官方文档](https://docs.unity.cn/cn/2020.3/Manual/class-TextureImporterOverride.html)
  - IOS
    - 选择默认的纹理压缩设置 (PVRTC) 可获得更大的兼容性。
      如果您的应用程序不包含 OpenGL ES 2 支持，则可以选择一种 ASTC 格式。这些格式提供更好的质量和灵活性，并且压缩速度比 PVRTC 快。
  - Android
    - 由于安卓设备众多，设备标准都不同意，一般会根据不同的设备标准制作多个安装包
</br>

- ==Compression==：选择纹理的压缩类型，帮助Unity正确选择压缩格式, 会根据平台和压缩格式的可用性进行压缩
  - None：不压缩纹理
  - Low Quality：以低质量格式压缩纹理
  - Normal Quality：以标准格式压缩纹理
  - High Quality：以高质量格式压缩纹理
</br>

- ==Use Crunch Compression==：启用后，使用Crunch压缩。Crunch是一种基于DXT或ETC纹理压缩的有损压缩格式。压缩时间长，解压速度快。
  - 压缩质量，质量越高意味着纹理越大，压缩时间越长
</br>

- ==Split Alpha Channel==：Alpha通道分离，节约内存。会把一张图分成两张纹理。一张包含RGB数据，一张包含Alpha数据，在渲染时再合并渲染。
</br>

- ==Override ETC2 fallback==：不支持ETC2压缩的设备上，使用的格式
</br>

关于双线性插值, 还是闫老师的课, [还是Lecture 09, 22:45](https://www.bilibili.com/video/BV1X7411F744/?spm_id_from=333.788.videopod.episodes&vd_source=e5ff09f1c2b416e099232ca31ec5028d&p=9)

***
## 2. Sprite

### 2.1 Sprite Editor
精灵图片编辑器
它主要用于编辑2D游戏开发中使用的Sprite精灵图片
它可以用于编辑图集中提取元素, 设置精灵边框, 设置九宫格, 设置轴心(中心)点等功能 

如果你的项目是创建时是3D项目的话, 得在PackageManager里下载2D Sprite包
***
#### 2.1.1 Single图片编辑

左上角
<center>

![左上](/Unity/图片/Unity核心/Unity核心09-29_10-50-58.jpg)

</center>

**①Sprite Editor**
<center>

![右下](/Unity/图片/Unity核心/Unity核心09-29_10-43-29.jpg)

</center>

- Position：在图片中的偏移位置和宽高
- Border：边框，用于设置九宫格的4条边
- Pivot：轴心（中心）点位置
- Pivot Unit Mode：轴心点单位模式
  - Normalized：标准化模式，0~1
  - Pixels：像素模式
- Custom Pivot：自定义轴心点

**②Custom Outline (决定渲染区域)**
自定义边缘线, 自定义物理形状
<center>

![右下](/Unity/图片/Unity核心/Unity核心09-29_10-58-35.jpg)

</center>

- Snap：将控制点贴近在最近的像素
- Outline Tolerance：轮廓点的复杂性和准确性，0~1, 值越大轮廓点越多，越准确
- Generate：生成网格轮廓

**③ Custom Physics Shape (决定碰撞判断区域)**
自定义精灵图片的物理形状, 主要用于设置需要物理碰撞判断的2D图片
它决定了之后产生碰撞检测的区域

**④ Secondary Textures (为图片添加特殊效果)**
次要纹理设置, 可以将其他纹理和该精灵图片关联
着色器可以得到这些辅助纹理, 然后用于做一些效果处理, 让精灵应用其他效果

***
#### 2.1.2 Multiple图集元素分割
当我们的图片资源是图集时, 我们需要将其Sprite Mode设置为Multiple
这时就可以使用Sprite Editor自带的功能进行图集元素分割

**①自动分割**
Type 选中 Automatic

<center>

![右下](/Unity/图片/Unity核心/Unity核心09-29_11-13-44.jpg)

</center>

- Pivot：单张图片轴心点位置
- Custom Pivot：自定义轴心点
- Method：如何处理现有对象
  - Delete Existing：替换掉已经选择的任何矩形
  - Smart：尝试创建新矩形同时保留或调整现有矩形
  - Safe：添加新矩形而不更改任何已经存在的矩形

**②按单位大小分割**
Type 选中 Grid By Cell Size

<center>

![右下](/Unity/图片/Unity核心/Unity核心09-29_11-18-07.jpg)

</center>

- Pixel Size：单元格宽高
- Offset：偏移位置
- Padding：和边缘的偏移位置
- Keep Empty Rects：是否保留空矩形

**③按单元格数量分割**
Type 选中 Grid By Cell Count
<center>

![右下](/Unity/图片/Unity核心/Unity核心09-29_11-55-55.jpg)

</center>

- Column & Row：行列数

***
#### 2.1.3 Polygon多边形编辑

如果我们使用的资源时多边形资源 
我们可以在设置时将模式设置为Polygon
然后可以在Sprite Editor中进行快捷设置

这个很简单,只需要设置你要的多边形边数(0 ~ 128), 生成对应的多边形用来切割和设置渲染范围 

***
### 2.2 Sprite Renderer
Sprite Renderer是精灵渲染器
所有2D游戏中游戏资源（除UI外）都是通过Sprite Renderer让我们看到的
它是2D游戏开发中的一个极为重要的组件

#### 2.2.1 2D对象的创建
三种方式

1. 直接拖拽 Texture Type 为 Sprites(2D and UI) 的 Sprite 图片到场景中
2. 右键创建: 2D Object -> Sprite -> 关联一个Sprite
3. 创建一个空物体, 添加 Sprite Renderer


#### 2.2.2 参数
<center>

![右下](/Unity/图片/Unity核心/Unity核心09-29_14-46-24.jpg)

</center>

- ==Sprite==：渲染的精灵图片
</br>

- Color：定义着色，一般没有特殊需求不会修改
</br>

- Filp：水平或竖直翻转精灵图片
</br>

- ==Draw Mode==：绘制模式，当尺寸变化时的缩放方式
  - ==Simple==：简单模式，缩放时整个图像一起缩放
  - ==Sliced==：切片模式，9宫格切片模式，十字区域缩放，4个角不变化
    - 一般用于变化不大的纯色图（注意：需要把精灵的网格类型设置为Full Rect）
  - ==Tiled==：平铺模式，将中间部分进行平铺而不是缩放（注意：需要把精灵的网格类型设置为Full Rect）
    - ==Continuous==：当尺寸变化时，中间部分将均匀平铺
    - ==Adaptive==：当尺寸变化时，类似Simple模式，当更改尺寸达到Stretch Value时，中间才开始平铺
</br>

- ==Mask Interaction==：与精灵遮罩交互时的方式
  - ==None==：不与场景中任何精灵遮罩交互
  - ==Visible inside Mask==：精灵遮罩覆盖的地方可见，而遮罩外部不可见
  - ==Visible Outside Mask==：精灵遮罩外部的地方可见，而遮罩覆盖处不可见
</br>

- Sprite Sort Point：计算摄像机和精灵之间距离时，使用精灵中心Center还是轴心点Pivot，一般情况下不用修改
</br>

- Material：材质，可以使用一些自定义材质来显示一些特殊效果
  - 一般情况不修改。默认材质是不会受到光照影响的，如果想要受光照影响，可以选择Default-Diffuse
</br>

- ==Additional Settings==：高级设置
  - ==Sorting Layer==：排序层选择
  - ==Order in Laye==r：层级序列号，数值越大约会显示在前面
</br>


#### 2.2.3 代码设置

**① 获取Sprite Renderer**
```CSharp
GameObject obj = new GameObject();
SpriteRenderer sr = obj.AddComponent<SpriteRenderer>();
```

**② 动态的改变图片**
```CSharp
sr.sprite = Resources.Load<Sprite>("dead1");
//别忘了, 这种加载方式的前提是你把资源放在了Resources文件夹下了
```

**③ 动态的加载 图集中的图**

```CSharp
Sprite[] sprs = Resources.LoadAll<Sprite>("RobotBoyIdleSprite");
sr.sprite = sprs[10];
```

***
### 2.3. Sprite Mask
> Hierarchy窗口右键 => 2D Object => Sprite Mask


精灵遮罩, 它的主要作用就是对精灵图片产生遮罩
制作一些特殊的功能，比如只显示图片的一部分让玩家看到

想要遮罩生效, 需要设置Sprite Renderer中的Mask Interaction

<center>

![右下](/Unity/图片/Unity核心/Unity核心09-30_08-42-18.jpg)

</center>

- Sprite：遮罩图片
- Alpha Cutoff：如果Alpha包含透明区域和不透明区域之间的混合（半透明），则可以手动确定所显示区域的分界点（0~1）
- Custom Range：自定义遮罩范围, 开启后可以设置遮罩的范围，按照排序层来划分
  - 只有与 Mask 同 Sorting Layer，且 Order in Layer 落在 Front/Back 对应的范围内的 Sprite，才会被遮罩影响。
    - Front：遮罩「同层且 Order 比自己大」的 Sprite（前面的）
    - Back：遮罩「同层且 Order 比自己小」的 Sprite（后面的）

举个例子: 我设置了一个新的 Sorting Layer 叫 Test, 排在 Default 层以上
我设置了Mask中的front和back如下图

<center>

![右下](/Unity/图片/Unity核心/Unity核心09-30_09-27-45.jpg)

</center>

那么我在Sprite Renderer中分别将Sorting Layer和Order Layer设置为
- (Default, 0)是没有效果的, (Default, 1)是有效果的 
- (Test, 0)是有效果的, (Test, 1)是有效果的, (Test, 2)是没效果的

*** 

### 2.4 Sorting Group
排序分组, 它的主要作用就是对多个精灵图片进行分组排序
Unity会将同一个排序组中的精灵图片一起排序，就好像他们是单个游戏对象一样
主要作用是对于需要分层的2D游戏用于整体排序

- 注意事项
  1. 子排序组，先排子对象 再按父对象和别人一起排 （同层和同层比）
  2. 多个 挂载排序分组组件的预设体 之间 通过修改 排序索引号来决定前后顺序

***

### 2.5  Sprite Atlas 精灵图集

#### 2.5.1 图集
打图集的目的就是减少DrawCall 提高性能

#### 2.5.2 在Unity中打开自带的打图集功能
[同样的内容在UGUI.md中的第18条写得更加详细](/Unity/UGUI.md)

在工程设置面板中打开功能

> Edit——>Project Setting——>Editor

Sprite Packer(精灵包装器，可以通过Unity自带图集工具生成图集)
Disabled：默认设置，不会打包图集

- Enabled For Builds（Legacy Sprite Packer）：Unity仅在构建时打包图集，在编辑模式下不会打包图集
- Always Enabled（Legacy Sprite Packer）：Unity在构建时打包图集，在编辑模式下运行前会打包图集

- Legacy Sprite Packer传统打包模式 相对下面两种模式来说 多了一个设置图片之间的间隔距离
- Padding Power:选择打包算法在计算打包的精灵之间以及精灵与生成的图集边缘之间的间隔距离, 这里的数字 代表2的n次方

- Enabled For Build：Unity进在构建时打包图集，在编辑器模式下不会打包
- Always Enabled：Unity在构建时打包图集，在编辑模式下运行前会打包图集

#### 2.5.3 相关参数

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_11-17-43.jpg)

</center>

- Type：图集类型
  - Master：主图集

    - Include in Build：选中可以在当前构建中包含图集

    - Allow Rotation：选中此选项将在打包图集时对图片元素进行旋转，可以最大限度提高组合后的图集密度；注意！！！如果是UI图集，请禁用此选项，因为打包时会将场景中UI元素旋转

    - Tight Packing：选中此选项在打包图集时使用图片轮廓来打包而不是根据矩形，可以最大限度提高组合后的图集密度

    - Alpha Dilation（Alpha 扩张）是用于解决精灵边缘渲染异常的优化设置，主要作用是避免图集打包后精灵边缘出现黑边、透明像素或采样错误。

    - Padding：图集中各图片的间隔像素
  - Variant：变体类型的图集

    - Master Atlas：关联的主图集（图集类型必须是Master）

    - Include in Build：选中可以在当前构建中包含图集

    - Scale：设置变体图集的缩放因子（0~1），变体图集的大小是主图集乘以Scale的结果

变体图集的主要作用是以主图集为基础，对它进行缩放产生一个新的图集副本。如果想使用变体图集中的内容，只需要勾选变体图集的Include in build选项，而主图集禁用此选项即可

- Read/Write Enabled：允许通过脚本访问纹理数据。如果启用，会创建纹理数据的副本。会让内存翻倍，一般情况下不需要开启它
- Generate Mip Maps：勾选它会生成Mipmap；Mipmap是一种性能优化手段，用内存换性能。一般情况下不用开启
- SRGB：启用此属性可指定将纹理存储在伽马空间中。对于非 HDR 颜色纹理（例如反照率和镜面反射颜色），应始终选中此复选框。如果纹理存储了有特定含义的信息，并且您需要着色器中的确切值（例如，平滑度或金属度），请禁用此属性。默认情况下会启用此属性。
</br>

- Filter Mode：纹理在3D变化拉伸时如何进行过滤
  - Point：纹理靠近时变为块状
  - Bilinear：纹理靠近时变得模糊
  - Trilinear：与Bilinear类似，但是纹理在不同的MIP级别之间模糊
</br>

- Objects for Packing：关联需要打图集的图片们，注意：一定是Sprite类型的图片
</br>

- Default
  - Max Texture Size：纹理的最大尺寸，像素为单位
  - Format：指定纹理的内部表示，在不同平台上会有不同的参数
  - Compression：纹理压缩类型
    - 不压缩
    - 低质量
    - 普通质量
    - 高质量
    - 质量越高占用内存越多，不压缩质量最好
  - Use Crunch Compression：使用Crunch压缩，是一种有损压缩格式，压缩耗时长，但是运行时解压速度快
  - Compressor Quality：压缩质量，质量越高纹理越大，耗时越长
#### 2.5.4 代码控制
```CSharp
GameObject obj = new GameObject();
SpriteRenderer sr = obj.AddComponent<SpriteRenderer>();
//加载图集资源
SpriteAtlas spriteAtlas = Resources.Load<SpriteAtlas>("MyAtlas");
//加载图集资源中的某一张小图
sr.sprite = spriteAtlas.GetSprite("dead1");
```
***
## 3. 2D物理系统

### 3.1 刚体

#### 3.1.1 2D物理系统中的刚体组件
刚体是物理系统中用于帮助我们进行模拟物理碰撞中力的效果的

2D物理系统中的刚体和3D中的刚体基本是一样的
最大的区别是对象只会在XY平面中移动，并且只在垂直于该平面的轴上旋转

#### 3.1.2 相关参数
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_15-31-28.jpg)

</center>

- Dynamic：动态类型, 受重力和力的影响移动和旋转
  - Material：物理材质，在刚体上设置了物理材质，如果子物体有碰撞器但是没有设置材质则会通用刚体的物理材质
    - 如果不设置，将使用在Physics 2D窗口中设置的默认材质
      物理材质的使用优先级：
      1. 2D碰撞器上指定的2D物理材质
      2. 2D刚体上指定的2D物理材质
      3. Physics 2D窗口指定的2D默认物理材质
  - Simulated：如果希望2D刚体以及所有子对象2D碰撞器和2D关节都能模拟物理效果, 需要启用该选项
  - Use Auto Mass：是否使用自动质量
  - Mass：质量
  - Linear Dray：影响位置移动的阻力系数
  - Angular Drag：影响旋转移动的阻力系数
  - Gravity Scale：受重力影响的程度
  - Collision Detection：碰撞检测算法
    - Discrete：离散检测算法，只会用新位置进行计算，速度过快时会穿过
    - Continuous：连续检测算法，计算量更大，但是不会发生穿过的情况
  - Sleeping Mode：对象处于静止状态时进入睡眠模式
    - Never Sleep：从不休眠，会一直进行检测计算，性能消耗较大
    - Start Awake：最初处于唤醒状态
    - Start Asleep：最初处于睡眠状态，但是可以被碰撞唤醒
  - Interpolate：物理更新间隔之间的插值运算
    - None：不应用移动平滑
    - Interpolate：根据前一帧进行平滑处理
    - Extrapolate：根据后一帧位置进行平滑处理
  - Constraints：约束限制, 可以让某一个轴不受力影响位移或者旋转
</br>

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_15-31-58.jpg)

</center>

- Kinematic：运动学类型, 不受力的影响，只能通过代码让其动起来, 能和Dynamic 2D刚体产生碰撞，但是不会动，
  只会进入碰撞检测函数, 因此它没有了质量摩擦系数等属性
  因此它的性能能消耗较低，主要会通过代码来处理其移动旋转
  - Simulated：
    如果希望2D刚体以及所有子对象2D碰撞器和2D关节都能模拟物理效果, 需要启用该选项
    当启用时，会充当一个无限质量的不可移动对象，可以和所有2D刚体产生碰撞
    如果Use Full Kinematic Contacts禁用，它只会和Dynamic 2D刚体碰撞
  - Use Full Kinematic Contacts：如果希望能和所有2D刚体碰撞，启用它
    如果不启用，它不会和Kinematic 2D和Static 2D刚体碰撞
</br>

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_15-32-19.jpg)

</center>

- Static：静态类型
  完全不动的需要检测碰撞的对象
  相当于是无限质量不可移动的对象
  它的性能消耗最小，它只能和Dynamic 2D刚体碰撞

  和它类似的有只加碰撞器而不加刚体的物体, 它们会和刚体物体产生碰撞，但是自己不会动
</br>

#### 3.1.3 如何选择不同类型的刚体
- Dynamic动态刚体：受力的作用，要动要碰撞的对象

- Kinematic运动学刚体：通过刚体API移动的对象，不受力的作用，但是想要进行碰撞检测 

- Static静态刚体：不动不受力作用的静态物体，但是想要进行碰撞检测 

上面还是很抽象, 我来告诉他们会用在哪些场景
1. 动态刚体最常用, 像是《超级马里奥》这类平台跳跃游戏中，**马里奥**就是一个典型的 Dynamic 动态刚体。他会受到重力的影响而下落，当玩家按下跳跃键时，会给马里奥施加一个向上的力，使其能够跳跃。同时，当马里奥与场景中的平台、敌人等物体碰撞时，会根据物理规则产生相应的反应，如反弹、被击退等。
2. 运动学刚体, 在一些游戏中，**电梯**通常是用 Kinematic 运动学刚体来实现的。电梯本身不受重力和其他物理力的影响，它的运动是通过脚本控制其位置和速度来实现的，比如当玩家进入电梯后，按下上升或下降的按钮，电梯会按照预设的速度和路径进行移动。但电梯又需要与玩家和其他物体进行碰撞检测，以确保玩家能够正确地进入和离开电梯，以及避免其他物体穿过电梯。
3. 静态刚体, 在各种平台跳跃游戏中，固定的**平台**就是 Static 静态刚体。这些平台不会移动，也不受任何物理力的作用，但它们为 Dynamic 动态刚体的角色提供了支撑和碰撞检测的表面，角色可以在平台上站立、跳跃和行走，当角色与平台碰撞时，会按照物理规则进行交互。

#### 3.1.4 刚体API
[看 Unity入门.md 的22条](/Unity/入门.md)

- 加力
```CSharp
Rigidbody2D rigid = this.GetComponent<Rigidbody2D>();
rigid.AddForce(new Vector2(0, 100));
```

- 速度
```CSharp
rigid.velocity = new Vector2(1, 0);
```
***
### 3.2 碰撞器 

碰撞器是用于在物理系统中 表示物体体积的的（形状或范围）
刚体通过得到碰撞器的范围信息进行计算
判断两个物体的范围是否接触
如果接触 刚体就会模拟力的效果产生速度和旋转

#### 3.2.1 2D碰撞器
1. 圆形碰撞器

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_21-13-45.jpg)

</center>

- Material：一种物理材质，用于确定碰撞的属性，控制摩擦和弹性
- Is Trigger：是否是触发器
- Used By Effector：是否被附加的2D效应器使用
- Offset：圆心偏移位置
- Radius：圆形的半径

2. 盒状碰撞器

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_20-58-19.jpg)

</center>

- Used by Composite: 如果勾选, 则该碰撞器将附加到2D复合碰撞器中使用
- Auto Tiling: 如果精灵渲染器组件的Draw Mode设置为Tiled平铺模式, 勾选该选项后, 当改变精灵大小时将自动更新碰撞器的尺寸
- Size: 矩形的宽高
- Edge Radius: 使四个顶点为圆角

3. 多边形碰撞器

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_21-14-08.jpg)

</center>


- Points：多边形顶点
  虽然可以手动修改，但是一般情况下 我们通过数值编辑太复杂了
  都通过Edit Collider编辑，或者让Unity自动识别创建

4. 边界碰撞器

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_21-14-55.jpg)

</center>

边界碰撞器的编辑主要还是通过Edit Collider, 一般不会手动去通过数值加点


5. 胶囊碰撞器

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_21-15-35.jpg)

</center>

- Size：胶囊的宽高
- Direction：是竖直胶囊还是水平胶囊

6. 复合碰撞器

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_21-16-35.jpg)

</center>

- Geometry Type：几何学类型，合并碰撞体时，碰撞体顶点将组合为两种不同的几何体类型
  - Outlines：空心轮廓，类似边界碰撞器
  - Polygons：实心多边形，类似多边形碰撞器
- Generation Type：生成类型，复合碰撞器在何时生成新几何体
  - Synchronous：对2D复合碰撞器或使用的其它碰撞器修改时，Unity立即生成新几何体
  - Manual：手动生成新几何体，通过代码生成或者点击下发的Regenerate Geometry生成按钮
- Vertex Distance：从复合碰撞器收集顶点时允许的最小间距值

#### 3.2.2 碰撞检测函数
[详细的看Unity入门.md的21.2](/Unity/入门.md)

碰撞检测函数 和 3D碰撞检测函数除了名字不同外其他基本一致

***
### 3.3 物理材质
物理材质是用于决定在物体产生碰撞时这些物体之间的摩擦和弹性表现的
通过物理材质我们可以做出类似 斜坡不滑落，小球反弹等效果

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_11-36-42.jpg)

</center>

#### 3.3.1 相关参数
Friction：摩擦系数，为0表示没有摩擦力
Bounciness：反弹程度。0表示没有弹力，1表示完美弹力（没有能量损失一直弹）

***
### 3.4 恒定力
恒定力是一个特殊的脚本
它可以给一个2D刚体持续添加一个力
在做一些随着时间推移而加速的对象时很适用
比如类似火箭发射等效果

恒定力脚本会线性的为对象添加力和扭矩力 让其移动和旋转

#### 3.4.1 相关参数

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_16-26-02.jpg)

</center>

- Force：物理更新时施加于2D刚体上的线性力
- Relative Force：物理更新时施加的线性力（相对刚体对象坐标系）
- Torque：物理更新时施加于2D刚体的扭矩力

*** 
### 3.5 效应器

**使用效应器需要将 Collider 中的 Used By Effector 开启, Is Trigger 视情况开启**

2D效应器是配合2D碰撞器一起使用
可以让游戏对象在相互接触时产生一些特殊的物理作用力
可以通过2D效应器
快捷的实现一些
传送带 互斥 吸引 漂浮 单向碰撞等等效果

#### 3.5.1 区域效应器

主要作用：在一个区域内让游戏对象受到力和扭矩力的作用

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_16-41-19.jpg)

</center>

- Use Collider Mask：是否启用碰撞器遮罩，如果开启才会出现下面的Collider - Mask，可以通过选择层，决定该效应器只会作用于哪些层的对象

- Use Global Angle：勾选将使用世界坐标系角度，如果不勾选，角度为局部角度
- Force Angle：施加力的角度
- Force Magnitude：施加力的大小
- Force Variation：施加力的随机大小变化 会在Force Magnitude基础上根据该值进行随机变化

- ForceTarget：效应器在目标对象上施加力的作用点
	- Collider：以碰撞器的当前位置（如果碰撞器有偏移，没有位于质心，可能会产生扭矩力，带来旋转）
	- Rigidbody：以刚体的当前质心（不会产生扭矩力）

- Drag：阻力
- Angular Drag：扭矩阻力

#### 3.5.2 浮力效应器
主要作用：模拟流体行为，浮动和阻力相关设置，让玩家在该区域看起来像在水里移动
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_16-49-50.jpg)

</center>


- Density：流体密度，密度较大，碰撞体会下沉，密度越小碰撞体会上浮
密度和流体相同的碰撞体会浮在流体中

- Surface Level：定义浮力流体的表面位置，对象高于此线时，不会对其施加浮力，以下或者相交会施加浮力。沿世界Y轴偏移

- Linear Drag：影响对象在水中移动的阻力系数
- Angular Drag：影响对象在水中旋转的阻力系数

- Flow Angle：流体流动方向相对世界控件的角度，沿指定方向施加浮力
- Flow Magnitude：与FlowAngle结合使用，前者决定力的角度，该值确定浮力大小
- Flow Variation：随机改变流体力的值

#### 3.5.3 点效应器
主要作用：模拟磁铁 吸引或者排斥的效果

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_16-54-57.jpg)

</center>


- Force Magnitude：施加力的大小
- Force Variation：施加力的大小变化
- Distance Scale：效应器和目标之间举例的缩放。计算距离时，会按该比值对距离进行缩放

- Force Source：力源来自哪个位置，从该点计算距离。
	- Collider：碰撞器的位置
	- Rigidbody：刚体的位置

- Force Target：作用力目标位置，用改点计算位置
	- Collider：碰撞器的位置，如果碰撞器有偏移，可能会产生扭矩力
	- Rigidbody：刚体的位置，不会产生扭矩力

- Force Mode：计算力的模式
	- Constant：忽略源和目标之间相隔的距离
	- Inverse Linear：反线性距离计算，距离越远，力的大小呈线性减小
	- Inverse Squared：反平方距离计算，力的大小呈指数减小（按平方下降），类似现实世界重力

#### 3.5.4 平台效应器
主要作用：2D游戏当中的平台或可往上跳跃的墙壁

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_17-03-21.jpg)

</center>

- Rotational Offset：旋转偏移量，控制平台角度偏移

- Use One Way：是否使用单向碰撞行为
- Use One Way Grouping：当平台式有多个碰撞器组合时，可以通过它将所有碰撞器设置为单向碰撞行为
- Surface Arc：以局部坐标系下向上的方向为中心，填写一个角度值，定义不允许通过的表面，该角度外的其它地方视为单向碰撞

- Use Side Friction：是否应该在平台两侧使用摩擦
- Use Side Bounce：是否应该在平台两侧使用弹性
- Side Arc：用于定义左右两侧平台的响应弧度

#### 3.5.5 表面效应器

主要作用：模拟传送带

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_17-35-28.jpg)

</center>

- Speed：表面保持的速度
- Speed Variation：速度的随机增加值

- Force Scale：缩放沿表面移动时施加的力。如果是0表示不施加力，相当于禁用。值越低越慢，值越高越快，建议不要设置为1，因为当设置为1时可能会抵消施加在物体上的其它力，比如跳跃的力

- Use Contact Force：是否对接触物体表面的出点施加力，如果选择会让对象旋转，如果不开启则不会旋转
- Use Friction：是否使用摩擦力
- Use Bounce：是否使用弹力

***
## 4. SpriteShape

### 4.1 Sprite Shape Profile
精灵形状概述文件

它主要是方便我们以节约美术资源为前提, 制作2D游戏场景地形或者背景的

#### 4.1.1 导入SpriteShape工具
在Package Manager中导入相关工具

#### 4.1.2 相关参数

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_18-01-21.jpg)
![alt text](/Unity/图片/Unity核心/Unity核心10-12_18-02-11.jpg)

</center>

- Use Sprite Borders：是否使用精灵边框，用于九宫格拉伸
- Texture：用于填充实心部分的纹理（使用的纹理的平铺模式必须是Repeat重复模式）
- Offset：纹理偏移量
</br>

  这里的设置主要用于封闭图形
  在不同角度范围内使用的图片不同
  可以达到一个封闭效果

- Angle Ranges：角度范围
- Start：起始角度
- End：结束角度
- Order：Sprite相交时的优先级，优先级高的显示在前面
</br>

- Sprites：指定角度范围内的精灵列表
  在该角度范围内，可以选择使用的图片资源
</br>

- Corners：指定角显示的精灵图片, 主要用于封闭图形
  外部四个角用的图片
  内部四个角用的图片

***
### 4.2 Sprite Shape Renderer与Sprite Shape Controller
精灵形状渲染器和控制器

#### 4.2.1 Sprite Shape Renderer相关参数
该控件主要是控制 材质 颜色 以及和其它Sprite交互时的排序等等信息
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_20-08-11.jpg)

</center>

- Color：颜色
- Mask Interaction：遮罩相互作用规则设置
- Fill Material和Edge Material：填充材质和边缘材质
- Sorting Layer和Order in Layer：排序相关

#### 4.2.2 Sprite Shape Controller相关参数

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_20-08-30.jpg)

</center>

- Profile：使用的精灵形状概述文件
- Detail：精灵形状的质量, 高中低三种质量
- Is Open Ended：是否是开放的，不封闭的
- Adaptive UV：自适应UV，如果开启，会自动帮助我们判断是平铺还是拉伸
  开启后只有宽度够才会平铺，如果宽度不够会拉伸
  不开启始终平铺，但是可能会出现裁剪效果
  一般根据你的实际效果进行选择
</br>

- Optimize Geometry：优化三角形数量，勾选后会最小化精灵图形中的三角形数量

- Enable Tangents：是否启用切线计算功能
  如果你的着色器中需要切线信息参与计算，则勾选
</br>

- Corner Threshold：角阈值，当拐角处的角度达到这个阈值时将使用角图片
- Stretch UV：是否拉伸UV，如果勾选纹理的UV将伸展到整个精灵形状的直线上
- Pixel Per Unit：禁用拉伸UV时才有，Unity单位对应多少像素，较高的值会较少纹理的大小
- Worldspace UV：根据世界控件的UV填充纹理
</br>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_20-12-01.jpg)**启用编辑状态后**
- Tangent Mode ：切线模式
  从左至右依次是：
  顶点模式-点两侧不构成曲线
  切线模式-点两侧构成曲线，并且可以控制切线弧度
  左右切线模式-点两侧构成曲线，并且可以分别控制左右两侧切线弧度
</br>

- Position：选中点的局部坐标位置
- Height：控制点左右两侧精灵图片的高度
- Corner：是否使用角度图片
  - Disabled：不使用角度图片
  - Automatic：自动
- Sprite Variant：选择使用的精灵图片
- Snapping：是否开启捕捉设置控制点

#### 4.2.3 生成碰撞器
1. 使用边界碰撞器
2. 使用多边形 碰撞器 配合复合碰撞器

***
## 5. Tilemap
Tilemap一般称之为 瓦片地图或者平铺地图, 是Unity2017中新增的功能
主要用于快速编辑2D游戏中的场景
通过复用资源的形式提升地图多样性

工作原理就是用一张张的小图排列组合为一张大地图

**它和SpriteShape的异同**
- 共同点
他们都是用于制作2D游戏的场景或地图的
- 不同点
  1. SpriteShape可以让地形有弧度,TileMap不行
  2. TileMap可以快捷制作有伪“Z”轴的地图，SpriteShape不行


### 5.1 瓦片资源

#### 5.1.1 创建瓦片资源
方法一：
> Assets => Create => Tile

方法二：
在Tile Palette瓦片调色板窗口创建
1. 首先新建一个瓦片地图编辑文件
2. 将资源拖入到窗口中选择要保存的路径

#### 5.1.2 相关参数

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-00-50.jpg)

</center>

- Preview：预览图
- Sprite：瓦片关联的精灵纹理
- Color：瓦片色调颜色
- Collider Type：碰撞器类型
	- None：不生成碰撞器
	- Sprite：基于精灵轮廓生成碰撞器形状
	- Grid：基于瓦片单元格生成碰撞器形状

*** 
### 5.2 瓦片调色板窗口
> Window => 2D => Tile Palette

#### 5.2.1 创建新调色板相关参数

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-12-33.jpg)

</center>

- Name：瓦片调色器名称
- Grid：瓦片的网格布局
	- Rectangle：矩形瓦片
	- Hexagon：六边形瓦片
	- Isometric：等距瓦片，单元格为菱形
	- Isometric Z as Y：等距瓦片并且Unity将单元格Z轴转换为局部Y坐标
- Hexagon Type：六边形瓦片地图类型
	- Point Top：点朝顶部的六边形
	- Flat Top：面朝顶部的六边形
- Cell Size：瓦片绘制到单元格的大小
	- Automatic：基于瓦片资源的精灵大小自动设置
	- Manual：自定义大小


<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-05-27.jpg)

</center>

#### 5.2.2 基础操作 
- 单击瓦片 => 选择瓦片
- 在多个瓦片上移动 => 选择多个瓦片
- Alt+左键拖动 => 平移
- 滚轮键拖动 => 平移
- 旋转滚轮键 => 放大/缩小

#### 5.2.3 面板相关
- ![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-27-32.jpg)瓦片地图中有多层时，可以再这里选择层级进行绘制
- ![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-28-17.jpg)选择工具（S）
- ![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-29-03.jpg)移动工具（M）
- ![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-31-06.jpg)画笔工具（B）, 使用选取器后会自动切换到画笔工具，单个填充
- ![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-31-35.jpg)框填工具（U）, 使用选取器后再切换到框填工具，范围填充
- ![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-32-04.jpg)选取器工具（I）, 选取填充样本
- ![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-32-20.jpg)橡皮擦工具（D或者使用画笔工具时按住Shift）, 单个擦除
- ![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-32-37.jpg)填充工具（G）, 使用选取器后再切换到填充工具，批量填充

#### 5.2.4 编辑瓦片地图
方法一：通过瓦片调色板文件创建
方法二：直接在场景中进行创建(常用)

矩形瓦片地图用于做横版游戏地图
六边形瓦片地图用于做策略游戏地图
等距瓦片地图用于做有"Z"轴的2D游戏

注意：
在编辑等距瓦片地图时
1. 需要修改工程的自定义轴排序 以Y轴决定渲染顺序
> Edit => Project Settings => Graphics
> Transparency Sort Axis中的数值是官方推荐数值

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_21-56-13.jpg)

</center>

2. 如果地图存在前后关系需要修改TileRenderer的渲染模式
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_22-02-19.jpg)

</center>

3. 可以通过Z轴偏移来控制绘制单个瓦片时的高度

> 选中瓦片再在Scene窗口绘制时, 勾选调色板下方的 Can Change Z Position
> 此时按"+"和"-"来调节高度

4. 精灵纹理的中心点会影响最终的显示效果

***
### 5.3 瓦片地图关键脚本和碰撞器

#### 5.3.1 Grid

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_22-15-03.jpg)

</center>

- Cell Size：网格单元格的大小
- Cell Gap：网格之间的间隔大小
- Cell Layout：网格单元的形状和排列
  - Rectangle：矩形
  - Hexagon：六边形
  - Isometric：等距布局，单元格为菱形
  - Isometric Z as Y：等距布局，但Unity将单元格Z轴转换为局部Y坐标
- Cell Swizzle：Unity将XYZ单元格坐标重新排序为你选择的类型

#### 5.3.2 TileMap
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_22-21-39.jpg)

</center>

- Animation Frame Rate：Unity播放瓦片动画的速率。相当于倍速
- Color：瓦片色调颜色
- Tile Anchor：瓦片的锚点偏移
- Orientation：瓦片地图上瓦片的方向。相当于2D平面使用的是Unity中的哪两个轴

#### 5.3.3 TileMapRenderer

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_22-22-48.jpg)

</center>

- Sort Order：设置所选瓦片地图上的瓦片排序方向
- Mode：渲染器的渲染模式
	- Chunk：按位置对瓦片进行分组，并将瓦片精灵一起批处理进行渲染，性能较好
	- Individual：单独渲染每个瓦片，会考虑他们的位置和排序顺序。会让瓦片精灵和场景中其它渲染器或自定义排序轴进行交互
- Detect Chunk Culling：渲染器如何剔除瓦片地图的边界
	- Auto：自动检测
	- Manual：手动设置拓展边界
- Chunk Culling Bounds：当选择手动设置剔除拓展边界时，可以在这里自己填写拓展的值


#### 5.3.4 瓦片地图碰撞器
为挂载TilemapRenerer脚本的对象添加Tilemap Collider2D脚本, 会自动添加碰撞器
注意：想要生成碰撞器的瓦片Collider Type类型要进行设置

可以通过复合碰撞器合并碰撞器
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_22-42-39.jpg)
![alt text](/Unity/图片/Unity核心/Unity核心10-12_22-44-10.jpg)

</center>