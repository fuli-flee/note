[toc]

***
# 一. 模型的制作过程

建模师:
① 建模 -> ② 展UV -> ③ 材质和纹理贴图
动作师:
④ 骨骼绑定 -> ⑥ 动画制作
***
# 二. 2D相关
***
## 1. 图片导入相关设置
### 1.1 概述
Unity支持的图片格式有很多
- BMP:是Windows操作系统的标准图像文件格式，特点是几乎不进行压缩，占磁盘空间大
</br>

- TIF:基本不损失图片信息的图片格式，缺点是体积大
</br>

- JPG:一般指JPEG格式，属于有损压缩格式，能够让图像压缩在很小的存储空间，一定程度上会损失图片数据，无透明通道
</br>

- PNG:无损压缩算法的位图格式，压缩比高，生成文件小，有透明通道
</br>

- TGA:支持压缩，使用不失真的压缩算法，还支持编码压缩。体积小，效果清晰，兼备BMP的图像质量和JPG的体积优势，有透明通道
</br>

- PSD:是PhotoShop（PS）图形处理软件专用的格式，通过一些第三方工具或自制工具可以直接将PSD界面转为UI界面
</br>

其它还支持
- EXR、GIF、HDR、IFF、PICT等等

其中Unity最常用的图片格式是
- JPG、PNG、TGA三种格式

***
#### 1.1.1 图片设置的6大部分

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_16-23-27.jpg)

</center>

1. 纹理类型
2. 纹理形状
3. 高级设置
4. 平铺拉伸
5. 平台设置
6. 预览窗口


***
### 1.2 纹理类型 (Texture Type)

#### 1.2.1 纹理类型主要是设置什么
设置纹理类型主要是为了让纹理图片有不同的主要用途, 指明其是用于哪项工作的纹理
***
#### 1.2.2 参数设置
<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_16-34-06.jpg)

</center>

**①Default**
默认纹理, 大部分导入的模型贴图都是该类型

名词解释:
[伽马颜色空间](https://docs.unity3d.org.cn/6000.0/Documentation/Manual/color-spaces.html)

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_16-36-14.jpg)
![alt text](/Unity/图片/Unity核心/Unity核心09-28_16-57-31.jpg)

</center>

`Alpha Source`

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_16-58-55.jpg)

</center>

**② Normal map**
法线贴图格式

法线贴图就是在原物体的凹凸表面的每个点上均作法线
法线就是垂直于某个点的切线的方向向量

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_17-07-19.jpg)
![alt text](/Unity/图片/Unity核心/Unity核心09-28_17-09-19.jpg)

</center>

**③ Editor GUI and Legacy GUI**
一般在编辑器中或者GUI上使用的纹理

**④ Sprite（2D and UI）**
2D游戏或者UGUI中使用的格式

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_17-14-40.jpg)

</center>

- **Sprite Mode**：图像中提取精灵图形的方式
  - Single：按原样使用精灵图像
  - Multiple：瓦片模式，如果是图集，使用该选项，可以在Sprite Editor编辑窗口自定义图片
  - Polygon：网格精灵模式
</br>

- **Pixels Per Unit**：世界空间中的一个距离单位对应多少像素
</br>

- **MeshType**：网格类型；只有Single和Multiple模式才支持
  - Full Rect：创建四边形，将精灵显示在四边形上
  - Tight：基于像素Alpha值来生成网格，更加贴合精灵图片的形状
    - 任何小于32*32的精灵都使用FullRect模式，即使设置成Tight模式也是
</br>

- Extrude Edges：使用滑动条确定生成的网格中精灵周围流出的区域大小
</br>

- **Pivot**：精灵图片的轴心点，Single模式才有此选项
  - 对应九宫格布局的九个点，还可以自定义
</br>

- **Generate Physics Shape**：启用此选项，Unity会自动根据精灵轮廓生成默认物理形状
  - 只有Single 和Multiple模式才可使用
</br>

- **Sprite Editor**：编辑Sprite，需要安装2D Sprite包

**⑤ Cursor**
自定义光标

**⑥ Cookie**
光源剪影格式

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_17-27-44.jpg)

</center>

- Light Type：应用的光源类型
    一般点光源的剪影需要设置为立方体纹理
    方向光和聚光灯的剪影设置为2D纹理

    - Spotlight：聚光灯类型，需要边缘纯黑色纹理
    - Directional：方向光，平铺纹理
    - Point：点光源，需要设置为立方体形状

**⑦ Lightmap**
光照贴图格式

**⑧ Single Channel**
纹理只需要单通道的格式

<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-28_17-31-21.jpg)

</center>

- Channel：希望将纹理处理为Alpha还是Red通道
    - Alpha：使用Alpha通道，不允许进行压缩
    - Red：使用红色通道

*** 
### 1.3 纹理形状
纹理不仅可以用于模型贴图, 还可以用于制作天空盒与反射探针
纹理形状设置, 主要就是用于在两种模式之间进行切换

#### 1.3.1 参数

- ==Texture Shape==：纹理形状
  - ==2D==：2D纹理，最常用设置，这些纹理将使用到模型和GUI元素上
  - ==Cube==：立方体贴图，主要用于天空盒和反射探针

以下对于Cube的参数进行详细讲解
<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-29_08-56-55.jpg)

</center>

- Mapping：如何将纹理投影到游戏对象上
  - Auto：根据纹理信息创建布局
  - 6 Frames Layout：纹理包含标准立方体贴图布局之一排列的六个图像
  - Latitude-Longitude Layout：将纹理映射到2D维度/经度
  - Mirrored Ball：将纹理映射到类似球体的立方体贴图上
</br>

- Convolution Type：纹理的过滤类型
  - None：无过滤
  - Specular：将立方体作为反射探针
  - Diffuse：将纹理进行过滤表示辐照度，可作为光照探
</br>

- Fixup Edge Seams：Convolution Type 为None 和 Diffuse下才有用。解决低端设备上面之间立方体贴图过滤错误

***
### 1.4 纹理高级设置
<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-29_09-05-20.jpg)

</center>

***
#### 1.4.1 参数

>为什么纹理要设置为2的N次方？
>因为图形学规则，纹理必须是2的幂尺寸
- ==Non-Power of 2==：如果纹理尺寸非2的幂如何处理
  - ==None==：纹理尺寸大小保持不变
  - ==To nearest==：将纹理缩放到最接近2的幂的大小,（注意：PVRTC格式要求纹理为正方形）
  - ==To larger==：将纹理缩放到最大尺寸大小值的2的幂的大小
  - ==To smaller==：将纹理缩放到最小尺寸大小值的2的幂的大小
</br>

- ==Read/Write Enabled==：启用可以使用Unity中提供的一些方法从纹理中获取到数据（一般需要获取图片数据时才开启）
</br>

- Streaming Mipmaps：启用则可以使用纹理串流，主要用于在控制加载在内存中的Mipmap级别，用于减少Unity对于纹理所需的内存总量，用性能换内存
  - Mip Map Priority：Mipmap优先级，Unity根据优先级来确定分配资源时优先考虑哪些Mipmap
</br>

- ==Generate Mip Maps==：允许生成MipMap
  - Border Mip Maps：启用可避免颜色向外渗透到较低MIP级别的边缘
  - Mip Map Filtering：优化图像质量的过滤方法
    - Box：随着尺寸减小，级别更加平滑
    - Kaiser：随着Mipmap尺寸大小下降而使用的锐化算法，如果远处纹理太模糊，可以使用该算法
  - Mip Maps Preserve Coverage：Mipmap的Alpha通道在Alpha测试期间保留覆盖率
    - Alpha Cutoff Value：覆盖率参考值
  - Fadeout Mip Maps：级别递减时使Mipmap淡化为灰色

#### 1.4.2 什么是Mipmap?
先贴上我最喜欢的闫老师的课,讲的很清楚 [Lecture 09, 从43:24开始](https://www.bilibili.com/video/BV1X7411F744?spm_id_from=333.788.videopod.episodes&vd_source=e5ff09f1c2b416e099232ca31ec5028d&p=9)

开启MipMap功能后，Unity会帮助我们根据图片信息生成n张不同分辨率的图片
在场景中会根据我们离该模型的距离选择合适尺寸的图片用于渲染，提升渲染效率

***
### 1.5 平铺拉伸
<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-29_09-45-32.jpg)

</center>

#### 1.5.1 参数

- ==Wrap Mode==：平铺纹理时的方式
  - Repeat：在区块中重复纹理
  - Clamp：拉伸纹理的边缘
  - Mirror：在每个整数边界上镜像纹理以创建重复图案
  - Mirror Once：镜像纹理一次，然后将拉伸边缘纹理
  - Per-axis：单独控制如何在U轴和V轴上包裹纹理
</br>

- ==Filter Mode==：纹理在通过3D变化拉伸时如何进行过度
  - Point：纹理在靠近时变为块状
  - Bilinear：纹理在靠近时变得模糊
  - Trilinear：与Bilinear类似，但纹理也在不同的Mip级别之间模糊
</br>

- Aniso Level：以大角度查看纹理时提高纹理质量。性能消耗高

***
### 1.6 平台设置
<center>

![alt text](/Unity/图片/Unity核心/Unity核心09-29_10-04-04.jpg)

</center>

平台设置主要设置纹理最终打包时在不同平台下的尺寸, 格式, 压缩方式
它影响了你包的大小和读取性能方面的问题, 所以非常重要
***
#### 1.6.1 参数

- ==Max Size==：设置导入的纹理的最大尺寸，即使美术出的很大的图，也可以通过这里把它们限制在一定范围内
</br>

- ==Resize Algorithm==：当纹理尺寸大于指定的Max Size时，使用的缩小算法
  - Mitchell：默认米切尔算法来调整大小，该算法是常用的尺寸缩小算法
  - Bilinear：使用双线性插值来调整大小。如果细节很重要的图片，可以使用它，它比米切尔算法保留的细节更多
</br>

- ==Format==：纹理格式, 各平台支持的格式有所不同, 如果选择Automatic, 会根据平台使用默认设置
  - [各平台纹理压缩格式, 这里贴了官方文档](https://docs.unity.cn/cn/2020.3/Manual/class-TextureImporterOverride.html)
  - IOS
    - 选择默认的纹理压缩设置 (PVRTC) 可获得更大的兼容性。
      如果您的应用程序不包含 OpenGL ES 2 支持，则可以选择一种 ASTC 格式。这些格式提供更好的质量和灵活性，并且压缩速度比 PVRTC 快。
  - Android
    - 由于安卓设备众多，设备标准都不同意，一般会根据不同的设备标准制作多个安装包
</br>

- ==Compression==：选择纹理的压缩类型，帮助Unity正确选择压缩格式, 会根据平台和压缩格式的可用性进行压缩
  - None：不压缩纹理
  - Low Quality：以低质量格式压缩纹理
  - Normal Quality：以标准格式压缩纹理
  - High Quality：以高质量格式压缩纹理
</br>

- ==Use Crunch Compression==：启用后，使用Crunch压缩。Crunch是一种基于DXT或ETC纹理压缩的有损压缩格式。压缩时间长，解压速度快。
  - 压缩质量，质量越高意味着纹理越大，压缩时间越长
</br>

- ==Split Alpha Channel==：Alpha通道分离，节约内存。会把一张图分成两张纹理。一张包含RGB数据，一张包含Alpha数据，在渲染时再合并渲染。
</br>

- ==Override ETC2 fallback==：不支持ETC2压缩的设备上，使用的格式
</br>

关于双线性插值, 还是闫老师的课, [还是Lecture 09, 22:45](https://www.bilibili.com/video/BV1X7411F744/?spm_id_from=333.788.videopod.episodes&vd_source=e5ff09f1c2b416e099232ca31ec5028d&p=9)

***
## 2. Sprite

### 2.1 Sprite Editor
精灵图片编辑器
它主要用于编辑2D游戏开发中使用的Sprite精灵图片
它可以用于编辑图集中提取元素, 设置精灵边框, 设置九宫格, 设置轴心(中心)点等功能 

如果你的项目是创建时是3D项目的话, 得在PackageManager里下载2D Sprite包
***
#### 2.1.1 Single图片编辑

左上角
<center>

![左上](/Unity/图片/Unity核心/Unity核心09-29_10-50-58.jpg)

</center>

**①Sprite Editor**
<center>

![右下](/Unity/图片/Unity核心/Unity核心09-29_10-43-29.jpg)

</center>

- Position：在图片中的偏移位置和宽高
- Border：边框，用于设置九宫格的4条边
- Pivot：轴心（中心）点位置
- Pivot Unit Mode：轴心点单位模式
  - Normalized：标准化模式，0~1
  - Pixels：像素模式
- Custom Pivot：自定义轴心点

**②Custom Outline (决定渲染区域)**
自定义边缘线, 自定义物理形状
<center>

![右下](/Unity/图片/Unity核心/Unity核心09-29_10-58-35.jpg)

</center>

- Snap：将控制点贴近在最近的像素
- Outline Tolerance：轮廓点的复杂性和准确性，0~1, 值越大轮廓点越多，越准确
- Generate：生成网格轮廓

**③ Custom Physics Shape (决定碰撞判断区域)**
自定义精灵图片的物理形状, 主要用于设置需要物理碰撞判断的2D图片
它决定了之后产生碰撞检测的区域

**④ Secondary Textures (为图片添加特殊效果)**
次要纹理设置, 可以将其他纹理和该精灵图片关联
着色器可以得到这些辅助纹理, 然后用于做一些效果处理, 让精灵应用其他效果

***
#### 2.1.2 Multiple图集元素分割
当我们的图片资源是图集时, 我们需要将其Sprite Mode设置为Multiple
这时就可以使用Sprite Editor自带的功能进行图集元素分割

**①自动分割**
Type 选中 Automatic

<center>

![右下](/Unity/图片/Unity核心/Unity核心09-29_11-13-44.jpg)

</center>

- Pivot：单张图片轴心点位置
- Custom Pivot：自定义轴心点
- Method：如何处理现有对象
  - Delete Existing：替换掉已经选择的任何矩形
  - Smart：尝试创建新矩形同时保留或调整现有矩形
  - Safe：添加新矩形而不更改任何已经存在的矩形

**②按单位大小分割**
Type 选中 Grid By Cell Size

<center>

![右下](/Unity/图片/Unity核心/Unity核心09-29_11-18-07.jpg)

</center>

- Pixel Size：单元格宽高
- Offset：偏移位置
- Padding：和边缘的偏移位置
- Keep Empty Rects：是否保留空矩形

**③按单元格数量分割**
Type 选中 Grid By Cell Count
<center>

![右下](/Unity/图片/Unity核心/Unity核心09-29_11-55-55.jpg)

</center>

- Column & Row：行列数

***
#### 2.1.3 Polygon多边形编辑

如果我们使用的资源时多边形资源 
我们可以在设置时将模式设置为Polygon
然后可以在Sprite Editor中进行快捷设置

这个很简单,只需要设置你要的多边形边数(0 ~ 128), 生成对应的多边形用来切割和设置渲染范围 

***
### 2.2 Sprite Renderer
Sprite Renderer是精灵渲染器
所有2D游戏中游戏资源（除UI外）都是通过Sprite Renderer让我们看到的
它是2D游戏开发中的一个极为重要的组件

#### 2.2.1 2D对象的创建
三种方式

1. 直接拖拽 Texture Type 为 Sprites(2D and UI) 的 Sprite 图片到场景中
2. 右键创建: 2D Object -> Sprite -> 关联一个Sprite
3. 创建一个空物体, 添加 Sprite Renderer


#### 2.2.2 参数
<center>

![右下](/Unity/图片/Unity核心/Unity核心09-29_14-46-24.jpg)

</center>

- ==Sprite==：渲染的精灵图片
</br>

- Color：定义着色，一般没有特殊需求不会修改
</br>

- Filp：水平或竖直翻转精灵图片
</br>

- ==Draw Mode==：绘制模式，当尺寸变化时的缩放方式
  - ==Simple==：简单模式，缩放时整个图像一起缩放
  - ==Sliced==：切片模式，9宫格切片模式，十字区域缩放，4个角不变化
    - 一般用于变化不大的纯色图（注意：需要把精灵的网格类型设置为Full Rect）
  - ==Tiled==：平铺模式，将中间部分进行平铺而不是缩放（注意：需要把精灵的网格类型设置为Full Rect）
    - ==Continuous==：当尺寸变化时，中间部分将均匀平铺
    - ==Adaptive==：当尺寸变化时，类似Simple模式，当更改尺寸达到Stretch Value时，中间才开始平铺
</br>

- ==Mask Interaction==：与精灵遮罩交互时的方式
  - ==None==：不与场景中任何精灵遮罩交互
  - ==Visible inside Mask==：精灵遮罩覆盖的地方可见，而遮罩外部不可见
  - ==Visible Outside Mask==：精灵遮罩外部的地方可见，而遮罩覆盖处不可见
</br>

- Sprite Sort Point：计算摄像机和精灵之间距离时，使用精灵中心Center还是轴心点Pivot，一般情况下不用修改
</br>

- Material：材质，可以使用一些自定义材质来显示一些特殊效果
  - 一般情况不修改。默认材质是不会受到光照影响的，如果想要受光照影响，可以选择Default-Diffuse
</br>

- ==Additional Settings==：高级设置
  - ==Sorting Layer==：排序层选择
  - ==Order in Laye==r：层级序列号，数值越大约会显示在前面
</br>


#### 2.2.3 代码设置

**① 获取Sprite Renderer**
```CSharp
GameObject obj = new GameObject();
SpriteRenderer sr = obj.AddComponent<SpriteRenderer>();
```

**② 动态的改变图片**
```CSharp
sr.sprite = Resources.Load<Sprite>("dead1");
//别忘了, 这种加载方式的前提是你把资源放在了Resources文件夹下了
```

**③ 动态的加载 图集中的图**

```CSharp
Sprite[] sprs = Resources.LoadAll<Sprite>("RobotBoyIdleSprite");
sr.sprite = sprs[10];
```

***
### 2.3. Sprite Mask
> Hierarchy窗口右键 => 2D Object => Sprite Mask


精灵遮罩, 它的主要作用就是对精灵图片产生遮罩
制作一些特殊的功能，比如只显示图片的一部分让玩家看到

想要遮罩生效, 需要设置Sprite Renderer中的Mask Interaction

<center>

![右下](/Unity/图片/Unity核心/Unity核心09-30_08-42-18.jpg)

</center>

- Sprite：遮罩图片
- Alpha Cutoff：如果Alpha包含透明区域和不透明区域之间的混合（半透明），则可以手动确定所显示区域的分界点（0~1）
- Custom Range：自定义遮罩范围, 开启后可以设置遮罩的范围，按照排序层来划分
  - 只有与 Mask 同 Sorting Layer，且 Order in Layer 落在 Front/Back 对应的范围内的 Sprite，才会被遮罩影响。
    - Front：遮罩「同层且 Order 比自己大」的 Sprite（前面的）
    - Back：遮罩「同层且 Order 比自己小」的 Sprite（后面的）

举个例子: 我设置了一个新的 Sorting Layer 叫 Test, 排在 Default 层以上
我设置了Mask中的front和back如下图

<center>

![右下](/Unity/图片/Unity核心/Unity核心09-30_09-27-45.jpg)

</center>

那么我在Sprite Renderer中分别将Sorting Layer和Order Layer设置为
- (Default, 0)是没有效果的, (Default, 1)是有效果的 
- (Test, 0)是有效果的, (Test, 1)是有效果的, (Test, 2)是没效果的

*** 

### 2.4 Sorting Group
排序分组, 它的主要作用就是对多个精灵图片进行分组排序
Unity会将同一个排序组中的精灵图片一起排序，就好像他们是单个游戏对象一样
主要作用是对于需要分层的2D游戏用于整体排序

- 注意事项
  1. 子排序组，先排子对象 再按父对象和别人一起排 （同层和同层比）
  2. 多个 挂载排序分组组件的预设体 之间 通过修改 排序索引号来决定前后顺序

***

### 2.5  Sprite Atlas 精灵图集

#### 2.5.1 图集
打图集的目的就是减少DrawCall 提高性能

#### 2.5.2 在Unity中打开自带的打图集功能
[同样的内容在UGUI.md中的第18条写得更加详细](/Unity/UGUI.md)

在工程设置面板中打开功能

> Edit——>Project Setting——>Editor

Sprite Packer(精灵包装器，可以通过Unity自带图集工具生成图集)
Disabled：默认设置，不会打包图集

- Enabled For Builds（Legacy Sprite Packer）：Unity仅在构建时打包图集，在编辑模式下不会打包图集
- Always Enabled（Legacy Sprite Packer）：Unity在构建时打包图集，在编辑模式下运行前会打包图集

- Legacy Sprite Packer传统打包模式 相对下面两种模式来说 多了一个设置图片之间的间隔距离
- Padding Power:选择打包算法在计算打包的精灵之间以及精灵与生成的图集边缘之间的间隔距离, 这里的数字 代表2的n次方

- Enabled For Build：Unity进在构建时打包图集，在编辑器模式下不会打包
- Always Enabled：Unity在构建时打包图集，在编辑模式下运行前会打包图集

#### 2.5.3 相关参数

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_11-17-43.jpg)

</center>

- Type：图集类型
  - Master：主图集

    - Include in Build：选中可以在当前构建中包含图集

    - Allow Rotation：选中此选项将在打包图集时对图片元素进行旋转，可以最大限度提高组合后的图集密度；注意！！！如果是UI图集，请禁用此选项，因为打包时会将场景中UI元素旋转

    - Tight Packing：选中此选项在打包图集时使用图片轮廓来打包而不是根据矩形，可以最大限度提高组合后的图集密度

    - Alpha Dilation（Alpha 扩张）是用于解决精灵边缘渲染异常的优化设置，主要作用是避免图集打包后精灵边缘出现黑边、透明像素或采样错误。

    - Padding：图集中各图片的间隔像素
  - Variant：变体类型的图集

    - Master Atlas：关联的主图集（图集类型必须是Master）

    - Include in Build：选中可以在当前构建中包含图集

    - Scale：设置变体图集的缩放因子（0~1），变体图集的大小是主图集乘以Scale的结果

变体图集的主要作用是以主图集为基础，对它进行缩放产生一个新的图集副本。如果想使用变体图集中的内容，只需要勾选变体图集的Include in build选项，而主图集禁用此选项即可

- Read/Write Enabled：允许通过脚本访问纹理数据。如果启用，会创建纹理数据的副本。会让内存翻倍，一般情况下不需要开启它
- Generate Mip Maps：勾选它会生成Mipmap；Mipmap是一种性能优化手段，用内存换性能。一般情况下不用开启
- SRGB：启用此属性可指定将纹理存储在伽马空间中。对于非 HDR 颜色纹理（例如反照率和镜面反射颜色），应始终选中此复选框。如果纹理存储了有特定含义的信息，并且您需要着色器中的确切值（例如，平滑度或金属度），请禁用此属性。默认情况下会启用此属性。
</br>

- Filter Mode：纹理在3D变化拉伸时如何进行过滤
  - Point：纹理靠近时变为块状
  - Bilinear：纹理靠近时变得模糊
  - Trilinear：与Bilinear类似，但是纹理在不同的MIP级别之间模糊
</br>

- Objects for Packing：关联需要打图集的图片们，注意：一定是Sprite类型的图片
</br>

- Default
  - Max Texture Size：纹理的最大尺寸，像素为单位
  - Format：指定纹理的内部表示，在不同平台上会有不同的参数
  - Compression：纹理压缩类型
    - 不压缩
    - 低质量
    - 普通质量
    - 高质量
    - 质量越高占用内存越多，不压缩质量最好
  - Use Crunch Compression：使用Crunch压缩，是一种有损压缩格式，压缩耗时长，但是运行时解压速度快
  - Compressor Quality：压缩质量，质量越高纹理越大，耗时越长
#### 2.5.4 代码控制
```CSharp
GameObject obj = new GameObject();
SpriteRenderer sr = obj.AddComponent<SpriteRenderer>();
//加载图集资源
SpriteAtlas spriteAtlas = Resources.Load<SpriteAtlas>("MyAtlas");
//加载图集资源中的某一张小图
sr.sprite = spriteAtlas.GetSprite("dead1");
```
***
## 3. 2D物理系统

### 3.1 刚体

#### 3.1.1 2D物理系统中的刚体组件
刚体是物理系统中用于帮助我们进行模拟物理碰撞中力的效果的

2D物理系统中的刚体和3D中的刚体基本是一样的
最大的区别是对象只会在XY平面中移动，并且只在垂直于该平面的轴上旋转

#### 3.1.2 相关参数
<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_15-31-28.jpg)

</center>

- Dynamic：动态类型, 受重力和力的影响移动和旋转
  - Material：物理材质，在刚体上设置了物理材质，如果子物体有碰撞器但是没有设置材质则会通用刚体的物理材质
    - 如果不设置，将使用在Physics 2D窗口中设置的默认材质
      物理材质的使用优先级：
      1. 2D碰撞器上指定的2D物理材质
      2. 2D刚体上指定的2D物理材质
      3. Physics 2D窗口指定的2D默认物理材质
  - Simulated：如果希望2D刚体以及所有子对象2D碰撞器和2D关节都能模拟物理效果, 需要启用该选项
  - Use Auto Mass：是否使用自动质量
  - Mass：质量
  - Linear Dray：影响位置移动的阻力系数
  - Angular Drag：影响旋转移动的阻力系数
  - Gravity Scale：受重力影响的程度
  - Collision Detection：碰撞检测算法
    - Discrete：离散检测算法，只会用新位置进行计算，速度过快时会穿过
    - Continuous：连续检测算法，计算量更大，但是不会发生穿过的情况
  - Sleeping Mode：对象处于静止状态时进入睡眠模式
    - Never Sleep：从不休眠，会一直进行检测计算，性能消耗较大
    - Start Awake：最初处于唤醒状态
    - Start Asleep：最初处于睡眠状态，但是可以被碰撞唤醒
  - Interpolate：物理更新间隔之间的插值运算
    - None：不应用移动平滑
    - Interpolate：根据前一帧进行平滑处理
    - Extrapolate：根据后一帧位置进行平滑处理
  - Constraints：约束限制, 可以让某一个轴不受力影响位移或者旋转
</br>

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_15-31-58.jpg)

</center>

- Kinematic：运动学类型, 不受力的影响，只能通过代码让其动起来, 能和Dynamic 2D刚体产生碰撞，但是不会动，
  只会进入碰撞检测函数, 因此它没有了质量摩擦系数等属性
  因此它的性能能消耗较低，主要会通过代码来处理其移动旋转
  - Simulated：
    如果希望2D刚体以及所有子对象2D碰撞器和2D关节都能模拟物理效果, 需要启用该选项
    当启用时，会充当一个无限质量的不可移动对象，可以和所有2D刚体产生碰撞
    如果Use Full Kinematic Contacts禁用，它只会和Dynamic 2D刚体碰撞
  - Use Full Kinematic Contacts：如果希望能和所有2D刚体碰撞，启用它
    如果不启用，它不会和Kinematic 2D和Static 2D刚体碰撞
</br>

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_15-32-19.jpg)

</center>

- Static：静态类型
  完全不动的需要检测碰撞的对象
  相当于是无限质量不可移动的对象
  它的性能消耗最小，它只能和Dynamic 2D刚体碰撞

  和它类似的有只加碰撞器而不加刚体的物体, 它们会和刚体物体产生碰撞，但是自己不会动
</br>

#### 3.1.3 如何选择不同类型的刚体
- Dynamic动态刚体：受力的作用，要动要碰撞的对象

- Kinematic运动学刚体：通过刚体API移动的对象，不受力的作用，但是想要进行碰撞检测 

- Static静态刚体：不动不受力作用的静态物体，但是想要进行碰撞检测 

上面还是很抽象, 我来告诉他们会用在哪些场景
1. 动态刚体最常用, 像是《超级马里奥》这类平台跳跃游戏中，**马里奥**就是一个典型的 Dynamic 动态刚体。他会受到重力的影响而下落，当玩家按下跳跃键时，会给马里奥施加一个向上的力，使其能够跳跃。同时，当马里奥与场景中的平台、敌人等物体碰撞时，会根据物理规则产生相应的反应，如反弹、被击退等。
2. 运动学刚体, 在一些游戏中，**电梯**通常是用 Kinematic 运动学刚体来实现的。电梯本身不受重力和其他物理力的影响，它的运动是通过脚本控制其位置和速度来实现的，比如当玩家进入电梯后，按下上升或下降的按钮，电梯会按照预设的速度和路径进行移动。但电梯又需要与玩家和其他物体进行碰撞检测，以确保玩家能够正确地进入和离开电梯，以及避免其他物体穿过电梯。
3. 静态刚体, 在各种平台跳跃游戏中，固定的**平台**就是 Static 静态刚体。这些平台不会移动，也不受任何物理力的作用，但它们为 Dynamic 动态刚体的角色提供了支撑和碰撞检测的表面，角色可以在平台上站立、跳跃和行走，当角色与平台碰撞时，会按照物理规则进行交互。

#### 3.1.4 刚体API
[看 Unity入门.md 的22条](/Unity/入门.md)

- 加力
```CSharp
Rigidbody2D rigid = this.GetComponent<Rigidbody2D>();
rigid.AddForce(new Vector2(0, 100));
```

- 速度
```CSharp
rigid.velocity = new Vector2(1, 0);
```
***
### 3.2 碰撞器 

碰撞器是用于在物理系统中 表示物体体积的的（形状或范围）
刚体通过得到碰撞器的范围信息进行计算
判断两个物体的范围是否接触
如果接触 刚体就会模拟力的效果产生速度和旋转

#### 3.2.1 2D碰撞器
1. 圆形碰撞器

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_21-13-45.jpg)

</center>

- Material：一种物理材质，用于确定碰撞的属性，控制摩擦和弹性
- Is Trigger：是否是触发器
- Used By Effector：是否被附加的2D效应器使用
- Offset：圆心偏移位置
- Radius：圆形的半径

2. 盒状碰撞器

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_20-58-19.jpg)

</center>

- Used by Composite: 如果勾选, 则该碰撞器将附加到2D复合碰撞器中使用
- Auto Tiling: 如果精灵渲染器组件的Draw Mode设置为Tiled平铺模式, 勾选该选项后, 当改变精灵大小时将自动更新碰撞器的尺寸
- Size: 矩形的宽高
- Edge Radius: 使四个顶点为圆角

3. 多边形碰撞器

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_21-14-08.jpg)

</center>


- Points：多边形顶点
  虽然可以手动修改，但是一般情况下 我们通过数值编辑太复杂了
  都通过Edit Collider编辑，或者让Unity自动识别创建

4. 边界碰撞器

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_21-14-55.jpg)

</center>

边界碰撞器的编辑主要还是通过Edit Collider, 一般不会手动去通过数值加点


5. 胶囊碰撞器

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_21-15-35.jpg)

</center>

- Size：胶囊的宽高
- Direction：是竖直胶囊还是水平胶囊

6. 复合碰撞器

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-11_21-16-35.jpg)

</center>

- Geometry Type：几何学类型，合并碰撞体时，碰撞体顶点将组合为两种不同的几何体类型
  - Outlines：空心轮廓，类似边界碰撞器
  - Polygons：实心多边形，类似多边形碰撞器
- Generation Type：生成类型，复合碰撞器在何时生成新几何体
  - Synchronous：对2D复合碰撞器或使用的其它碰撞器修改时，Unity立即生成新几何体
  - Manual：手动生成新几何体，通过代码生成或者点击下发的Regenerate Geometry生成按钮
- Vertex Distance：从复合碰撞器收集顶点时允许的最小间距值

#### 3.2.2 碰撞检测函数
[详细的看Unity入门.md的21.2](/Unity/入门.md)

碰撞检测函数 和 3D碰撞检测函数除了名字不同外其他基本一致

***
### 3.3 物理材质
物理材质是用于决定在物体产生碰撞时这些物体之间的摩擦和弹性表现的
通过物理材质我们可以做出类似 斜坡不滑落，小球反弹等效果

<center>

![alt text](/Unity/图片/Unity核心/Unity核心10-12_11-36-42.jpg)

</center>

#### 3.3.1 相关参数
Friction：摩擦系数，为0表示没有摩擦力
Bounciness：反弹程度。0表示没有弹力，1表示完美弹力（没有能量损失一直弹）