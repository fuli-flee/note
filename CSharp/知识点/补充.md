[toc]
***
# 一. Unity跨平台基本原理

## 1.1 .Net相关知识

### 1.1.1 .Net是什么
微软的.Net既不是编程语言也不是框架
是类似于互联网时代、次时代、21世纪、信息时代之类的宣传口号
它是一整套技术体系的统称,或者说它是微软提供的技术平台的代号

包含的内容有
- 框架体系:.Net Framework、.Net Core、Mono等等
- 开发语言:C#、VB、F#等等(C#是.Net平台主推的开发语言)
- 开发工具:Visual Studio、Visual Studio Code等等

你可以简单理解.Net本质上就是微软为自己的一系列产品取的一个代号

### 1.1.2 目的
1. 跨语言
只要是面向.NET平台的编程语言(C#、VB、C++、F#等等),用其中一种语言编
写的内容可以无缝地用在另一种语言编写的应用程序中

2. 跨平台
一次编译,不需要任何代码修改,应用程序就可以运行在任王意有.NET框架实现的
操作系统上,即代码不依赖于操作系统,也不依赖硬件环境

### 1.1.3 如何实现的跨语言
- `CLS (Common Language Specification)` 
公共语言规范
.Net专门参考每种语言并找出了语言间的共性,定义了一组规则。
与其说是规则,不如说它是一组**语言互操作的标准规范**
只要开发者都遵守这个规则来编码,那么代码就能被任意.Net平台支持的语言所
通用,即可以通过不同的编程语言(C#、VB、J#等等)来创建应用程序
</br>

- `CTS (Common Type System)`
公共类型系统
**当你需要设计面向.Net的语言时需要遵循一个体系,这个体系就是CTS
刚才提到的CLS公共语言规范就是是CTS公共类型系统的子级**
一个编程语言,如果**它能够支持CTS,那么我们就称它为面向.NET平台的语言**
</br>

- `CLI (Common Language Infrastructure)`
公共语言基础结构
**是微软将CTS等内容提交给国际组织计算机制造联合会ECMA的的一个工业标准**
</br>

- `总结`
微软为了实现跨语言,制定了一些规范
**只要一门语言支持CTS(公共类型系统)的规则
那么我们就能够使用它在.Net平台下开发应用程序**
CLS(公共语言规范)是CTS的一个子级,是一组**语言互操作的的标准规范**
我们经常可以看到的**CLI**公共语言基础结构,**它包含CTS**公共类型系统
它是**微软将CTS等内容提交给国际组织计算机制造联合会ECMA的一个工业标准**

### 1.1.4 如何实现的跨平台
.Net的跨语言是让各种语言支持.Net的规范CLI(也就是CTS等规范)
**早期的.Net系列产品主要是为了给Windows操作系统服务的**
并没有跨平台的特性,即使跨语言了
也只是可以使用多语言开发Windows上的应用程序

### 1.1.5 .Net Framework
.Net Framework在2002年推出1.0版本
.NET Framework是一个可以快速开发、部署网站服务及应用程序的开发框架
是Windows中的一个组件,部分开源,主要用于开发Windows下应用程序

包括
- 公共语言运行时(Common Language Runtime,CLR)
- 虚拟执行系统
- .NET Framework 类库等

**体系结构**
<center>

![alt text](/CSharp/图片/补充/CSharp补充10-20_17-21-27.jpg)
![alt text](/CSharp/图片/补充/CSharp补充10-20_17-17-29.jpg)

</center>

**制作应用程序
编程语言+调用各种类库进行开发生成程序集**

1. 只要支持CLS公共语言规范的语言都可以用于开发Windows下的各种应用程序和网站程序
2. BCL(基础类库)和FCL(框架类库)是这个框架体系中为我们实现好的各种API
3. 程序集的表现就是后缀为.dll或者.exe格式的文件, 其中包含的最关键信息:
   - PE头、CLR头(就是一些程序的格式信息,比如入口方法,版本号等等)
   - CIL代码(通用中间代码)是介于源代码和机器码之间的代码之后会通过CLR产生机器码

CIL代码你可以理解为由于可能使用不同的代码进行开发,所以会会将这些代码翻译为统一规范的中间代码 


**让应用程序在操作系统上运行**
**起作用的就是 CLR (Common Language Runtime)公共语言运行时**
它是 .Net Framework的基础,所有的.Net技术都是建立在此之上的
它是一个在执行时管理代码的代码,
提供内存管理、线程管理等等核心服务,
就好像一个小型的操作系统一样
所以形象的把它称为".Net虚拟机"。
如果想要应用程序在目标操作系统上能够运行
就必须依靠 .Net 提供的CLR环境来支持
那就必须在操作系统上安装 .Net Framework
它会将程序集中的IL(中间代码) 翻译为机器码最终在操作系统上运行

<center>

![alt text](/CSharp/图片/补充/CSharp补充10-20_17-35-34.jpg)

</center>

### 1.1.6 .Net Core
.Net Core 是2016年推出的 .Net Framework的新一代版本, 它就像是 .Net Framework的兄弟
**是 .Net Framework的翻版实现,它是一个开源项目**
它是基于 .Net Framework来进行设计的主要目的就是跨平台
是 .Net 技术框架组成在Windows、MacOS、类Linux系统下的具体实现
**它的原理就是为不同的操作系统实现对应的
CLR公共语言运行时(.Net虚拟机)
这样就可以在不同的平台上
将IL(中间代码)翻译成机器码最终在操作系统上运行了**

### 1.1.7 Mono
从上面的知识我们可以认识到 .Net FrameWork是不跨平台的, 而 .Net Core 是支持跨平台的, 那从2002年FrameWork的诞生到2016年Core的诞生中间有14年的空窗期, 那这就催生了Mono这个跨平台的项目

Mono是一个由Xamarin公司(已被微软收购)所赞助的开源项目
**它基于.Net的CLI(Common Language Infrastructure)公共语言基础结构**
提供了微软 .Net FrameWork的另一种实现
**它相对 .Net FrameWork最大的区别就是具备跨平台的能力**
它不仅可以运行在Windows、MacOS、Linux等操作系统
甚至还可以运行在PS3、XBOX、Wii等主机平台上
Mono的1.0版本出现在2004年
也就是说在 .Net Core出现之前,Mono是.Net平台实现跨平台的不二之选

**`Mono如何实现的跨平台`**
Mono利用 .Net平台制定的CLI公共语言基础结构规则
利用它我们可以**把很多种语言编译成通用规范的CIL公共中间语言**
**再利用CLR公共语言运行时**,将这些 **CIL公共中间语言转换元为
操作系统的原生代码 (主要做的就是在各种操作系统上实现了对应的CLR内容)**
这样用各种不同语言编写的逻辑就能够在指定操作系统上运运行了
它的这一套规则是在 .Net Framework规则上进行的修改和添加

简单来说就是
在Unity下使用各种语言进行逻辑实现
这些语言在发布时会被编译成
**IL中间代码**
最终这些中间代码在对应操作系统上
通过**MonoVM(虚拟机)**
真正翻译成机器码运行起来

## 1.2 IL2CPP
它是一个脚本后处理方式
其实就是继Mono之后的一种跨平台解决方案
从名字上就知道它的作用是**将IL中间代码转译为CPP代码**

### 1.2.1 跨平台原理
IL2CPP和Mono的区别就在于
当生成了IL中间代码后Mono是直接通过虚拟机转译运行

而IL2CPP的步骤多了一些
- 会将IL中间代码转译为C++代码
- 再通过各平台的C++编译器直接编译为可执行的原生汇编代码

虽然中间代码变为了C++, 但是内存管理还是遵循C#中GC的方式
所以会有一个IL2CPP VM(虚拟机)用来完成GC管理,线程创建等服务工作的

### 1.2.2 Mono和IL2CPP
**`Mono`**
1. 构建(最终打包时)速度快
2. Mono编译机制是JIT**即时编译(也就是说它可以边编译边执行)**,所以支持更多类库
3. 必须将代码发布为托管程序集(.dll文件)
4. MonoVM虚拟机平台维护麻烦,且部分平台不支持(WebGL)
5. 由于Mono版本授权原因,C#很多新特性无法使用

**`IL2CPP`**
1. 相对Mono构建(最终打包时)速度慢
2. 只支持AOT提前编译
3. 可以启用引擎代码剥离来减少代码的大小
4. 程序的运行效率比Mono高,运行速度快
5. 多平台移植更加方便

IL2CPP不能在运行时动态生成代码和类型, 所以必须在编译时就完全确定需要用到的类型

### 1.2.3 设置脚本后处理模式
> File => Build settings => player setting(左下角) => Win平台设置 => other setting => Configuration => Scripting Backend

### 1.2.4 存在的问题
- JIT: 边编译边执行
- AOT: 事先编译好后再执行

由于IL2CPP是AOT编译机制, 所以存在一些问题

### 1.2.5 类型裁剪
[官方文档](https://docs.unity3d.com/cn/2018.4/Manual/ManagedCodeStripping.html)

IL2CPP在打包时会自动对Unity工程的DLL进行裁剪，将代码中没有引用到的类型裁剪掉，
以达到减小发布后包的尺寸的目的。
然而在实际使用过程中，很多类型有可能会被意外剪裁掉，
造成运行时抛出找不到某个类型的异常。
特别是通过反射等方式在编译时无法得知的函数调用，在运行时都很有可能遇到问题

解决方案：
1. IL2CPP处理模式时，将PlayerSetting->Other Setting->Managed Stripping Level(代码剥离)设置为Low
2. 把上面的设置为High, 然后通过Unity提供的link.xml方式来告诉Unity引擎，哪些类型是不能够被剪裁掉的, 在Unity工程的Assets目录中（或其任何子目录中）建立一个叫[link.xml](/CSharp/知识点/相关配置文件/link.xml)(链接中有详细讲解该文件的书写格式)的XML文件

### 1.2.6 泛型问题
举例：List\<A>和List\<B>中A和B是我们自定义的类，
我能必须在代码中显示的调用过，IL2CPP才能保留List\<A>和List\<B>两个类型。
如果在热更新时我们调用List\ <C>，但是它之前并没有在代码中显示调用过，
那么这时就会出现报错等问题。主要就是因为JIT和AOT两个编译模式的不同造成的

解决方案：
- 泛型类：声明一个类，然后在这个类中声明一些public的泛型类变量
- 泛型方法：随便写一个静态方法，在将这个泛型方法在其中调用一下。这个静态方法无需被调用

这样做的目的其实就是在预言编译之前让IL2CPP知道我们需要使用这个内容

***
# 二. C#版本和unity的关系
## 2.1 各Unity版本支持的C#版本
[官方文档](https://docs.unity3d.com/cn/current/Manual/CSharpCompiler.html)

|unity版本|C#版本|
|---|---|
|Unity 2021.2|C# 9|
|Unity 2020.3|C# 8|
|Unity 2019.4|C# 7.3|
|Unity 2017|C# 6|
|Unity 5.5|C# 4|

## 2.2 Unity的 .Net API兼容级别
>PlayerSetting => Other Setting => Api Compatibility Level

主要有两种选择
- .Net 4.x（特殊需求时）:
   具备较为完整的 .Net API，甚至包含了一些无法跨平台的API
   如果你的应用主要针对Windows平台，并且会使用到 .Net Standard 2.0中没有的功能时会选择使用它
</br>

- .Net Standard 2.0（建议使用）:
   是一个.Net标准API集合，相对 .Net 4.x包含更少的内容，可以减小最终可执行文件大小, 它具有更好的跨平台支持
</br>

.Net Standard 2.0 配置文件大小是 .Net 4.x配置文件的一半, 所以我们尽量使用 .Net Standard 2.0

***
# 三. C#各版本新功能和语法

## 3.1 命名和可选参数与动态类型

### 3.1.1 命名和可选参数
- 有了命名参数，我们将不用匹配参数在所调用方法中的顺序, 每个参数可以按照参数名字进行指定
```CSharp
public void Test(int i, float f, bool b) { }

Test(b: false, f: 3.4f, i: 3);
```

- 命名参数可以配合可选参数使用,让我们做到跳过其中的默认参数直接赋值后面的默认参数

```CSharp
public void Test2(int i , bool b = true, string s = "123") { }

Test2(1, s: "234");
```


**作用**
可以让我们更方便的调用函数，少写一些重载函数


### 3.1.2 动态类型
关键词：**dynamic**


作用：

      通过dynamic类型标识变量的使用和对其成员的引用绕过编译时类型检查, 改为在运行时解析这些操作。
      在大多数情况下，dynamic类型和object类型行为类似
      任何非Null表达式都可以转换为dynamic类型。
      dynamic类型和object类型不同之处在于，
      编译器不会对包含类型 dynamic 的表达式的操作进行解析或类型检查
      编译器将有关该操作信息打包在一起，之后这些信息会用于在运行时评估操作。
      在此过程中，dynamic 类型的变量会编译为 object 类型的变量。
      因此，dynamic 类型只在编译时存在，在运行时则不存在。


注意：
1. 使用dynamic功能 需要将Unity的 .Net API兼容级别切换为 .Net 4.x
2. IL2CPP 不支持 C# dynamic 关键字。它需要 JIT 编译，而 IL2CPP 无法实现
3. 动态类型是无法自动补全方法的，我们在书写时一定要保证方法的拼写正确性

**作用**
动态类型可以节约代码量，当不确定对象类型，但是确定对象成员时，可以使用动态类型
通过反射处理某些功能时，也可以考虑使用动态类型来替换它
***
## 3.2 线程池
命名空间：`System.Threading`
类名：`ThreadPool`（线程池）

在多线程的应用程序开发中，频繁的创建删除线程会带来性能消耗，产生内存垃圾
为了避免这种开销C#推出了 线程池ThreadPool类

ThreadPool中有若干数量的线程，如果有任务需要处理时，会从线程池中获取一个空闲的线程来执行任务
任务执行完毕后线程不会销毁，而是被线程池回收以供后续任务使用
当线程池中所有的线程都在忙碌时，又有新任务要处理时，线程池才会新建一个线程来处理该任务，
如果线程数量达到设置的最大值，任务会排队，等待其他任务释放线程后再执行
线程池能减少线程的创建，节省开销，可以减少GC垃圾回收的触发

线程池相当于就是一个专门装线程的缓存池
优点：节省开销，减少线程的创建，进而有效减少GC触发
缺点：不能控制线程池中线程的执行顺序，也不能获取线程池内线程取消/异常/完成的通知

### 3.2.1 重要方法
1. 获取可用的工作线程数和I/O线程数
```CSharp
int num1;
int num2;
ThreadPool.GetAvailableThreads(out num1, out num2);
```

2. 获取线程池中工作线程的最大数目和I/O线程的最大数目
```CSharp
ThreadPool.GetMaxThreads(out num1, out num2);
```

3. 设置线程池中可以同时处于活动状态的 工作线程的最大数目和I/O线程的最大数目
   - 大于次数的请求将保持排队状态，直到线程池线程变为可用
   - 更改成功返回true，失败返回false
```CSharp
ThreadPool.SetMaxThreads(20, 20);
```

4. 获取线程池中工作线程的最小数目和I/O线程的最小数目
```CSharp
ThreadPool.GetMinThreads(out num1, out num2);
```

5. 设置 工作线程的最小数目和I/O线程的最小数目
```CSharp
ThreadPool.SetMinThreads(5, 5);
```

6. 将方法排入队列以便执行，当线程池中线程变得可用时执行
```CSharp
ThreadPool.QueueUserWorkItem((obj) =>
{
    print(obj);
    print("开启了一个线程");
}, "123452435345");
```
***
## 3.3 Task
命名空间：`System.Threading.Tasks`
类名：`Task`

Task顾名思义就是任务的意思
Task是在线程池基础上进行的改进，它拥有线程池的优点，同时解决了使用线程池不易控制的弊端
它是基于线程池的优点对线程的封装，可以让我们更方便高效的进行多线程开发

简单理解：
- Task的本质是对线程Thread的封装，它的创建遵循线程池的优点，并且可以更方便的让我们控制线程
- 一个Task对象就是一个线程

### 3.3.1 创建无返回值Task的三种方式
1. 通过new一个Task对象传入委托函数并启动
```CSharp
Task t1 = new Task(委托函数/Lambda表达式);
t1.Start();
```
</br>

2. 通过Task中的Run静态方法传入委托函数
```CSharp
Task t2 = Task.Run(委托函数/Lambda表达式);
```
</br>

3. 通过Task.Factory中的StartNew静态方法传入委托函数
```CSharp
Task t3 = Task.Factory.StartNew(委托函数/Lambda表达式);
```

### 3.3.2 创建有返回值的Task
1. 通过new一个Task对象闯入委托函数并启动
```CSharp
//这里可以写各种类型在<>里, 下面的例子同理
//那你写的函数体里就得返回对应的类型数据
//拿下面例子来说, 也就是"委托函数/Lambda表达式"这里面你要返回一个int类型的数据出去
Task<int> t1 = new Task<int>(委托函数/Lambda表达式);
t1.Start();
```

2. 通过Task中的Run静态方法传入委托函数
```CSharp
Task<string> t2 = Task.Run<string>(委托函数/Lambda表达式);
```

3. 通过Task.Factory中的StartNew静态方法传入委托函数
```CSharp
Task<float> t3 = Task.Factory.StartNew<float>(委托函数/Lambda表达式);
```

获取返回值
```CSharp
int ans = t1.Result;
```

**注意**：
- Resut获取结果时会阻塞线程
- 即如果task没有执行完成, 会等待task执行完成获取到Result
- 然后再执行后边的代码,也就是说 执行到这句代码时 由于我们的Task中是死循环, 所以主线程就会被卡死

### 3.3.3 同步执行Task
如果你希望Task能够同步执行
只需要调用Task对象中的`RunSynchronously`方法
注意：需要使用 new Task 对象的方式，因为Run和StartNew在创建时就会启动

```CSharp
Task t = new Task(()=> {
    Thread.Sleep(1000);
    print("哈哈哈");
});

t.RunSynchronously();
print("主线程执行");
```

### 3.3.4 Task中线程阻塞的方式（任务阻塞）
先写个例子
```CSharp
Task t1 = Task.Run(() =>
{
    for (int i = 0; i < 5; i++)
    {
        print("t1:" + i);
    }
});

Task t2 = Task.Run(() =>
{
    for (int i = 0; i < 20; i++)
    {
        print("t2:" + i);
    }
});

//以下三种方法的代码写到这

print("主线程执行");
```
上面例子在正常情况下会先输出"主线程执行",再输出t1和t2的执行输出的内容

至于为什么:
   因为 Task.Run 会将任务放入线程池异步执行，不会阻塞主线程。主线程执行到 print("主线程执行") 时无需等待 t1、t2 完成，所以先输出主线程内容，之后 t1、t2 的异步任务才会在后台线程中陆续执行并输出。

1. Wait方法：等待任务执行完毕，再执行后面的内容
   ```CSharp
   t2.Wait();
   ```
   那上面的例子就是要等t2输出完了再去输出"主线程执行";
</br>

2. WaitAny静态方法：传入任务中任意一个任务结束就继续执行
```CSharp
Task.WaitAny(t1, t2);
```

3. WaitAll静态方法：任务列表中所有任务执行结束就继续执行
```CSharp
Task.WaitAll(t1, t2);
```

### 3.3.5 Task完成后继续其它Task（任务延续）
1. WhenAll静态方法 + ContinueWith方法：传入任务完毕后再执行某任务
   ```CSharp
   Task.WhenAll(t1, t2).ContinueWith((t) =>
   {
      print("一个新的任务开始了");
      
      想执行的代码逻辑
   });
   ```
   或者
   ```CSharp
   Task.Factory.ContinueWhenAll(new Task[] { t1, t2 }, (t) =>
   {
       print("一个新的任务开始了");
       
       想执行的代码逻辑
   });
   ```
</br>

2. WhenAny静态方法 + ContinueWith方法：传入任务只要有一个执行完毕后再执行某任务
   ```CSharp
   Task.WhenAny(t1, t2).ContinueWith((t) =>
   {
      print("一个新的任务开始了");
      
      想执行的代码逻辑
   });
   ```
   或者
   ```CSharp
   Task.Factory.ContinueWhenAny(new Task[] { t1, t2 }, (t) =>
   {
       print("一个新的任务开始了");
       
       想执行的代码逻辑
   });
   ```


### 3.3.6 取消Task执行
方法一：通过加入bool标识 控制线程内死循环的结束

方法二：通过CancellationTokenSource取消标识源类 来控制
CancellationTokenSource对象可以达到延迟取消、取消回调等功能
```CSharp
CancellationTokenSource c = new CancellationTokenSource();

Task.Run(() =>
{
    int i = 0;
    
#region 先看下面
   //延迟5s取消
   c.CancelAfter(5000);
   //取消后回调函数
   c.Token.Register(() =>
   {
      print("任务取消了");
   });
#endregion

    //这里本来是写了一个死循环, 但是我将他换成了CancellationTokenSource标识
    //c.IsCancellationRequested 默认为false

    //while (true)
    while (!c.IsCancellationRequested)
    {
        print("计时：" + i);
        ++i;
        Thread.Sleep(1000);
    }
});

//当执行这句代码时 c.IsCancellationRequested 就会变成true
//那么线程就会停止死循环
c.Cancel();
```
### 3.3.7 总结
1. Task类是基于Thread的封装
2. Task类可以有返回值，Thread没有返回值
3. Task类可以执行后续操作，Thread没有这个功能
4. Task可以更加方便的取消任务，Thread相对更加单一
5. Task具备ThreadPool线程池的优点，更节约性能

***
## 3.4 异步方法Async和Await关键字
同步和异步主要用于修饰方法
- 同步方法：当一个方法被调用时，调用者需要等待该方法执行完毕后返回才能继续执行
- 异步方法：当一个方法被调用时立即返回，并获取一个线程执行该方法内部的逻辑，调用者不用等待该方法执行完毕

### 3.4.1 异步编程适用场景
需要处理的逻辑会严重影响主线程执行的流畅性时, 我们需要使用异步编程

比如：
1. 复杂逻辑计算时
2. 网络下载、网络通讯
3. 资源加载时

### 3.4.2 async和await
async和await一般需要配合Task进行使用
async用于修饰函数、lambda表达式、匿名函数
await用于在函数中和async配对使用,主要作用是等待某个逻辑结束
此时逻辑会返回函数外部继续执行，直到等待的内容执行结束后，再继续执行异步函数内部逻辑
在一个async异步函数中可以有多个await等待关键字


**`使用 async 修饰异步方法`**
1. 在异步方法中使用await关键字（不使用编译器会给出警告但不报错），否则异步方法会以同步方式执行
2. 异步方法名称建议以Async结尾
3. 异步方法的返回值只能是void、Task、Task<>
4. 异步方法中不能声明使用ref或out关键字修饰的变量

**`使用await等待异步内容执行完毕`**（一般和Task配合使用）
遇到await关键字时
1. 异步方法将被挂起
2. 将控制权返回给调用者
3. 当await修饰内容异步执行结束后，继续通过调用者线程执行后面内容

用一个简单的例子来解释
```CSharp
public async void CalcPathAsync()
{
    print("开始处理寻路逻辑");
    await Task.Run(() =>
    {
        //处理复杂逻辑计算
        Thread.Sleep(1000);
        value = 50;
    });

    print("寻路计算完毕 处理逻辑");
}
```

注意：Unity中大部分异步方法是不支持异步关键字async和await的，我们只有使用协同程序进行使用

虽然官方 不支持 但是 存在[第三方工具](https://github.com/svermeulen/Unity3dAsyncAwaitUtil)可以让Unity内部的一些异步加载的方法 支持 异步关键字

***
## 3.5 静态导入
用法：在引用命名空间时，在using关键字后面加入static关键词
作用：无需指定类型名称即可访问其静态成员和嵌套类型
好处：节约代码量，可以写出更简洁的代码

***
## 3.6 异常筛选器
用法：在异常捕获语句块中的Catch语句后通过加入when关键词来筛选异常
when（表达式）该表达式返回值必须为bool值，如果为ture则执行异常处理，如果为false，则不执行

作用：用于筛选异常
好处：帮助我们更准确的排查异常，根据异常类型进行对应的处理

```CSharp
try
{
    //用于检查异常的语句块
}
catch (System.Exception e) when(e.Message.Contains("301"))
{
    //当错误编号为301时  作什么处理
    print(e.Message);
}
catch (System.Exception e) when (e.Message.Contains("404"))
{
    //当错误编号为404时  作什么处理
    print(e.Message);
}
```

***
## 3.7 nameof运算符
用法：nameof(变量、类型、成员)通过该表达式，可以将他们的名称转为字符串
作用：可以得到变量、类、函数等信息的具体字符串名称
***
## 3.8 字面值改进
基本概念：在声明数值变量时，为了方便查看数值
         可以在数值之间插入_作为分隔符
主要作用：方便数值变量的阅读

***
## 3.9 out变量的快捷使用 和 弃元
用法：不需要再使用带有out参数的函数之前，声明对应变量
作用：简化代码，提高开发效率

```CSharp
//1.以前使用带out函数的写法
int a;
int b;
Calc(out a, out b);

//2.现在的写法
Calc(out int x, out int y);

//3.结合var类型更简便(但是这种写法在存在重载时不能正常使用,必须明确调用的是谁)
Calc(out var a, out var b);

//4.可以使用 _弃元符号 省略不想使用的参数
Calc(out int c, out _);
```

***
## 3.10 ref修饰临时变量和返回值
基本概念：使用ref修饰临时变量和函数返回值，可以让赋值变为引用传递
作用：用于修改数据对象中的某些值类型变量

只举一个例子, 值类型变量和结构体我就不写了
```CSharp
//函数返回值
int[] numbers = new int[] { 1, 2, 3, 4, 5, 6, 7, 8 };
ref int number = ref FindNumber(numbers, 5);
number = 999;
print(numbers[4]);
//输出999
//并且这个数组会变成{ 1, 2, 3, 4, 999, 6, 7, 8 }

public ref int FindNumber(int[] numbers, int number)
{
    for (int i = 0; i < numbers.Length; i++)
    {
        if (numbers[i] == number)
            return ref numbers[i];
    }
    return ref numbers[0];
}
```
***
## 3.11  本地函数
基本概念：在函数内部声明一个临时函数
注意：
- 本地函数只能在声明该函数的函数内部使用
- 本地函数可以使用声明自己的函数中的变量

作用：方便逻辑的封装
建议：把本地函数写在主要逻辑的后面，方便代码的查看

```CSharp
public int AddTest(int i)
{
    bool b = false;
    i += 10;
    Calc();
    print(b);//输出true
    return i;//返回(i+20)的结果

   //本地函数
    void Calc()
    {
        i += 10;
        b = true;
    }
}
```
***
## 3.12 抛出表达式
抛出表达式，就是指抛出一个错误
一般的使用方式 都是 throw后面 new 一个异常类

异常基类：`Exception`

```CSharp
throw new NullReferenceException("1231231");
```

**C#自带异常类**
常见:
- IndexOutOfRangeException：当一个数组的下标超出范围时运行时引发。
- NullReferenceException：当一个空对象被引用时运行时引发。
- ArgumentException：方法的参数是非法的
- ArgumentNullException： 一个空参数传递给方法，该方法不能接受该参数
- ArgumentOutOfRangeException： 参数值超出范围
- SystemException：其他用户可处理的异常的基本类
- OutOfMemoryException：内存空间不够
- StackOverflowException 堆栈溢出
</br>

- ArithmeticException：出现算术上溢或者下溢
- ArrayTypeMismatchException：试图在数组中存储错误类型的对象
- BadImageFormatException：图形的格式错误
- DivideByZeroException：除零异常
- DllNotFoundException：找不到引用的DLL
- FormatException：参数格式错误
- InvalidCastException：使用无效的类
- InvalidOperationException：方法的调用时间错误
- MethodAccessException：试图访问思友或者受保护的方法
- MissingMemberException：访问一个无效版本的DLL
- NotFiniteNumberException：对象不是一个有效的成员
- NotSupportedException：调用的方法在类中没有实现
- InvalidOperationException：当对方法的调用对对象的当前状态无效时，由某些方法引发。


***
## 3.13 元组
基本概念：多个值的集合，相当于是一种快速构建数据结构类的方式

一般在函数存在多返回值时可以使用元组 (返回值1类型,返回值2类型,....) 来声明返回值
在函数内部返回具体内容时通过 (返回值1,返回值2,....)  进行返回

主要作用：提升开发效率，更方便的处理多返回值等需要用到多个值时的需求
```CSharp
//1.无变量名元组的声明(获取值：Item'N'作为从左到右依次的参数，N从1开始)
(int, float) yz = (1, 5.5f);
print(yz.Item1);// 输出 1
print(yz.Item2);// 输出 5.5

//2.有变量名元组的声明
(int i, float f) yz2 = (1, 5.5f);
print(yz2.i);// 输出 1
print(yz2.f);// 输出 5.5

//3.元组可以进行等于和不等于的判断
//  数量相同才以及类型相同才比较，每一个参数的比较是通过==比较 如果都是true 则认为两个元组相等
if (yz == yz2)
    print("相等");
else
    print("不相等");

//4. 也可以放在类中作成员变量
public class Test : MonoBehaviour
{
    public (int, float) yz;
}
```

### 3.13.1 应用场景
1. 无变量名函数返回值
```CSharp
var info = GetInfo();

private (string str, int i, float f) GetInfo()
{
    return ("123", 2, 5.5f);
}
```

2. 元组的解构赋值
```CSharp
int myInt;
string myStr;
float myFloat;
(myStr, myInt, myFloat) = GetInfo();
```

3. 丢弃参数
```CSharp
(string ss, _, _) = GetInfo();
```

4. 字典中的键 需要用多个变量来控制
```CSharp
Dictionary<(int i, float f), string> dic = new Dictionary<(int i, float f), string>();
dic.Add((1, 2.5f), "123");

if(dic.ContainsKey((1,2.5f)))
{
    print("存在相同的键");
    print(dic[(1, 2.5f)]);
}
```
***
## 3.14 模式匹配
基本概念：模式匹配时一种语法元素，可以测试一个值是否满足某种条件，并可以从值中提取信息

在C#7中，模式匹配增强了两个现有的语言结构
1. is表达式，is表达式可以在右侧写一个模式语法，而不仅仅是一个类型
2. switch语句中的case

主要作用：节约代码量，提高编程效率

```CSharp
void Start()
{
    //1.常量模式(is 常量)：用于判断输入值是否等于某个值
    object o = 1.5f;
    if(o is 1)
    {
       print("o是1");
    }
    if(o is null)
    {
       print("o是null");
    }
 
    //2.类型模式(is 类型 变量名、case 类型 变量名)：用于判断输入值类型，如 果类型相同，将输入值提取出来
    //判断某一个变量是否是某一个类型，如果满足会将该变量存入你申明的变量中
    if (o is int i)
    {
       print(i);
    }
 
    switch (o)
    {
       case int value:
          print("int:" + value);
          break;
       case float value:
          print("float:" + value);
          break;
       case null:
          print("null");
          break;
       default:
          break;
    }
 
 
    //3.var模式：用于将输入值放入与输入值相同类型的新变量中
    //          相当于是将变量装入一个和自己类型一样的变量中
    if(o is var v) { }//这里的v是object类型的

    //但是它可以这么玩, 可以少声明一个变量去判断
    if (GetInt() is var k && k >= 0 && k <= 10) { }
}



public int GetInt()
{
    return 1;
}
```
***
## 3.15 静态本地函数
静态本地函数就是在本地函数前方加入静态关键字
它的作用就是让本地函数不能够使用访问封闭范围内（也就是上层方法中）的任何变量
作用 让本地函数只能处理逻辑，避免让它通过直接改变上层变量来处理逻辑造成逻辑混乱

```CSharp
public int CalcInfo(int i)
{
    bool b = false;
    i += 10;
    Calc(ref i, ref b);
    return i;

    static void Calc(ref int i, ref bool b)
    {
        i += 10;
        b = true;
    }
}
```
***
## 3.16 Using 声明

**`using声明`**
```CSharp
using(对象声明)
{
   使用对象，语句块结束后 对象将被释放掉
   当语句块结束 会自动帮助我们调用 对象的 Dispose这个方法 让其进行销毁
   using一般都是配合 内存占用比较大 或者 有读写操作时  进行使用的 
}
```

using 声明就是对using（）语法的简写, 当函数执行完毕时 会调用 对象的 Dispose方法 释放对象
```CSharp
using StreamWriter s2 = new StreamWriter("文件路径");
```

利用这个写法 就会在上层语句块执行结束时释放该对象

注意：在使用using语法时，声明的对象必须继承System.IDisposable接口
因为必须具备Dispose方法，所以当声明没有继承该接口的对象时会报错

***
## 3.17 Null 合并赋值
[??操作符的知识回顾在C#高阶的第11条的第6点](/CSharp/知识点/高阶.md)

空合并赋值是C#8.0新加的一个运算符 ??=
类似复合运算符
`左边值 ??= 右边值`
当左侧为空时才会把右侧值赋值给变量

```CSharp
string str = null;

str ??= "666";
print(str);//输出666
//由于左侧为空才会将右侧赋值给变量，所以不为空的变量不会改变
str ??= "1111";
print(str);//输出666
```
***
## 3.18 解构函数Deconstruct
我们可以在自定义类当中声明解构函数
这样我们可以将该自定义类对象利用元组的写法对其进行变量的获取

- 语法：
   在类的内部声明函数public void Deconstruct(out 变量类型 变量名, out 变量类型 变量名.....)
- 特点：
   一个类中可以有多个Deconstruct，但是参数数量不能相同

```CSharp
public class Person
{
    public string name;
    public bool sex;
    public string number;

    public void Deconstruct(out string n, out bool sex) => (n, sex) = (this.name, this.sex);

    public void Deconstruct(out string n, out bool sex, out string number) => (n, sex, number) = (this.name, this.sex, this.number);
}

void Start()
{
    Person p = new Person();
    p.name = "扶离";
    p.sex = false;
    p.email = "shifuliya@163.com";

    //可以对该对象利用元组将其具体的变量值 解构出来
    //相当于把不同的成员变量拆分到不同的临时变量中
    (string nameStr, bool sexBool) = p;
}
```
## 3.19 模式匹配增强功能

### 3.19.1 switch表达式
switch表达式是对有返回值的switch语句的缩写
用=>表达式符号代替case:组合
用_弃元符号代替default
它的使用限制，主要是用于switch语句当中只有一句代码用于返回值时使用

语法：
```CSharp
函数声明 => 变量 switch
{
   常量=>返回值表达式,
   常量=>返回值表达式,
   常量=>返回值表达式,
   ....
   _ => 返回值表达式,
}
```
举个例子:
```CSharp
public enum PosType
{
    Top_Left,
    Top_Right,
    Bottom_Left,
    Bottom_Right,
}

public Vector2 GetPos(PosType type) => type switch
{
    PosType.Top_Left => new Vector2(0, 0),
    PosType.Top_Right => new Vector2(1, 0),
    PosType.Bottom_Left => new Vector2(0, 1),
    PosType.Bottom_Right => new Vector2(1, 1),
    _ => new Vector2(0, 0)
};
```

### 3.19.2 属性模式
就是在常量模式的基础上判断对象上各属性
用法：变量 is {属性:值, 属性:值}

举个例子:
```CSharp
public class DiscountInfo
{
    public string discount;
    public bool isDiscount;

    public DiscountInfo(string discount, bool isDiscount)
    {
        this.discount = discount;
        this.isDiscount = isDiscount;
    }

    public void Deconstruct(out string dis, out bool isDis)
    {
        dis = this.discount;
        isDis = this.isDiscount;
    }
}

void Start()
{
   DiscountInfo info = new DiscountInfo("5折", true);

   if (info is { discount: "6折", isDiscount: true }) { }
}
```

它可以结合switch表达式使用
结合switch使用可以通过属性模式判断条件的组合

```CSharp
public float GetMoney(DiscountInfo info, float money) => info switch
{
    //可以利用属性模式 结合 switch表达式 判断n个条件是否满足
    { discount: "5折", isDiscount: true } => money * .5f,
    { discount: "6折", isDiscount: true } => money * .6f,
    { discount: "7折", isDiscount: true } => money * .7f,
    _ => money
};
```

### 3.19.3 元组模式
属性模式我们可以在switch表达式中判断多个变量同时满足再返回什么
但是它必须是一个数据结构类对象，判断其中的变量
而元组模式可以更简单的完成这样的功能，我们不需要声明数据结构类，可以直接利用元组进行判断
```CSharp
void Start()
{
    print(GetMoney("5折", true, 200));// 输出1000
}

public float GetMoney(string discount, bool isDiscount, float money) => (discount, isDiscount) switch
{
    ("5折", true) => money * .5f,
    ("6折", true) => money * .6f,
    ("7折", true) => money * .7f,
    _ => money
};
```

### 3.19.4 位置模式
如果自定义类中实现了解构函数
那么就可以直接用对应类对象与元组进行is判断
```CSharp
public class DiscountInfo
{
    public string discount;
    public bool isDiscount;

    public DiscountInfo(string discount, bool isDiscount)
    {
        this.discount = discount;
        this.isDiscount = isDiscount;
    }

    //新增解构函数
    public void Deconstruct(out string dis, out bool isDis)
    {
        dis = this.discount;
        isDis = this.isDiscount;
    }
}

void Start()
{
    DiscountInfo info = new DiscountInfo("5折", true);

    if(info is ("5折", true)) { 处理逻辑 }
}
```

同样也可以配合switch表达式来处理逻辑
```CSharp
//与上面元组模式的区别在于传入参数更加方便了
public float GetMoney(DiscountInfo info, float money) => info switch
{
    ("5折", true) => money * .5f,
    ("6折", true) => money * .6f,
    ("7折", true) => money * .7f,
    _ => money
};

void Start()
{
    print(GetMoney(info, 300));//150
}
```

补充：配合when关键字进行逻辑处理
```CSharp
public float GetMoney(DiscountInfo info, float money) => info switch
{
    (string dis, bool isDis) when dis == "5折" && isDis => money * .5f,
    (string dis, bool isDis) when dis == "6折" && isDis => money * .6f,
    (string dis, bool isDis) when dis == "7折" && isDis => money * .7f,
    _ => money
};
```
***
# 四. 其他补充

## 4.1 日期和时间
我们可以通过Time获取当前游戏相关的时间
比如帧间隔时间，游戏运行的时间和帧数等等内容

但这里讲解的是真实世界时间相关的内容
比如如何得知当前时间的 年、月、日、时、分、秒

而C#便提供了对应的结构方便我们处理时间相关逻辑
1. DateTime 日期结构体
2. TimeSpan 时间跨度结构体

### 4.1.1 名词解释
1. 单位转换
1s秒 = 1000ms毫秒
1ms毫秒 = 1000μs微妙
1μs微妙 = 1000ns纳秒
</br>

2. 格里高利历:
格里高利历一般指公元
公元，即公历纪年法
目前我们所说公历，就是格里高利历
</br>

3. 格林尼治时间(GMT)：
格林尼治标准时间
是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线
地球每天的自转是有些不规则的，而且正在缓慢减速
所以，格林尼治时间已经不再被作为标准时间使用
现在的标准时间──协调世界时（UTC）
</br>

4. 协调世界时(UTC):
又称世界统一时间、世界标准时间、国际协调时间
UTC协调世界时即格林尼治平太阳时间，是指格林尼治所在地的标准时间，
也是表示地球自转速率的一种形式
UTC基于国际原子时间，通过不规则的加入闰秒来抵消地球自转变慢的影响，是世界上调节时钟和时间的主要时间标准
</br>

5. 时间戳
从1970年1月1日（UNIX时间戳的起点时间）到现在的时间
计算机时间和众多的编程语言的时间都是从1970年1月1日开始算起
是因为很多编程语言起源于UNIX系统，而UNIX系统认为1970年1月1日0点是时间纪元
所以我们常说的UNIX时间戳是以1970年1月1日0点为计时起点时间的

### 4.1.2 DateTime
[一定会用到的官方文档](https://learn.microsoft.com/zh-cn/dotnet/standard/base-types/standard-date-and-time-format-strings)


命名空间：`System`
- `DateTime` 是 C# 提供给我们处理日期和时间的结构体
- `DateTime` 对象的默认值和最小值是0001年1月1日00:00:00（午夜）
         最大值可以是9999年12月31日晚上11:59:59
</br>

- 主要参数：
  - 年、月、日、时、分、秒、毫秒
  - ticks：以格里高利历00:00:00.000年1月1日以来的100纳秒间隔数表示,一般是很大的数字
- 次要参数：
  - DateTimeKind：日期时间种类
    - Local：本地时间
    - Utc：UTC时间
    - Unspecified：不指定
- Calendar:日历
  - 使用哪个国家的日历，一般在Unity开发中不使用

**`初始化`**
```CSharp
DateTime dt = new DateTime(2025, 10, 1, 9, 30, 45, 500);

//年、月、日、时、分、秒、毫秒
print(dt.Year + "-" + dt.Month + "-" + dt.Day + 
        "-" + dt.Hour + "-" + dt.Minute + "-" + dt.Second + "-" + dt.Millisecond);
```
**`获取时间`**
```CSharp
//当前日期和时间
DateTime nowTime = DateTime.Now;
print(nowTime.Minute);

//返回今日日期
DateTime nowTime2 = DateTime.Today;
print(nowTime2.Year + "-" + nowTime2.Month + "-" + nowTime2.Day);

//返回当前UTC日期和时间
DateTime nowTimeUTC = DateTime.UtcNow;
```

**`计算时间`**
```CSharp
//加各种单位的时间
DateTime nowTime3 = nowTime.AddDays(-1);
print(nowTime3.Day);
```

**`字符串输出`**
```CSharp
print(nowTime.ToString());
print(nowTime.ToShortTimeString());
print(nowTime.ToShortDateString());
print(nowTime.ToLongTimeString());
print(nowTime.ToLongDateString());

print(nowTime.ToString("D"));
print(nowTime.ToString("yyyy-MM-dd-ddd/HH-mm-ss"));
```

**`字符串转DateTime`**
字符串想要转回DateTime成功的话 
那这个字符串一定是最基本的 toString的转换出来的字符串才能转回去
```CSharp
string str = nowTime.ToString();
str = "1931/9/18 10:20:00";
print(str);//勿忘国耻

DateTime dt3;
if(DateTime.TryParse(str, out dt3)) { 处理逻辑 }
```

**`存储时间`**
1. 以直接存字符串
2. 可以直接存Ticks
3. 可以直接存时间戳信息

### 4.1.3 TimeSpan
命名空间：`System`
`TimeSpan` 是 C# 提供给我们的时间跨度结构体
用两个`DateTime`对象相减 可以得到该对象

```CSharp
TimeSpan ts = DateTime.Now - new DateTime(1970, 1, 1);

//输出各种信息
print(ts.TotalMinutes);
print(ts.TotalSeconds);
print(ts.TotalDays);
print(ts.TotalHours);
print(ts.Ticks);
```

**`初始化它来代表时间间隔`**
```CSharp
TimeSpan ts2 = new TimeSpan(1,0,0,0);
DateTime timeNow = DateTime.Now + ts2;
```

**`用它相互计算`**
```CSharp
TimeSpan ts3 = new TimeSpan(0, 1, 1, 1);
TimeSpan ts4 = ts2 + ts3;
print(ts4.Days + "-" + ts4.Hours); // 1-1
```

**`自带常量方便用于和ticks进行计算`**
```CSharp
print(ts4.Ticks / TimeSpan.TicksPerSecond);
```

举个例子
```CSharp
//用当前时间加上2天 再 减去 1970年1月1日的时间 得到时间差
TimeSpan time = DateTime.Now.AddDays(2) - new DateTime(1970,1,1);
//再将该时间差转换为秒 便得到最终的时间戳 我们只需要存储该int变量即可
int timeStamp = (int)(time.Ticks / TimeSpan.TicksPerSecond);

//由于时间戳的单位为秒，所以我们将其乘以转换常量 转为为ticks的单位
TimeSpan time2 = new TimeSpan(timeStamp * TimeSpan.TicksPerSecond);
//再用1970年1月1日+上该时间跨度即可
DateTime date = new DateTime(1970, 1, 1) + time2;


//每次打开面板时计算目标时间和当前时间的秒数差 
//在面板中对显示内容进行更新 
//注意：不要在更新函数中不停用DateTime.Now来计算，浪费性能。我们只需要在面板打开时计算一次时间差
//之后 用该时间差进行计算即可
int seconds = (int)(date - DateTime.Now).TotalSeconds;
```