[toc]
***
# 1.枚举

## 概念
- 枚举是一个被命名的int常量集合
```csharp
enum E_枚举名
{
    枚举项名,    //整形常量  第一个默认为0 ,下面依次累加
    枚举项名1,    
    枚举项名2    
}
```
## 声明位置
- 在namespace定义域中声明枚举类(通常)
- 在class和struct中声明(不常用)

## 类型转换
- 转int : 括号强转
- 转string : 后接ToString();
- string转枚举: `Enum.Parse(目标类型,"字符")`,如:`Enum.Parse(typeof(E_Monster),"boss")`
***
# 2.数组
## 概念
- 存储一组相同类型数据的集合

## 数组的声明
```Csharp
int[] arr1; // 声明,未开辟空间

int[] arr2 = new int[5]; //定义,堆上开辟5个int空间

int[] arr3 = new int[5]{1, 2, 3, 4, 5}; //定义顺便初始化

int[] arr4 = new int[]{1, 2, 3, 4, 5}; //隐式定义长度

int[] arr5 = {1, 2, 3, 4, 5}; //隐式构造, 这是语法糖，编译器会自动推断为 new int[]{1, 2, 3, 4, 5}
```

***
# 3.二维数组
```csharp
int [,] arr = new int[3,3];
```
## 交错数组
```csharp
int [][] arr = new int[3][];
//变量类型[][] 交错数组名 = new 变量类型[行数][]{一维数组1, 一维数组2, ....}
int[][] arr3 = new int[3][] { new int[] { 1, 2, 3 },
                              new int[] { 1,2},
                              new int[] { 1} };
//数组的个数
Console.WriteLine(arr3.GetLength(0));
//行数
Console.WriteLine(arr3[0].Length);

```
***
# 4.值类型和引用类型
- 引用类型: string, 数组, class
- 值类型: struct
## string
```Csharp
string str = "123";
string str2 = str;
str2 = "321";
```
- 以上代码中str和str2在执行到第二行代码时,指向的内存地址是一样的,也就是说C#中对于string类型是浅拷贝,但是当你执行到第三行时,由于C#中string对象是不可变的,所以会创建一个新的字符串对象,并将str2指向新的"321"对象上
- 而对于C++来说,std::string是深拷贝,在创建的同时就已经开辟新的内存空间了,并将原来的string对象中的内存表示复制到自己的内存中,所以同样的代码在C++中虽然结果一样,但是有本质上的区别
- C#的string对象声明是在堆上的,而C++的std::string是在栈上的
***
# 5.ref和out
- 参数的修饰符,让值传递变为引用传递
```Csharp
static void ChangeValueRef(ref int a)
{
    a = 99;
}

static void Main(string[] args)
{
    int a = 0;
    ChangeValueRef(ref a);
    Console.WriteLine(a);//99
}
```
- ref传入的变量必须初始化,out不用
- out传入的变量必须在函数内部赋值,ref不用
- 且在变量已经初始化的情况下,传入out的参数,如果不在函数内部给它重新赋值,是会报错的
```Csharp
static void ChangeValueRef(ref int a)
{
    a = 99;
}
static void ChangeValueout(out int a) //控制离开当前方法之前必须对out参数a赋值
{
     
}

static void Main(string[] args)
{
    int a = 0;
    ChangeValueRef(ref a);
    ChangeValueout(out a);
    Console.WriteLine(a);
}
```
***
# 5.变长参数关键字
- params关键字后面必为数组,数组类型可以是任意类型
- 函数参数中最多出现一个params关键字,并且一定是在最后
```Csharp
static void Eat(string name,params string[] things) {}
```
- params 修饰的数组参数最少支持 0 个元素。
```Csharp
public void PrintNumbers(params int[] numbers)
{
    foreach (var number in numbers)
    {
        Console.WriteLine(number);
    }
    Console.WriteLine($"元素个数: {numbers.Length}");
}

// 调用方式：
PrintNumbers();           // 0 个元素 - 完全有效
PrintNumbers(1);          // 1 个元素
PrintNumbers(1, 2, 3);    // 3 个元素
```

- 默认参数(可选参数)
```Csharp
static void speak(string str = "屋檐")
```
- 支持多参数默认值,每个参数都可以有默认值
- 如果要混用,可选参数必须写在普通参数后面
***
# 6.函数重载
- 函数名相同,参数的顺序或数量不同
- 命名一组功能相似的函数,减少函数名的数量,避免命名空间的污染
***
# 7.struct 
- 结构体是一种自定义变量类型,是数据和函数的集合
- 一般写在namespace作用域中
</br>

- 在结构体中声明的**变量不能直接初始化**
- 变量类型可以写任意类型(包括结构体),但是不能是自己的结构体
- 在结构体中的方法,目前不需要加static关键字,当学到后面了不一定
- 结构体里默认为private
</br>

- 结构体的构造函数
  - 函数名和结构体名相同, 没有返回值
  - 必须有参数
  - **如果声明了构造函数,就必须对所有变量数据进行初始化**
</br>
  
为什么必须要进行初始化? 值类型（结构体）的核心特性是 “值语义”：变量直接存储数据本身，而非引用。这种特性要求值类型在创建后 状态必须确定（否则复制、传递时会出现不可预期的 “半初始化” 状态）。
</br>

- 为了解决构造函数的传参与结构体内部变量名一致而导致的变量赋值错误,需引入this关键字代表结构体自己

## 来自后期的自己
### 在类中定义一个有参构造函数后就无法调用无参构造函数了,但是为什么结构体可以?

**核心原因：结构体总是有一个隐式的无参数构造函数**

- 即使你定义了有参构造函数，结构体仍然有一个编译器自动提供的默认无参构造函数，这个构造函数会将所有字段初始化为默认值。

**结构体的特殊规则**
- 编译器总是为结构体生成默认无参构造函数
- 这个默认构造函数不能被显式定义或重写
- 它会将所有字段设置为默认值（0、false、null等）

**为什么结构体有这样的设计？**
1. 值类型的本质要求
结构体是值类型，必须保证在任何情况下都能被正确初始化。即使没有显式调用构造函数，内存分配时也需要有确定的值。

2. 性能优化
结构体通常用于高性能场景，隐式的默认构造函数避免了不必要的初始化开销。

3. 与.NET底层兼容
在IL层面，值类型总是有默认构造函数来确保内存的确定性。

***