[toc]
***
# 1.面向对象
- 封装: 用程序语言来形容对象
- 继承: 复用封装对象的代码
- 多态: 同样行为的不同表现
***
# 2.封装
声明在namespace作用域中
***
## 2.1类声明的语法
```Csharp
class 类名
{
    //特征--成员变量
    //行为--成员方法
    //保护特征--成员属性

    //构造函数和析构函数
    //索引器
    //运算符重载
    //静态成员
}
```
***
## 2.2成员变量
**在类中是可以声明的变量类型为自己的类名的,和struct也正好相反**

- 为什么?
  - 类的实例通过new关键字在堆上创建，创建时会触发构造函数执行。反面就是不new就不构造,那也就是说内存时有限的
  - 再考虑类型,类是引用类型,结构体是值类型,那考虑`Person p;`这句代码,p就是一个引用,引用的内存是固定的,实例分配到堆上,那么你没赋值也就没构造
    ```Csharp
    public class Person{ Person p; }
    ```
  - 结构体是值类型，它的实例通常分配在栈上,而编译器需要为每个结构体类型计算一个确定的大小。
    ```Csharp
    public struct Person{ Person p; }
    ```
  - 这会产生一个递归的、无限大小的类型定义
  - 编译器无法计算出这个结构体到底需要多少字节的内存，因此会报错

**在类中是可以初始化变量的,这和struct正好相反**

- 为什么?
  - 类的实例在堆上分配，编译器会确保所有这些初始化代码被插入到每个构造函数的最开始处, 初始化发生在对象构造时，有明确的生命周期控制
  - 结构体经常在栈上分配，没有明确的构造时机,结构体必须保证即使没有调用构造函数，所有字段也有默认值（0或null）,编译器会自动为所有字段赋默认值,但是有不能显式初始化,这样就会造成歧义

OK,看完上面两条,相信你可能有疑问: 那我初始化类型为自己的类名的变量,类里面不就跟struct一样有递归了吗?

你说的对,所以又引入一个新知识点: **对于成员变量类型是自己的类时是不能对其进行初始化的**,虽然不会报错,但是这个操作是危险的,所以上面的理论都是基于这一点来说的(我是不是应该把这条写到上面?)

```Csharp
public class Person
{ 
    Person p = new Person(); // 这个是不行的
    Person p = null; //这个是可以的
}
```

### 补充:
  - 类中声明自身类型成员时，虽然语法允许，但实际使用时需避免 “无限递归实例化”（如 Person p = new Person()），否则会导致栈溢出（StackOverflowException）。而 Person p = null 是安全的，因为它只是一个未指向任何对象的引用。
  - 结构体的构造函数必须显式初始化所有成员，这是为了保证值类型的确定性 —— 无论通过哪种方式创建结构体，其成员都有明确的值，避免未定义行为。说人话就是,结构体里的成员变量不能初始化赋值,但是在结构体里的构造函数你要赋值就必须把所有的成员变量都给赋值了
***
## 2.3成员变量的初始值
- 值类型: 默认值是0
- 引用类型: 默认值是null
- defult(变量类型) 就能得到类型的默认值
***
## 2.4访问修饰符
- public: 公共的
- private: 私有的  允许内部访问
- protect: 受保护的  运行内部和子类访问
***
## 2.5成员方法
- 成员方法目前不加static,到static知识点的时候具体分析
- 成员方法必须实例化出对象,再通过对象来使用
- 成员方法受访问修饰符影响
***
## 2.6默认访问级别
- 类的成员：默认是 private
- 结构体的成员：默认是 private
- 类本身和结构体本身：默认是 internal

internal，意思是"在同一程序集内可访问"。
在类和结构体内部，字段、方法、属性等成员默认都是 private

在类和结构体前加上public或private，不会直接影响其内部成员的访问级别，但它会控制"谁能看到这个类"，从而间接影响成员的可访问性。

一个项目 == 一个程序集 , 每个.csproj文件(打开你项目所在的文件夹就知道了)编译后就是一个程序集。同一项目内的代码都在同一程序集中，可以互相访问internal成员。不同项目之间需要添加引用才能访问public成员。

***
## 2.7构造函数,析构函数,GC
### 构造函数
在实例化对象时,会调用构造函数用于初始化
如果不写,默认存在一个无参的构造函数

- 没有返回值
- 函数名和类名相同
- 没有特殊需求时,一般是public
- 构造函数可以被重载
- 如果不自己实现无参的构造函数而实现了有参构造的函数,就会失去默认的无参构造函数

**类中是允许声明无参构造函数的,而结构体不允许**

#### 构造函数的特殊写法
`构造函数名(参数列表) : this(参数1,参数2,...)`
```Csharp
class Student
{
    string name;
    int age;

    public Student()
    {
        name = "Cherno";
        age = 10;
    }

    public Student(int age)
    {
        this.age = age;
    }

    public Student(string name, int age) : this() //先调用public Student()
    { 
    }

    public Student(string name, int age) : this(age) // 先调用public Student(int age)
    { 
    }
}
```
- 这样写会调用后面的构造函数,再调用当前的构造函数

### 析构函数
对于像C++这样需要手动管理内存的语言,需要在析构函数中做一些内存回收处理
但是C#存在GC,几乎不怎么使用析构

### GC
垃圾回收的过程是在遍历堆(Heap)上的动态分配的所有对象
通过识别它们是否被引用来确定哪些对象是垃圾,哪些对象仍要被使用
所谓垃圾就是没有被任何变量,对象引用的内容, 垃圾就需要被回收释放

GC有很多算法
- 引用计数
- 标记清除
- 标记整理
- 复制集合

GC只负责堆内存的垃圾回收
引用类型都是存在堆中的,所以它的分配和释放都是通过垃圾回收机制来管理的

栈上的内存是由系统自动管理的
值类型在栈中分配内存,它们有自己的生命周期,不用对它们进行管理,会自动分配和释放

#### C#的GC
- 首先会将堆内存分成三代(0代,1代,2代)
  - 代是垃圾回收机制的一种算法
- 新分配的对象会被配置到第0代内存中
- 每次分配都可能会进行垃圾回收以释放内存
</br>

- 在一次内存回收过程开始时,垃圾回收器会认为堆中全是垃圾,会进行以下两步:
  1. 标记对象: 从根(静态字段,方法参数)开始检查引用对象,标记后变为可达对象,未标记的为不可达
  2. 搬迁对象压缩堆: (挂起执行托管代码线程) 释放未标记对象,搬迁可达对象,修改引用地址
</br>

- 内存较大的对象总被认为是第二代内存,目的是减少性能损耗
- 不会对大对象进行搬迁压缩,83kb以上的对象被认为是大对象
</br>

- 当前代内存满时会触发GC,释放当前代及处于其下的代的内存
- 说人话就是:
  - 0代满了,释放0代内存, 并使可达对象升代
  - 1代满了,释放0代和1代内存, 并使可达对象升代(原本0代可达的到1代,原本1代可达的到2代)
  - 2代满了,释放0代,1代和2代的内存,该升代的升代,该保留的保留(原本2代的可达保留在2代,原本1代的可达升至2代,原本0代的升至1代)
</br>

- 了解了GC机制后,就易明白
  - 0代内存释放的频率最高,1代次之,2代最低
  - 2代内存很大,用于存放所以经过分代淘汰的所筛选下来的可达对象 
  - 大对象每次释放消耗的内存较大,每次释放都会消耗CPU,使性能降低

手动触发GC的方式: `GC.Collect();`
但是GC是很耗性能的
***
## 2.8成员属性
### 概念
- 用于保护成员变量
- 为成员属性的获取和赋值添加逻辑处理
- 属性可以让成员变量在外部((只能获取不能修改) || (只能修改不能获取))
- 属性命名一般使用帕斯卡命名

### 语法
```Csharp
访问修饰符 属性类型 属性名
{
    get{}
    set{}
}
```
- `value`关键字(仅限在set作用域中), 用于表示外部传入的值,所以`value`的类型肯定是和属性类型一致

### get和set前可以加访问修饰符
- 不加,默认使用属性声明时的访问修饰符
- 加的访问修饰符要低于属性的访问权限
- 不能让get和set的访问权限都低于属性的权限 
- get和set可以只有一个,那就没必要在前面加访问修饰符了

### 自动属性
- 作用: 如果类中有一个特征是希望外部能得不能改,并且没有什么特殊处理,那么可以直接使用自动属性
```Csharp
public string name{get; private set;}
```
***
## 2.9索引器
### 作用
让对象可以像数组一样通过索引访问其中元素,使程序看起来更直观,更容易编写

### 语法
```csharp
访问修饰符 返回值 this[参数类型 参数名,参数类型 参数名...]
{
    get{}
    set{}
}
```
- 上面的例子不直观,看下面的
```Csharp
class Person
{
    string name;
    int age;
    Person[] friends;

    public Person this[int index]
    {
        get 
        {
            return friends[index];
        }
        set 
        {
            friends[index] = value;
        }
    }
}

static void Main(string[] args)
{
    Person p = new Person();
    p[0] = new Person();
}
```
- 以上解决了什么问题呢? 思考一下,如果没有定义索引器
- 那你访问friends中的元素,要么把friends用属性给包裹起来,要么加上public
- 再进一步想,这个代码中的get中index如果非法不就报错了吗? 所以索引器中也是可以去组织自己的逻辑的(set也同理),比如写成这样
```csharp
get
{
    if(friends == null || friends.Length - 1 < index)
        return null;
    return friends[index];
}
```
### 索引器重载
```csharp
class Person
{
    string name;
    int age;
    Person[] friends;
    int[,] array;

    public int this[int i, int j]
    {
        get { return array[i, j];}
        set { array[i, j] = value;}
    }

    public Person this[int index]
    {
        get { return friends[index];}
        set { friends[index] = value;}
    }
} 
```
***
## 2.10静态成员
静态成员的特点: 直接用类名点出来直接使用

静态成员大部分是公共的

```csharp
public class Test
{
    static public float PI = 3.1415926f;
    public int testInt = 5;

    static public float CalcuCircie(float r){return PI * r * r;}
    public void TestFun(){Console.WriteLine("Test");}
}

static void Main(string[] args)
{
    Console.WriteLine(Test.PI);
    Console.WriteLine(Test.CalcuCircie(2));

    Test t = new Test();
    Console.WriteLine(t.testInt);
    t.TestFun();
}

```
根据以上代码可以发现,静态的成员变量或成员函数不用实例化就能调用,而非静态的需要实例化

### 为什么可以直接使用
- 程序在开始进行时,就会分配内存空间
- 静态成员的生命周期和程序一致,也就是程序开始运行到程序结束
- 因此,静态成员就会有一个唯一的内存空间来存储,进而让静态成员有了唯一性
- 只要静态成员是公共的,那它也就有全局性
</br>

### 静态与非静态
1. 非静态成员变量与静态函数的生命周期不一致
2. 非静态成员变量只能将对象实例化出来后才能使用
3. 静态方法中不能直接访问实例成员，因为不知道要操作哪个对象

根据以上三条可知,静态函数中不能使用非静态成员,如果非要使用,就只能先实例化对象后再用,如下
```CSharp
public class Test
{
    static public float PI = 3.1415926f;
    public int testInt = 5;

    static public float CalcuCircie(float r)
    {
        Test t = new Test();
        t.testInt = 20;

        return PI * r * r;
    }
}
```
所以理解上面后,下面这句话也就好理解了
- 非静态函数可以使用静态成员

### 作用
1. 常用的唯一变量的声明
2. 方便快速的获取对象声明

### const和static
- 常量初始化必须赋值,静态变量不用
- 常量不能后期修改,静态变量可以
- const只能修饰变量
- const一定是写在访问修饰符后面的
- 它们都可以通过类名点出来用

const(常量)可以理解为特殊的static(静态)(只是"理解为",可不是等同)

### 简单单例实现
- 以下不是单例的实现,但思路接近了
- 一个类对象,在整个应用程序的成名周期中,有且仅有一个该对象的存在,不能在外部实例化,直接通过该类类名就能够得到唯一的对象
```CSharp
//简单基本单例
namespace _5静态成员
{
    class Object
    {
        private static Object obj = new Object(); 
        public int testInt  = 20;
        public static Object Obj
        {
            get
            {
                return obj;
            }
        }

        private Object() { }
    }

    internal class Class2
    {
        static void Main(string[] args)
        {
            Console.WriteLine(Object.Obj.testInt);
        }
    }
}
```
***
## 2.11静态类和静态构造函数

### 静态类
- 只能包含静态成员
- 不能实例化

#### 作用
1. 将常用的静态成员写在静态类中,方便使用
2. 静态类不能实例化,更能体现工具类的唯一性,比如: Console就是一个静态类

一般情况下静态类里的成员或者方法都是公共的,除非要在类里面去实现或处理一些逻辑

### 静态构造函数
- 静态类和普通类都可以有
- 不能使用访问修饰符
- 不能有参数
- 不管是在静态类中还是在非静态类中,当你第一次使用了类中的内容时,就会自动调用一次,且只会调用一次

#### 作用
在静态构造函数中初始化静态变量

## 2.11拓展方法
### 概念
为现有的**非静态变量类型**添加新方法

### 作用
1. 不需要在对象中重新写方法
2. 不需要继承来添加方法
3. 为别人封装的类型写额外的方法

### 特点
1. **一定是写在静态类中**
2. **一定是静态函数**
3. 第一个参数为拓展目标
4. 第一个参数用this修饰
5. 拓展方法与原方法重名的话,优先调用原方法,拓展方法就没有用了

### 语法
```CSharp
访问修饰符 static 返回值 函数名(this 拓展类名 参数名,参数类型 参数名,参数类型 参数名...)
```

```CSharp
namespace _7拓展方法
{
    class Ticktet
    {
        public int num1 { get; set; }
        public int num2 { get; set; }

    }

    static class Expend
    {
        public static int Add(this Ticktet t, int a, int b)
        {
            t.num1 = a;
            t.num2 = b;
            return t.num1 + t.num2;
        }
    }

    internal class Class1
    {
        static void Main(string[] args)
        {
            Ticktet t = new Ticktet();
            Console.WriteLine(t.Add(3,5)); //在原来的类的基础,在外部拓展了方法
            Console.WriteLine(Expend.Add(t,4,5));
        }
    }
}
```
***
## 2.12重载运算符
### 特点
1. 一定是一个**公共的静态方法**
2. 返回值写在operator前
3. 逻辑处理自定义

### 作用
让自定义类和结构体对象可以进行运算

!!! important 注意
    1. 条件运算符需要成对实现
    2. 一个符号可以多个重载
    3. **不能使用ref和out**
    4. 参数列表中必须至少一个当前类类型的参数

### 语法
```CSharp
public static 返回类型 operator 运算符(参数列表)
```
```CSharp
struct Vector2
{
    public int x; 
    public int y;

    public static Vector2 operator +(Vector2 v1,Vector2 v2)
    {
        Vector2 v = new Vector2();
        v.x = v1.x + v2.x;
        v.y = v2.y + v2.y;
        return v;
    }
}
```
### 可重载和不可重载的运算符
- 条件运算符,比如`>`和`<`,`<=`和`>=`等,必须配对实现;就比如说你重载了`>`,你就必须同时重载`<`,不然就报错
- 逻辑或`&&` 逻辑或`||`,索引符`[]`,强转运算符`()`,特殊运算符,三目运算符等都不能重载
***
## 2.13内部类和分部类

### 内部类
在一个类中再声明一个类

- 使用时要用包裹者点出自己
- 访问修饰符的作用很大

### 分部类
把一个类分成几部分声明

!!! important 注意
    - 关键字为**partial**
    - 分部描述一个类,提高程序的拓展性
    - 分部类可以写在多个脚本文件中
    - 分部类的访问修饰符要一致
    - 分部类中不能有重复成员


### 分部方法
将方法的声明和实现分离

**特点**
- 不能加访问修饰符,默认私有
- 只能在分部类中声明
- 返回值只能是void
- 可以有参数,但是不能用out关键字 
***
# 3.继承
- 一个类A继承一个类B, 类A将会继承类B的所有成员, A类将拥有B类的所有特征和行为
- 子类可以有自己的特征和行为
- 单根性: 子类只能有一个父类
- 传递性: 子类可以间接继承父类的父类

***
## 3.1继承的基本语法
```CSharp
class 类名 : 被继承的类名{  }
```
!!! important 子类和父类符同名成员
    C#中允许子类存在和父类同名的成员, 但是不建议使用
***
## 3.2里氏替换原则
任何父类出现的地方,子类都可以替代

!!!important 重点
    父类容器装子类对象,因为子类对象包含了父类的所有内容

**作用:**
方便进行对象的存储和管理

```CSharp
class GameObject { }

class Player:GameObject
{
    public void PlayerAtk() { Console.WriteLine("Player攻击!"); }
}
class Monster:GameObject
{
    public void MonsterAtk() { Console.WriteLine("Monster攻击!"); }
}

internal class Class1
{
    static void Main(string[] args)
    {
        //里氏替换原则
        GameObject player = new Player();
        GameObject monster = new Monster();
    }
}
```
根据以上代码你会发现,`player`的容器是`GameObject`(父类),`player`是`Player`(子类)对象,照理说`player`是拥有`PlayerAtk()`这个方法的,但是当你写
```CSharp
player.PlayerAtk();
```
这句代码时,你会发现是报错的,解决方法看下面

### is和as
`is`: 判断一个对象是否是指定的类对象,返回值为bool类型
`as`: 将一个对象转换为指定类对象,返回值为指定类型对象,返回失败时为null

```CSharp
类对象 is 类名
类对象 as 类名
```
回到上面的报错,解决方法为
```CSharp
if(player is Player)
{
    (player as Player).PlayerAtk();
}
```
此时就调用成功了

至此,里氏替换原则就差不多了,学完感觉挺鸡肋啊
其实它的主要使用场景如下:
```CSharp
class GameObject { }

class Player:GameObject
{
    public void PlayerAtk() { Console.WriteLine("Player攻击!"); }
}
class Monster:GameObject
{
    public void MonsterAtk() { Console.WriteLine("Monster攻击!"); }
}

internal class Class1
{
    static void Main(string[] args)
    {
        //假设有一个GameObject数组,你不能清楚的知道里面的每一个元素的类型
        GameObject[] objects = { new Player(), new Monster(), new Player() };//这里明确定义了元素是为了偷懒,明白意思就行

        for (int i = 0; i < objects.Length; ++i)
        {
            if (objects[i] is Player)
            {
                //这里就可以写Player的逻辑
            }
            else if (objects[i] is Monster)
            {
                //这里就可以写Monster的逻辑
            }
        }
    }
}
```
**再来个具体的场景吧**
在游戏中有一个场景里又有玩家又有怪物还有NPC,但是它们的基类都是一样的,如果你想一下管理上面所有类型的对象,你完全可以用它们公共的基类容器去存储这个场景里所有的对象,然后通过is和as来决定它们各自需要处理的逻辑

***
## 3.3继承中的构造函数
**特点**
- 当声明一个子类对象时,先执行父类的构造函数再执行子类的构造函数
- 父类的无参构造很重要
- 子类可以通过Base关键字 代表父类 调用父类构造

```CSharp
 class GameObject
 {
     public GameObject()
     {
         Console.WriteLine("GameObject构造");
     }
 }
 class Player : GameObject
 {
     public Player()
     {
         Console.WriteLine("Player构造");
     }
 }
 class MainPlayer : Player
 {
     public MainPlayer()
     {
         Console.WriteLine("MainPlayer构造");
     }
 }

 internal class Class1
 {
     static void Main(string[] args)
     {
         MainPlayer mainPlayer = new MainPlayer();
     }
 }
```
- 输出为
```CSharp
GameObject构造
Player构造
MainPlayer构造
```
### 父类无参构造的重要性
在实例化子类对象时,默认会调用父类的无参构造函数,而当你在父类中没有实现无参构造,且实现了有参构造时,无参构造函数就会失效,此时子类在继承时就会报错

那如果我想让子类在实例化时调用你指定的父类中的构造函数(不管是有参的还是无参的),看下面

### base关键字
- 和this在构造函数上的用法相似
- 可以指定父类中的构造函数
- 子类构造函数, 你不管是直接还是间接,是默认还是指定,都需要有相关联的父类构造函数
```CSharp
class Father
{
    public Father(int i)
    {
        Console.WriteLine("父类有参构造");
    }
}
class Son : Father
{
    public Son(int i) : base(i) // 这里指定的就是父类的public Father(int i)构造函数
    {
        Console.WriteLine("子类有参构造");
    }

    public Son(int i, string str) : this(i) //间接调用父类构造
    { 
    }
}
```
***
## 3.4object和拆装箱
### 所有类型的最终基类
- 关键字: `object`
- `object`是所有类型的基类,它是一个类(引用类型)
- 可以利用里氏替换原则,用object容器装所有对象
- 可以用来表示不确定的类型,作为函数参数类型
</br>

```CSharp
class Base{ public void Fun() { } }

internal class Class1
{
    static void Main(string[] args)
    {
        //引用类型及其转换
        object o = new Base();
        if (o is Base)
            (o as Base).Fun();

        //值类型及其转换
        object o1 = 1f;
        float f = (float)o1;

        //string类型
        object o2 = "123";
        string str = o2.ToString();
        string str1 = o2 as string;//推荐

        //数组
        object o3 = new int[10];
        int[] arr1 = (int[])o3;
        int[] arr2 = o3 as int[];//推荐
    }
}
```
- 为什么推荐? 因为好记: 值类型就括号强转,引用类型就用`as`
### 装箱和拆箱
**发生的条件**
- 用object存值类型(装箱)
- 用object存引用类型(拆箱)

**装箱**
把值类型存储在引用类型中,栈内存会迁移到堆内存

**拆箱**
把引用类型存储的值类型取出来,堆内存会迁移到栈内存

**优缺点**
- 不确定类型时可以方便参数的存储和传递
- 内存迁移,性能消耗大

**看下面的例子**
- 上面说的方便在哪? 看下面代码中的`TestFun`函数
- 是个东西就能往里传, 你就说方不方便吧? 
- 但是这里面拆装箱肯定很多
```CSharp
class Base{ public void Fun() { } }

internal class Class1
{
    static void Main(string[] args)
    {
        //装箱
        object o = 3;
        //拆箱
        int num = (int)o;

        TestFun(1243,63f,0.2343,"Cherno",' ',new Base());
    }
    static void TestFun(params object[] objects)
    {
        //用上面的方法区别值类型和引用类型,然后执行对应的逻辑
    }
}
```
***
## 3.5密封类
用sealed关键字修饰的类, 会使类无法再被继承
**作用**
- 在面向对象程序的设计中,密封类不允许最底层子类被继承
***
# 4.多态
***
## 4.1Vob
**多态的概念**
让继承统一父类的子类们在执行相同方法时有不同的表现

**主要目的**
同一父类的对象,执行相同行为(方法)有不同的表现

**解决的问题**
让同一对象有唯一行为的特征

```CSharp
class Father
{
    public void SpeakName()
    {
        Console.WriteLine("Father的方法");
    }
}

class Son : Father
{
    public void SpeakName()
    {
        Console.WriteLine("Son的方法");
    }
}
internal class Class1
{
    static void Main(string[] args)
    {
        Father f = new Son();
        f.SpeakName();//打印 Father的方法
        (f as Son).SpeakName();//打印 Son的方法
    }
}
```
那这就有问题了,你一个对象对于一个函数来说怎么可以有两种实现,那我以后代码写多了岂不是很乱

### 实现多态
编译时多态--函数重载(提一嘴)

我们学习运行时多态(vob)
- v: virtual(虚函数)
- o: override(重写)
- b: base(父类)

C#和C++不一样,C#即使在父类写了virtual,在子类不写override是不算重写的

***
## 4.2抽象类和抽象方法
### 抽象类

**用关键字abstract修饰**
- 不能被实例化的类
- 可以包含抽象方法
- 继承抽象必须重写其抽象方法

### 抽象方法(纯虚方法)
- 只能在抽象类中声明
- 没有方法体
- 不能是私有的
- 继承后必须实现,用override重写
- 抽象方法要求子类必须实现,但是没要求子类的子类也实现,但是子类的子类也能重写抽象方法

```CSharp
abstract class Fruits
{
    public string name;

    public abstract void Bad();
}

class Apple : Fruits
{
    public override void Bad()
    {
        Console.WriteLine("重写父类抽象方法");
    }
}

class SuperApple : Fruits
{
    public override void Bad()
    {
        Console.WriteLine("重写父类的父类抽象方法");
    }
}

internal class Class1
{
    static void Main(string[] args)
    {
        Fruits apple = new Apple();
        apple.Bad(); //输出 重写父类抽象方法
        superApple.Bad();//输出 重写父类的父类抽象方法
    }
}
```
### 虚方法(virtual)和纯虚方法(abstract)
- 它们都可以通过子类的override重写
- 虚方法有函数体,而纯虚方法没有函数体
- 虚方法是由我们子类选择性实现,而抽象方法必须要求子类去实现
- 抽象方法只能声明在抽象类中,虚方法不管什么类都可以声明
- 虚方法和抽象方法都可以无限的由子类重写

***
## 4.3接口
### 概念
- 接口是行为的抽象规范,它也是一中自定义类型
- 接口是抽象行为的"基类"
- 关键字: **interface**

**接口的声明**
1. 不包含变量
2. 只包含方法,属性,索引器,事件
3. 成员不能被实现
4. 成员可以不用写访问修饰符,**不能是私有的**
5. 接口不能继承类,但可以继承另一个接口

**接口的使用**
1. 类可以继承多个接口
2. 类继承接口后,必须实现接口中所有成员

**特点**
1. 它和类的声明类似
2. 接口是用来继承的
3. 接口不能被实例化,但是可以作为容器存储对象

### 继承
1. 类可以继承1个类和n个接口
2. 继承接口后,必须实现其中的内容,并且必须是public的
3. 实现的接口函数,可以加virtual再在子类重写
4. 接口也遵循里氏替换原则

```CSharp
public interface Ifly
{

    void fly();//方法
    string Name { get; set; } //属性
    int this[int index] { get;set; }//索引器
    event Action DoSomething; // 事件
}

class Animal{ }

class Person : Animal, Ifly
{
    public void fly() { }
    public int this[int index]
    {
        get 
        {
            return 0;
        }
        set { }
    }            
    public string Name { get; set; }
    public event Action DoSomething;
}

internal class Class1
{
    static void Main(string[] args)
    {
        //里氏替换
        Ifly p = new Person();
    }
}
```

- 接口继承接口时,不需要实现
- 待类继承接口后,类自己去实现所有内容
### 显式实现接口
- 当一个类继承两个接口,但是接口存在着同名方法
- 显式实现接口时,不能写访问修饰符

但是显式实现接口后,只能用对应的容器去装载对象后才能调用对应的接口方法,除非用as
```CSharp
class Player : IAtk, ISuperAtk
{
    //显式实现接口
    void IAtk.Atk()
    {
        Console.WriteLine("IAtk的实现");
    }

    void ISuperAtk.Atk()
    {
        Console.WriteLine("ISuperAtk的实现");
    }
}

internal class Class1
{
    static void Main(string[] args)
    {
        Player p = new Player();//这样是无法直接调用显式接口的方法的
        IAtk p1 = new Player();
        ISuperAtk p2 = new Player();

        (p as IAtk).Atk();//输出 IAtk的实现
        (p as ISuperAtk).Atk();//输出 ISuperAtk的实现
        p1.Atk();//输出 IAtk的实现
        p2.Atk();//输出 ISuperAtk的实现
    }
}
```

***
## 4.4密封方法
**关键字sealed**
- 用密封关键字sealed修饰的重写方法称为密封方法
- 让虚函数或者抽象方法之后不能再被重写
- 和override一起出现
***
# 5.其余相关知识
***
## 5.1命名空间

**概念**
命名空间是用来组织和重用代码的

**使用**
```CSharp
namespace 命名空间名
{
    类
    类
}
```
- 在同一命名空间当中不允许用同一个类名
- 不同命名空间中相互使用,需要引用命名空间或指明出处
  - 用`using 命名空间`
  - 用`命名空间.类名`
```CSharp
using MyGo //要么这么写

namespace MyGo
{
    public class Sakiko{}
}

namespace _17命名空间
{
    internal class Class1
    {
        static void Main(string[] args)
        {
            MyGo.Sakiko sakiko = new MyGo.Sakiko(); //要么这么写
        }
    }
}
```

- 不同命名空间中允许有同名类
- 如果在一个命名空间中要调用其他命名空间中的同名类,那就只能用指明出处的方式来声明

```CSharp
namespace MyGo{ class Sakiko { } }

namespace AveMujica{class Sakiko { } }

namespace _17命名空间
{
    internal class Class1
    {
        static void Main(string[] args)
        {
            MyGo.Sakiko sakiko = new MyGo.Sakiko();
            AveMujica.Sakiko sakiko1 = new AveMujica.Sakiko();
        }
    }
}
```
- 命名空间可以包裹命名空间 

```CSharp
namespace BangDream
{
    namespace MyGo
    {
        class Anon { }
    }

    namespace AveMujica
    {
        class Anon { }
    }
}
```
- 命名空间的类,默认是public
- internal修饰命名空间时只能在当前程序集中使用,暂时可以理解为一个工程是一个程序集
***
## 5.2Object中的方法
Object是所有类型的基类
object是Object的别名,在使用时用哪个都是一样的

### Object的静态方法
**Equals**
- 判断两个对象是否相等(值类型针对的是数据,而引用类型针对的是内存),最终判断权交给左侧对象的Equals方法
- 不管是值类型还是引用类型都会按照左侧对象的Equals方法的规则来进行比较
```CSharp
class Test { }
internal class Class1
{
    static void Main(string[] args)
    {
        Test t1 = new Test();
        Test t2 = new Test();
        Test t3 = t1;

        Console.WriteLine(object.Equals(t1,t2));//false
        Console.WriteLine(object.Equals(t1,t3));//true
    }
}
```
**ReferenceEquals**
- 比较两个对象是否是相同的引用,主要是用来比较引用类型的对象
- 值类型对象返回值始终是false
```CSharp
class Test { }
internal class Class1
{
    static void Main(string[] args)
    {
        Test t1 = new Test();
        Test t2 = new Test();
        Test t3 = t1;

        Console.WriteLine(object.ReferenceEquals(1,1));//false

        Console.WriteLine(object.ReferenceEquals(t1,t2));//false
        Console.WriteLine(object.ReferenceEquals(t1,t3));//true
    }
}
```
- Object是所有类型的基类,只要是个类都继承于它,所以以上的代码中的object是可以不用写的
### Object中的成员方法
**GetType**
- 该方法在反射中是非常重要的
- 该方法的主要作用就是获取对象运行是的类型Type
- 通过Type结合反射相关的知识点可以做很多关于对象的操作

**MemberwiseClone**
- 该方法用于获取对象的浅拷贝对象, 返回一个对象,该对象中的引用变量会与原对象指向的内存相同

### Object中的虚方法

**(virtual) Equals**
- 默认实现还是比较两者是否为同一引用,相当于ReferenceEquals
- 但是微软在所有值类型的基类System.ValueType中重写了该方法,专门用来比较值相等
- 我们自己也可以重写该方法,定义自己的规则

**GetHashCode**
- 该方法是获取对象的哈希码
- 一种通过算法算出的,表示对象的唯一编码,不同对象哈希码有可能一样,具体根据哈希算法决定
- 我们可以通过重写该函数来定义自己的对象的哈希码算法

**ToString**
- 用于返回当前对象代表的字符串,我们可以重写它定义我们自己的对象转字符的规则
- 当我们调用打印方法时(Console.WriteLine()),默认使用的就是对象ToString方法后打印出来的内容

***
## 5.3String

**获取指定位置的字符**
- String的本质是char数组
```CSharp
string str = "汉堡还是塔斯汀好吃";
char[] chars = str.ToCharArray();
Console.WriteLine(chars[1]); // 堡
```

**字符串拼接**

```CSharp
str = string.Format("{0} , {1}",0,1);
Console.WriteLine(str); // 0 , 1
```

**正向查找字符位置**
- `IndexOf`方法会正向(从左往右)的查找字符中的字符,然后返回第一个找到的下标
```CSharp
string str = "阿良良木历";
int index = str.IndexOf("良");
int index1 = str.IndexOf("伤");
Console.WriteLine(index); // 输出 1
Console.WriteLine(index1); // 输出 -1
```

**反向查找指定字符**
```CSharp
string str = "我是阿良良木历阿良良木历";
int index = str.LastIndexOf("阿良良木历");
Console.WriteLine(index); // 7
```
**移除指定位置后的字符**
- 字符串的很多方法都不会改变原字符串,而是返回一个新的字符串
```CSharp
string str = "我是阿良良木历阿良良木历";
str = str.Remove(2);
Console.WriteLine(str); // 我是
```
- 执行两个参数进行移除
  - 参数1 开始位置
  - 参数2 字符个数
```CSharp
string str = "我是阿良良木历阿良良木历";
str = str.Remove(1, 1);
Console.WriteLine(str); // 我阿良良木历阿良良木历
```
**替换指定字符串**
```CSharp
string str = "我是Spike";
str = str.Replace("Spike", "鲁路修");
Console.WriteLine(str);// 我是鲁路修
```
**大小写转换**

```CSharp
string str = "ksdfasdfasfasdfsasdfasdf";
str = str.ToUpper();
Console.WriteLine(str); // KSDFASDFASFASDFSASDFASDF

str = str.ToLower();
Console.WriteLine(str); // ksdfasdfasfasdfsasdfasdf
```
**字符串截取**
```CSharp
string str = "sometime";
str = str.Substring(2);
Console.WriteLine(str); //metime
```
- 参数一 开始位置
- 参数二 指定个数
- 不会自动的帮助你判断是否越界 你需要自己去判断
```CSharp
string str = "sometime";
str = str.Substring(2, 2);
Console.WriteLine(str); //me
```
**字符串切割**
```CSharp
string str = "1_1|2_2|3_3|5_1|6_1|7_2|8_3";
string[] strs = str.Split('|');
for (int i = 0; i < strs.Length; i++)
{
    Console.WriteLine(strs[i]);
    /* 输出  1_1
            2_2
            3_3
            5_1
            6_1
            7_2
            8_3 */
}
```
**C#中String和string、Int32和int、Int16和short、Int64和long他们的区别是什么？**
- 功能上没区别,string 是 String 的别名，int 是 Int32 的别名，以此类推。

***
## 5.4StringBuilder
- String在每次重新赋值或者拼接的时候会分配新的内存空间
- 如果一个字符串经常改变会非常浪费空间

### 概念
C#提供的一个用于处理字符串的公共类

**解决的问题**
- 修改字符串而不创建新的对象,需要频繁修改和拼接字符串可以使用它,可以提升性能
- 使用前需要引用命名空间(using System.Text)

**初始化**
- StringBuilder本质上也是一个字符数组,只是封装得和String不一样而已
- 所以StringBuilder存在一个容量问题,每次往里面增加时会自动扩容,扩容当前的2倍

**增删改查**
- 增: Append/AppendFormat
- 插入: Insert
- 删: Remove
- 清空: Clear
- 替换: Replace

**判断相等**
- 用object里的Equals方法
***
## 5.4类与结构体
### 概述
- 结构体具备封装的特性,但是不具备继承和多态
- 因为结构体不具备继承的特性,所以它不能够使用protected修饰符

### 区别
- 结构体成员变量声明不能指定初始值,而类可以
- 结构体不能声明无参的构造函数,而类可以
- 结构体声明有参构造后,无参构造仍然可以使用
- 结构体需要在构造函数中初始化所有成员变量,而类随意
- 结构体不能被static修饰(不存在静态结构),而类可以
- 结构体不能在自己内部声明和自己一样的结构体变量,而类可以

### 特别的
- 结构体可以继承接口,因为接口是行为的抽象

### 如何选择
1. 想要用继承和多态时,用类
2. 对象是数据集合时,用结构体
3. 经常被赋值传递的对象,并且改变赋值对象,源对象不想跟着变化的,用结构体,如: 坐标,向量
***
## 5.5抽象类与接口
- 建议在写接口时,不写任何访问修饰符,因为它默认public

### 相同点
1. 都可以被继承
2. 都不能被直接实例化
3. 都可以包含方法声明
4. 子类必须实现未实现的方法
5. 都遵循里氏替换原则

### 区别
1. 抽象类中可以有构造函数;接口不能
2. 抽象类只能被单一继承;接口可以被继承多个
3. 抽象类中可以有成员变量;接口不能
4. 抽象类中可以声明成员方法,虚方法,抽象方法,静态方法;接口中只能声明没有实现的抽象方法
5. 抽象类方法可以使用访问修饰符;接口建议不写

### 如何选择
1. 表示对象的用抽象,表示行为拓展的用接口
2. 不同对象拥有的共同行为,我们往往用接口实现
***
# 6.拓展
***
## 6.1面向对象七大原则

**单一职责原则(SRP)**
1. 类被修改的几率很大,因此应该专注于单一的功能
2. 如果把多个功能放在同一个类中,功能之间就形成了关联,改变其中一个功能,有可能终止另一功能

**开闭原则(OCP)**
1. 对拓展开发,对修改关闭
2. 拓展开发: 模块的行为可以被拓展从而满足新的需求
3. 修改关闭: 不允许修改模块的代码(或者尽量少的修改)

**里氏替换原则(LSP)**
- 任何父类出现的地方,子类都可以替代

**依赖倒转原则(DIP)**
- 要依赖于抽象,不要依赖于具体实现

**迪米特原则(最少知识原则)(LoP)**
- 一个对象应当对其他对象尽可能少的了解

**接口分离原则(ISP)**
1. 不应该强迫别人依赖它们不需要的方法
2. 一个接口不需要提供太多的行为,一个接口应该尽量只提供一个对外的功能,让别人去选择需要实现什么样的行为,而不是把所有的行为都封装在一个接口当中

**合成复用原则(CRP)**
1. 尽量使用对象组合,而不是继承来达到复用的目的
2. 继承关系是强耦合,组合关系是低耦合
***