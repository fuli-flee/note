[toc]
***
# 1. 简单数据结构
***
## 1.1 ArrayList
在学习一个类的基本使用时,先看官方文档,对于使用技巧再去看别人的博客
[官方文档](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.arraylist?view=net-9.0)

**本质**
它的本质是一个object类型的数组

**命名空间**
需要`using System.Collections`

**增删改查**
以下都能在官方文档里查看,这里列出几个常用的

- 增
  - `Add()`       增加单个元素
  - `AddRange() ` 范围增加,把另一个容器里面的内容加到后面 
  - `Insert()`
- 删
  - `Remove()`    从头找
  - `RemoveAt()`
  - `Clear()`
- 查
  - `Contains()`  查看元素是否存在
  - `IndexOf()`   正向查找,找不到返回-1
  - `LastIndexOf()`   反向查找

**遍历**
普通遍历不讲了,讲迭代器遍历
```CSharp
static void Main(string[] args)
{
    ArrayList arr = new ArrayList();
    arr.Add("1234");    arr.Add(true);
    arr.Add("1234");    arr.Add(true);

    foreach (object item in arr)
    {
        Console.WriteLine(item);
    }
}
```

**装箱拆箱**
上面提到了ArrayList的本质,那它一定会有频繁的拆装箱,所以ArrayList尽量少用,后面有更好的容器,官方文档已经写出了上位替代了,可以看看
***
## 1.2 栈
本质也是object[]数组, 这里学的Stack不是泛型的,泛型的为`Stack<T>`,所以不用指定类型,啥都能存,下面的队列也是一样

**操作**
- 压栈: `Push()`
- 弹栈: `Pop()`
- 查看栈顶元素: `Peek()`,这里就和C++不一样了,C++是top()
- 查看元素是否在栈中: `Contains()`
- 清空: `Clear()`
- 查看长度: `Count`

**遍历**
- 用迭代器遍历,会从栈顶遍历到栈底
- 还可以将栈转换为Object数组,可以直接ToArray()

***
## 1.3 Queue
本质还是Object[]数组

**操作**
- 增加至队尾: `Enqueue()`
- 从队头取元素: `Dequeue()`
- 查看队头元素: `Peek()`
- 查看元素是否存在: `Contains()`
- 清空: `Clear()`
- 长度: `Count`

***
## 1.4 Hashtable
- 本质是基于键的哈希代码组织起来的 键值对
- 使用键来访问集合中的元素
- 不能出现相同的键


**操作**
- 增加元素: `Add(key, value) `
- 删除元素: `Remove(key)` 删除不存在的键是没反应的
- 清空: `Clear()`
- 检测键是否存在:`Contains(key)` / `ContainsKey(key)`
- 检测值是否存在: `ContainsValue`
- 键值对数: `Count`

**遍历**
1. 遍历所有键
```CSharp
foreach(object item in 哈希表名字.Keys)
```
2. 遍历所有值, 可以通过键来找到对应的值, 反过来不行
```CSharp
foreach(object item in 哈希表名字.Values)
```
3. 键值对一起遍历
```CSharp
foreach(DictionaryEntry item in 哈希表名字)
```
4. 迭代器遍历
```CSharp
IDictionaryEnumerator myEnumerator = hashtable.GetEnumerator();
bool flag = myEnumerator.MoveNext();
while (flag)
{
    Console.WriteLine("键：" + myEnumerator.Key + "值：" + myEnumerator.Value);
    flag = myEnumerator.MoveNext();
}
```
**装箱和拆箱**
- 往里面进行值类型存储就是在装箱
- 将值类型对象取出来转换使用时,就是在拆箱
***
# 2. 泛型
***
## 2.1 泛型
泛型实现了类型参数化, 通过类型参数化来实现同一份代码可以操作多种类型

泛型相当于类型占位符, 定义类或方法时使用替代符代表变量类型, 当真正使用类或者方法时再具体指定类型

### 泛型的分类
泛型占位字母可以有多个, 用逗号隔开

- 泛型类
```CSharp
class 类名<泛型占位字母>
```
- 泛型接口
```CSharp
interface 类名<泛型占位字母>
```
- 泛型函数
```CSharp
函数名<泛型占位字母>(参数列表)
```
### 泛型方法
对于泛型函数来说, 如果想得到该泛型类型的默认值, 如下:
```CSharp
public void TestFun<T>()
{
    T t = default(T);
}
```

**泛型类中的泛型方法**
```CSharp
class Test<T>
{
    public T value;
    //这个方法就不叫泛型方法了, 因为 T 在泛型类声明的时候就指定了
    //则它就不能再动态变化了
    public void TestFun(T t) { }
}
```
### 泛型的作用
1. 不同类型对象的相同逻辑处理就可以选择泛型
2. 使用泛型可以一定程度避免拆箱装箱
***
## 2.2 泛型约束

- 让泛型的类型有一定的限制
- 关键字: `where`
- 泛型约束一共有6种

这里分两个表格,看起来方便

| 值类型 |  引用类型 | 存在无参公共构造函数 | 
|--------|----------|---------------------|
|`where 泛型字母:struct`|`where 泛型字母:class`|`where 泛型字母:new()`|


| 某个类本身或者其派生类 | 某个接口的派生类型 | 另一泛型类型本身或者派生类型 | 
|--------|----------|---------------------|
|`where 泛型字母:类名`|`where 泛型字母:接口名`|`where 泛型字母:另一泛型字母`|

### 约束的组合使用
```CSharp
class Test<T> where T : class,new() { }
```
### 多个泛型有约束
```CSharp
class Test<T,K> where T : class,new() where K : struct { }
```
***
# 3. 常用泛型数据结构类
***
## 3.1 List
本质是一个可变类型的泛型数组

**命名空间**
`using System.Collections.Generic;`

**操作**
- 增: `Add()` / `AddRange()`
- 删: `Remove()` / `RemoveAt()`
- 存在: `Contains()`
- 正向查: `IndexOf()`
- 反向查: `LastIndexOf()`
- 长度: `Count`
- 容量: `Capacity`
***
## 3.2 Dictionary
这个Dictionary不像C++里的unordered_map,反而像unordered_set,因为它能去重

- 可以理解为拥有泛型的Hashtable, 它也是基于键的哈希代码组织起来的键值对
- 键值对类型从Hashtable的object变成了可以自己指定的泛型

**声明**
```CSharp
Dictionary<int, string> dictionary = new Dictionary<int, string>();
```

**操作**
- 增: `Add()`
- 删: `Remove()`
- 键存在: `ContainsKey()`
- 值存在: `ContainsValue()`

**遍历**
这里以上面的声明的字典为例

1. 遍历所有键
```CSharp
foreach(int item in dictionary.Keys)
```
2. 遍历所有值, 可以通过键来找到对应的值, 反过来不行
```CSharp
foreach(string item in dictionary.Values)
```
3. 键值对一起遍历
```CSharp
foreach(KeyValuePair<int,string> item in dictionary)
```
***
## 3.3 顺序存储和链式存储

**数据结构**
一句话, 人定义的 存储数据 和 表示数据之间关系 的规则

**线性表** 
由n个具有相同特性的数据元素的优先序列

### 顺序存储
- 数组, Stack, Queue, List, ArratList
- 用一组地址连续的存储单元依次存储线性表的各个数据元素

### 链式存储
- 链表
- 用一组任意的存储单元存储线性表中的各个数据元素

### 顺序存储和链式存储的优缺点
从增删改查的角度思考
- 增: 链式存储 计算上 优于顺序存储(中间插入时链式不用像顺序一样去移动位置)
- 删: 链式存储 计算上 优于顺序存储(中间删除时链式不用像顺序一样去移动位置)
- 改: 顺序存储 使用上 优于链式存储(数组可以直接通过下标得到元素，链式需要遍历)
- 查: 顺序存储 使用上 优于链式存储(数组可以直接通过下标得到元素，链式需要遍历)
***
## 3.4 LinkedList
本质是一个可变类型的泛型双向链表

**操作**
- 链尾增加元素: `AddLast()`
- 链头增加元素: `AddFirst()`
- 移除头节点: `RemoveFirst()`
- 移除尾节点: `RemoveLast()`
- 移除指定节点: `Remove(value)`
- 头节点: `First`
- 尾节点: `Last`
- 找指定值的节点: `Find()`
  - 这里要注意了,这里返回的是节点,找不到返回空, 看这行代码就懂了
    ```CSharp
    LinkedListNode<int> node = linkedList.Find();
    ```
- 在某节点后加一个节点: `AddAfter(节点, value)`
  ```CSharp
  LinkedListNode<int> n = linkedLis.Find(20);
  linkedList.AddAfter(n, 15);
  ```
- 在某节点之前添加一个节点: `AddBefore(节点, value)`

**遍历**
- foreach遍历
```CSharp
foreach(int item in linkedList) { }
```
- 通过节点遍历
```CSharp
//从前往后
LinkedListNode<int> head = linkedList.First;
while(head != null) { head = head.Next; }

//从后往前
LinkedListNode<int> head = linkedList.Last;
while(head != null) { head = head.Previous; }
```
***
## 3.5 泛型栈和队列
在使用上和上面谈到的栈和队列一模一样,只是加了泛型
***
# 4. 委托和事件
***
## 4.1 委托
对于把函数当参数传递,我想起[C++里的函数指针](https://www.bilibili.com/video/BV1254y1h7Ha?spm_id_from=333.788.videopod.sections&vd_source=e5ff09f1c2b416e099232ca31ec5028d), 有兴趣可以去看看

- 委托是函数的容器, 可以理解为表示函数的变量类型, 用来存储和传递函数, 委托的本质是一个类, 用来定义函数的类型(返回值和参数的类型)
- 不同的函数必须对应和各自"格式"一致的委托

### 语法
- 关键字: delegate
- 语法: `访问修饰符 delegate 返回值 委托名(参数列表); `
- 写在namespace和class语句块中, 在namespace中居多

**自定义委托**
- 访问修饰符一般不写, 默认为public, 在别的命名空间中能使用
- 设为private后,其他命名空间就不能用了 


这里只是声明了一个可以用来存储无参无返回值函数的容器
这里只是定义了规则, 并没有使用
```CSharp
delegate void MyFun();
```
同一作用域中,委托规则的声明不可以重名

**泛型委托**
```CSharp
delegate T MyFun()
```
### 使用

```CSharp
namespace _08委托
{
    delegate void Del();
    delegate int Del2(int a);
    internal class Class1
    {
        static void Fun()
        {
            Console.WriteLine("123123");
        }

        static int Fun2(int value)
        {
            return value;
        }

        static void Main(string[] args)
        {
            //下面两种声明其实是差不多的
            Del del1 = new Del(Fun);
            Del2 del2 = Fun2;

            //调用委托, 下面两种调用其实是差不多的
            del1.Invoke();
            del2(5);
        }
    }
}
```
以上委托的使用是比较罕见的,委托常用在:
- 作为类的成员
- 作为函数的参数

假如某一函数中有一个变量,且只能在这个函数里创建并处理逻辑,处理完后然后再传给委托处理这个数, 以上实现就需要委托了

```CSharp
namespace _08委托
{
    delegate int Calculate(int a);

    class Test
    {
        public Calculate cal;
        public void TestFun(Calculate cal)
        {
            int i = 10;

            //假装处理一些逻辑
            i += 10;

            cal(i);
        }
    }

    internal class Class1
    {
        public static int Function(int value) 
        {
            Console.WriteLine(value);
            return value; 
        }
        static void Main(string[] args)
        {
            Calculate cal = new Calculate(Function);
            Test t = new Test();
            t.TestFun(cal); // 输出 20
        }
    }
}
```
以上这种先处理一些逻辑后,再通过前面处理过的结果,靠委托去批量的处理另一些逻辑,这种思想就是[观察者模式](https://design-patterns.readthedocs.io/zh-cn/latest/behavioral_patterns/observer.html)的雏形了


**这块可以不用看,但是看了能加深理解**

看完并理解上面的代码后, 先聚焦在`TestFun()`方法上, 想一想这种场景:
- 你的目的是将这个只能声明在`TestFun()`方法中的变量`i`处理一些逻辑后再交给`Function()`去处理逻辑
- 这个`i`只能定义在`TestFun()`方法中,所以只要出`TestFun()`方法的作用域后就会自动销毁
</br>

- 在不用委托的条件下,要怎么完成你的目的? 
- 那只能把`i`提出`TestFun()`,提到和`Function()`同一作用域及以上,提升它的生命周期
- 然后把它放到`TestFun()`的参数列表里,处理完逻辑之后,再传给`Function()`继续处理,但这也同时违背了 "只能声明在`TestFun()`方法中" 这一条件
- 上面内容看着抽象吧, 看下面代码

```CSharp
class Test
{
    public void TestFun(ref int i)
    {
        i += 10;
    }
}

internal class Class1
{
    public static int Function(int value) 
    {
        Console.WriteLine(value);
        return value; 
    }
    static void Main(string[] args)
    {
        int i = 10;
        Test t = new Test();
        t.TestFun(ref i);
        Function(i);//输出20 
    }
}
```
- 缺点就是你不知道你的`i`会不会被其他的函数干扰

**这块结束**

### 多播委托
人话这一块: 委托变量可以存储多个函数

**增: `+=`**
```CSharp
delegate void TestDel(int a);

internal class Class1
{
    public static void TestFun(int value) 
    {
        Console.WriteLine(value);
    }
    public static void TestFun2(int value) 
    {
        value -= 5;
        Console.WriteLine(value);
    }
    static void Main(string[] args)
    {
        TestDel del = TestFun;
        del += TestFun2;
        del(10);//这里会输出两行  第一行 10    第二行  5
    }
}
```
上面代码有个优化的地方
```CSharp
TestDel del = TestFun;//这里不能改为+=
del += TestFun2;
```
但是你在初始化委托的时候设置为空,那就可以统一增加函数的方式
```CSharp
TestDel del = null;
del += TestFun; // del = del + TestFun; 这样写也行
del += TestFun2;
```
而在委托执行的时候也是按照添加的顺序去执行,可以理解为先进先出

**删: `-=`**
理解上面的增了后,删也就好说了
值得一提的是,当你删除委托中没有的函数时,不会报错,只是没反应而已

### 系统定义好的委托
需要`using System`

- **Action**
代表**无参无返回值**的委托
  ```CSharp
  delegate void MyDel();
  static void Fun() { }

  //这两句作用是一样的
  Action action = Fun;
  MyDel action = Fun;
  ```
- **Func\<out T>**
  代表**无参返回值类型为T**的委托
  ```CSharp
  public static int TestFun3() {  return 1; }
  Func<int> func = TestFun3;
  ```
- **Action\<in T>**
代表 可以传多个参数的**有参无返回值**的委托,最多传16个参数
</br>

- **Func\<in T,out TResult>**
代表 可以传多个参数的**有参有返回值**的委托,最多传16个参数
尖括号中的最后一个参数永远是返回值类型  
***
## 4.2 事件
### 概念
事件是一种特殊的变量类型, 是委托的安全包裹, 让委托的使用更有安全性

### 使用
**语法**
```CSharp
访问修饰符 event 委托类型 事件名;
```

**使用**
- 事件是**作为成员存在于类中**的,委托怎么用,事件就怎么用
- 它只能作为成员存在与类,接口以及结构体中

**与委托的区别**
1. 不能在类外部赋值
2. 不能在类外部调用
3. 事件不能作为临时变量在函数中使用,委托可以


- 委托可以在外部赋值,而事件不能在外部赋值,只能通过`+=`和`-=`去添加和移除事件里记录的函数
- 事件不能在外部调用,所以也就不存在以下的代码
```CSharp
class Test
{
    public event Action myEvent;
}
internal class Class1
{
    static void Main(string[] args)
    {
        Test t = new Test();
        //以下两句代码是会报错的
        t.myEvent();
        t.myEvent.Invoke();
    }
}
```
- 如果你想在外部调用那只能这么写

```CSharp
class Test
{
    public event Action myEvent;

    public void DoEvent()
    {
        myEvent();
    }
}
internal class Class1
{
    static void Main(string[] args)
    {
        Test t = new Test();
        t.DoEvent();
    }
}
```
### 为什么会有事件
1. 防止外部随意置空委托
2. 防止外部随意调用委托
3. 事件相当于对委托进行了一次封装,让其更加安全
***
## 4.3 匿名函数
- C++是不一样的,[匿名函数一般在需要快速创建一个一次性的函数时使用](https://www.bilibili.com/video/BV195411A7KX?spm_id_from=333.788.videopod.sections&vd_source=e5ff09f1c2b416e099232ca31ec5028d)

- 没有名字的函数,匿名函数的使用主要是配合委托和事件进行使用
- **脱离委托和事件是不会使用匿名函数的**

### 语法
```CSharp
delegate (参数列表)
{
    //逻辑
}
```
1. 函数中传递委托参数时
2. 委托或事件赋值时

### 使用
- 当你声明了一个匿名函数时,需要用委托或者事件装载起来,不然会报错
- 调用匿名函数是通过调用委托来实现
```CSharp
Action a = delegate() { };
```
- 写个例子
```CSharp
Action<int> a = delegate (int a)
{
    Console.WriteLine("匿名函数");
};
```
- 一般作为函数参数传递 或者 作为函数返回值
### 匿名函数的缺点
- 添加到委托或者事件容器中后 不记录 无法单独移除
- 因为匿名函数没有名字,所以不能用`-=`去指定移除
***
## 4.4 Lambda表达式
可以理解为匿名函数的简写,除了写法不同外,使用上和匿名函数一模一样
```CSharp
(参数列表) => { 函数体 };
```
### 使用
- 举个例子
```CSharp
Action<int> a = (int num) => 
{ 
    //写逻辑
};
```
- 你甚至还可以连参数类型都不写
```CSharp
Action<int> a = (num) =>
{
    Console.WriteLine("num: {0}", num);
};

a(5);//输出 num: 5
```

### 闭包
**内层的函数可以引用包含在它外层的函数的变量, 即使外层函数的执行已经终止**
```CSharp
class Test
{
    public event Action action;

    //外层函数
    public Test()
    {
        //外层函数的变量
        int value = 5;
        //内层函数
        action = () =>
        {
            Console.WriteLine("value: {0}", value);
        };
    }

    public void DoSomething()
    {
        action();
    }
}

internal class Class1
{
    static void Main(string[] args)
    {
        Test t = new Test();
        t.DoSomething();
    }
}
```
ok,我们来分析一下上面的代码,如果构造函数只写成这样
```CSharp
public Test() { int value = 5; }
```
那很明显,value出作用域后就会被销毁,但是像上面代码所示,把`value`放进了闭包,`value`的生命周期就变了
本来在这句代码执行完的时候,`value`就访问不到了
```CSharp
Test t = new Test();
```
但是你会发现这句代码照样调用了变量`value`
```CSharp
t.DoSomething();
```
我们一点点来捋一下,`action`这个事件是和`Test`对象同生命周期的,在构造函数中,将调用了`value`的匿名函数加入到了`action`中,这里就将`value`这个变量的生命周期拉长到了`action`同等生命周期(因为匿名函数不能指定移除,但是可以提前清空`action`容器,当你清空`action`时,那么此时`value`的生命周期就结束了),所以在`DoSomething`方法中可以正常的调用事件`action`

那么我们再进一步想一个问题,明明内存在栈上的`value`,为什么不会被自动销毁,反而生命周期还变长了?
- 答案已经很明显了,`value`的内存被提升到堆了
- 当匿名函数（`lambda`表达式）捕获了外部变量（如`value`）时，C#编译器会生成一个类来封装这些变量，从而延长其生命周期。捕获的变量不再位于栈上，而是被提升到堆中（由编译器生成的闭包类管理）。
- 被捕获的变量（`value`）的生命周期不再局限于构造函数的作用域，而是与捕获它的委托的生命周期相同。只要委托实例存在，该变量就不会被垃圾回收。


**该变量提供的值并非变量创建时的值,而是在父函数范围内的最终值**
```CSharp
class Test
{
    public event Action action;

    public Test()
    {
        for (int i = 0; i < 10; ++i)
        {
            action += () => { Console.Write(i + " "); };
        }
    }

    public void DoSomething()
    {
        action();
    }
}

internal class Class1
{
    static void Main(string[] args)
    {
        Test t = new Test();
        t.DoSomething();//输出 10 10 10 10 10 10 10 10 10 10
    }
}
```
这又是为什么? 我们再来捋一捋

当编译器遇到循环中的lambda表达式时,它发现lambda捕获了循环变量 i, 编译器会生成一个闭包类来存储被捕获的变量, 也就是说这句代码往action里加的 i 是同一个变量, 循环变量 i 在闭包中被共享（所有lambda都引用同一个变量）
```CSharp
action += () => { Console.Write(i + " "); };
```

那应该怎么解决呢? 
- 用一个变量去存储每个状态下的变量 i 就行了
```CSharp
public Test()
{
    for (int i = 0; i < 10; ++i)
    {
        int temp = i;  // 创建局部副本
        action += () => { Console.Write(temp + " "); };
    }
}
```
***
# 5. List排序
**自带的排序方法**
`sort()`, ArrayList也是这个

**自定义类的排序**
将需要排序的类继承于`IComparable\<T>`接口,实心接口中的`CompareTo(T other)`方法,该方法会将当前的对象和传入对象进行对比,并返回一个整形作为结果,规则为: 
- 返回值小于0, 将当前对象放在传入对象的前面
- 返回值大于0, 将当前对象放在传入对象的后面
- 返回值等于0, 不改变当前对象的位置
```CSharp
class Test : IComparable<Test>
{
    public int value;

    public Test(int value)
    {
        this.value = value;
    }

    public int CompareTo(Test other)
    {
        if (this.value > other.value) return 1;
        else if(this.value < other.value) return -1;
        return 0;
    }
}

internal class Class1
{
    static void Main(string[] args)
    {
        List<Test> tests = new List<Test>();
        tests.Add(new Test(30));
        tests.Add(new Test(20));
        tests.Add(new Test(10));
        tests.Add(new Test(70));
        tests.Add(new Test(80));
        tests.Add(new Test(60));
        tests.Add(new Test(90));
        tests.Sort();

        for (int i = 0; i < tests.Count; ++i)
        {
            Console.WriteLine(tests[i].value);//输出升序的结果
        }
    }
}
```
`Sort()`本质上把想要排序的对象通过里氏替换`as`成一个`IComparable\<T>`接口对象,然后再去调用自定义的`CompareTo(T other)`方法

**通过委托函数进行排序**
- 通过`sort()`的重载, 把比较函数作为参数传入
```CSharp
class Test 
{
    public int value;

    public Test(int value)
    {
        this.value = value;
    }
}

internal class Class1
{
    static void Main(string[] args)
    {
        List<Test> tests = new List<Test>();
        tests.Add(new Test(30));
        tests.Add(new Test(20));
        tests.Add(new Test(10));
        tests.Add(new Test(70));
        tests.Add(new Test(80));
        tests.Add(new Test(60));
        tests.Add(new Test(90));

        //从这里开始看
        tests.Sort(Cmp);

        for (int i = 0; i < tests.Count; ++i)
        {
            Console.WriteLine(tests[i].value);
        }
    }

    static int Cmp(Test a,Test b)
    {
        if (a.value < b.value) return -1;
        else return 1;
    }
}
```
- 你都知道能`sort`重载能传函数了,那不如直接写一个Lambda表达式,那不更方便,一行代码解决
```CSharp
tests.Sort((a,b) => { return a.value > b.value ? 1 : -1; });
```
***
# 6. 协变逆变
## 概念
**协变**
- 和谐的变化,自然的变化
- 因为里氏替换原则父类可以装载子类,所以子类变父类,如string变为object

**逆变**
- 逆常规的变化,不正常的变化
- 和协变相反,让父类变为子类, 如object变成string

**协变和逆变是用来修饰泛型的**
- 协变: out
- 逆变: in
- 用于在泛型中修饰泛型字母的,只有泛型接口和泛型委托可以使用

## 作用
1. **返回值和参数**
    - 用out修饰的泛型只能作为返回值
    ```CSharp
    delegate T TestOut<out T>();
    ```
    - 用in修饰的泛型只能作为参数
    ```CSharp
    delegate void TestOut<in T>(T t);
    ```

2. **结合里氏替换原则理解**
   
**协变**
- 看下面的代码, 它想把子类的委托容器变为父类的委托容器
- `TestOut<T>`是参数为T,返回值也为T的委托,那`TestOut<Son>`和`TestOut<Father>`就不是一个东西,因为它们返回值和参数都不一样 
```CSharp
delegate T TestOut<T>();

class Father { }
class Son : Father { }

internal class Class3
{
    static void Main(string[] args)
    {
        TestOut<Son> son = () => { return new Son(); }; 
        TestOut<Father> father = son; //这里是会报错的
    }
}
```
- 但是我们知道,这里的两个容器存在明显的继承关系,也就是说通过里氏替换,我们可以将这里的子类容器变为父类容器,这时便需要用到`out`了
```CSharp
delegate T TestOut<out T>();
```
- 修改泛型委托后,上面代码就可以运行了,也就说明`TestOut<Father> father = son;`这一句成功的将子类泛型委托转为了父类泛型委托

**逆变**
- 你懂了上面的协变,逆变也就同理了
```CSharp
delegate void TestIn<in T>(T t);

class Father { }
class Son : Father { }

internal class Class3
{
    static void Main(string[] args)
    {
        TestIn<Father> father = (value) => { };
        TestIn<Son> son = father; 
    }
}
```
***
# 7. 多线程
## 什么是进程
- 进程是计算机中的程序关于某数据集合上的一次运行活动,是系统进行资源分配和调度的基本单位,是操作系统结构的基础
</br>

- 上面是外星语,接下来我们来说人话
- 打开一个应用程序就是在操作系统上开了一个进程(你手机删后台的时候不是能看到多个应用的缩略图吗,你可以理解为那一个图片就代表一个进程)
- 进程之间可以相互独立运行,互不干扰 (你打游戏会干扰你QQ接收消息吗)
- 进程之间也可以相互访问,操作 (你用微信扫二维码进入了拼好饭) 

## 什么是线程
- 操作系统能够进行运算调度符最小单位
- 它被包含在进程之中,是进程中的实际运作单位
- 一条线程指的是进程中一个单一顺序的控制流,一个进程中可以并发多个线程
- 比如: 你开麦打游戏,你游戏运行是一个线程,你开麦把语音传递给队友又是一个线程,它们是同时存在的,这就是多线程,但是这两个线程又被包含在这个游戏的进程中(因为这两个线程都属于这个游戏)

## 语法
- 关键字: Thread
- 命名空间: using System.Threading

### 1.声明一个新的线程
   
!!! important 注意
    线程执行的代码 需要封装到一个函数中

```CSharp
static void NewThreadFun()
{
    Console.WriteLine("新声明的线程");
}

static void Main(string[] args)
{
    Thread t = new Thread(NewThreadFun);
}
```
- 以上便声明了一个新的线程,这里我们使用的是线程的其中一个重载
```CSharp
public Thread(ThreadStart start);
```
- 然后我们去查看这个`ThreadStart`类的源码定义为
```CSharp
public delegate void ThreadStart();
```
- 我们找到了传入参数的本质,也就是说线程接收的参数是一个无参无返回值的委托

### 2.启动
```CSharp
Thread t = new Thread(NewThreadFun);
t.Start();
```

### 3.后台线程
```CSharp
t.IsBackground = true;
```
- 当前台线程结束了的时候,整个程序也就结束了,即使还有后台线程还在运行
- 后台线程不会防止应用程序的进程被终止掉
- 如果不设置为后台进程,可能会导致进程无法正常关闭

### 4.关闭释放一个线程
- 如果是开启的线程不是死循环是能够结束的逻辑,那么就不用刻意的去关闭它
- 如果是死循环,想要终止这个线程,只有两种方法
  - 在死循环中用bool标识
    ```CSharp
    static bool isRunning = true;
    static void NewThreadFun()
    {
        while(isRunning)
            Console.WriteLine("新声明的线程");
    }
    static void Main(string[] args)
    {
        Thread t = new Thread(NewThreadFun);
        t.Start();
        //在主线程中,你想什么时候让你新开的线程停止,就把标识符设置为false就行了
        isRunning = false;
    }
    ```
  - 通过线程提供的方法(注意 在.Net core版本中无法终止, 会报错)
    ```CSharp
    t.Abort();//终止该线程
    t = null;//这里置空后,等待GC释放
    ```

## 线程休眠
```CSharp
Thread.Sleep(1000);//这里单位是毫秒   1s == 1000ms
```
- 这里就实现了线程等待1s打印一次
```CSharp
static void NewThreadFun()
{
    while (isRunning)
    {
        Console.WriteLine("新声明的线程");
        Thread.Sleep(1000);
    }
}
```

## 共享数据
- 多个线程使用的内存是共享的,都属于该应用程序(进程)
- 所以要注意 当多线程 同时操作同一片内存区域时会进行内存争用
- 可以试试运行这段代码,会出现很有意思的现象
```CSharp
static void NewThreadFun()
{
    while (true)
    {
        Console.SetCursorPosition(0,0);
        Console.ForegroundColor = ConsoleColor.Yellow;
        Console.Write("●");
    }
}

static void Main(string[] args)
{
    Thread t = new Thread(NewThreadFun);
    t.Start();
    t.IsBackground = true;

    while (true)
    {
        Console.SetCursorPosition(10, 5);
        Console.ForegroundColor = ConsoleColor.Blue;
        Console.Write("◆");
    }
}
```

- 可以通过加锁的形式避免问题
    - 当我们想要在多个线程当中想要访问同样的东西,进行逻辑处理的时候
    - 为了避免不必要的逻辑顺序执行的差错
- 语法为
```CSharp
lock(引用类型对象) { }
``` 
- [在操作系统这门课程中也有相关的知识,这里的给出面向工作的操作系统相关文档](https://xiaolincoding.com/os/4_process/process_base.html#%E8%BF%9B%E7%A8%8B)
***
# 8. 预处理指令
- 预处理指令指导编译器在编译开始之前对信息进行预处理
- 预处理指令都是以#开始
- 预处理指令不是语句,所以它们不以;结束

**常见的预处理指令**
1. #define和#undef
   - #define: 定义一个符号,类似一个没有值的变量
   - #undef: 取消#define定义的符号,让其失效
   - 它们一般写在脚本文件的最前面
2. #if, #elif, #else, #endif
   - 和if语句规则一样,一般配合#define定义的符号使用
   - 用于告诉编译器进行编译代码的流程控制 
3. #warning和#error
   - 警报和错误会直接显示在错误列表中
   - 而#error会使编译器连编译都不能编译
***
# 9. 反射和特性
***
## 9.1 反射
事先说明: 反射一般用于访问别的程序集,而为了方便学习,下面的例子都是访问自己的程序集,所以下面的代码例子看起来会多此一举

### 什么是程序集
- 程序集是由编译器编译得到的,供进一步编译执行的中间产物
- 在WIN系统下,它一般表现为后缀为.dll(库文件)或者是.exe(可执行文件)的格式
- 以下是人话: 程序集就是我们写的一个代码的集合,最终都会被编译器翻译为一个程序集供别人使用,比如一个库文件(dll)或者一个可执行文件(exe)

### 什么是元数据
- 元数据就是用来描述数据的数据
- 人话: 程序中的类,类中的函数,变量等信息就是程序的元数据
- 有关程序以及类型的数据被称为元数据,它们都保存在程序集中

### 反射的概念
- 程序正在运行时可以查看其他程序集或者自身的元数据
- 一个运行的程序查看本身或者其他程序的元数据的行为就叫反射
- 人话: 在程序运行时,通过反射可以得到其他程序集或者自己程序集代码的各种信息
- 类,函数,变量,对象等等,实例化它们,执行它们,操作它们

### 反射的作用
- 因为反射可以在程序编译后得到信息,所以提高程序的扩展性和灵活性
- 程序运行时得到所有元数据,包括元数据的特性
- 程序运行时,实例化对象,操作对象
- 程序运行时创建新对象,用这些对象执行任务

### 相关语法
#### Type
- 类的信息类,它是反射功能的基础,是访问元数据的主要方式
- 使用`Type`的成员获取有关类型声明的信息
- 有关类型的成员(构造函数,方法,字段,属性和类的事件)

**获取Type**
1. 用Object中的GetType()可以获取对象的Type
    ```CSharp
    int a = 32;
    Type type = a.GetType();//这里的type就拿到了int(Int32)类型的所有信息
    ```
2. 通过typeof关键字,传入类名也可以得到对象的Type
    这种形式往往用于我们能够明确得到类名的,也就是编译时就能确定传入的类型
    ```CSharp
    Type type1 = typeof(int);
    ```
3. 通过类的名字也可以获取类型,类名必须包含命名空间,不然找不到
    ```CSharp
    Type type2 = Type.GetType("System.Int32");
    ```  
   - 你会发现,这括号里传入的是字符串参数(我去查了一下,我也看不懂_(:з」∠)_,先暂时放在这里吧)

这三个type你会发现指向的是一个内存,每种数据类型在内存中只会有一个对应的 Type 对象实例

#### 得到类的程序集信息
```CSharp
Console.WriteLine(type.Assembly);
```
**为了方便讲解以下内容,这里先声明一个测试类**
```CSharp
class Test
{
    private int i = 1;
    public int j = 10;
    public string str = "123";

    public Test()  { }

    public Test(int i)
    {
        this.i = i;    
    }

    public Test(int i, string str) : this(i)
    {
        this.str = str;
    }

    public void Speak()
    {
        Console.WriteLine(i);
    }
}
```

#### 获取类中的所有公共成员
- 类: **MemberInfo**
- 方法: **GetMembers()**
- 需要引用命名空间: using System.Reflection;
- 首先获得Type,然后得到所有公共成员
```CSharp
Type type = typeof(Test);
MemberInfo[] infos = type.GetMembers();
for (int i = 0; i < infos.Length; ++i)
{
    Console.WriteLine(infos[i]);
}
```
- 得到这么一个玩意
```
Void Speak()
System.Type GetType()           \
System.String ToString()         |===> 这三个都是Object里的方法
Boolean Equals(System.Object)   /
Int32 GetHashCode()
Void .ctor()    ->这是构造函数 
Void .ctor(Int32)   ->这是有int参数的构造函数
Void .ctor(Int32, System.String)    ->不用多说了吧
Int32 j
System.String str
```
- 我们能够得到它,我们之后就能执行它

#### 获取类的公共构造函数并调用
- 类: **ConstructorInfo**
- 方法: **GetConstructor(Type[])**
- 先获取所有构造函数
```CSharp
ConstructorInfo[] ctors = type.GetConstructors();
```
- 上面代码得到
```
Void .ctor()
Void .ctor(Int32)
Void .ctor(Int32, System.String)
```
-  获取其中一个构造函数并执行
    - 得构造函数传入 Type数组,数组中内容按顺序是参数类型
    - 执行构造函数传入Object数组,表示按顺序传入的参数

① **得到无参构造**
```CSharp
ConstructorInfo info = type.GetConstructor(new Type[0]);
//执行无参构造,没有参数传null
Test obj = info.Invoke(null) as Test;
Console.WriteLine(obj.j); //输出 10
```
② **得到有参构造**
```CSharp
ConstructorInfo info2 = type.GetConstructor(new Type[] { typeof(int) });
obj = info2.Invoke(new object[] { 2 }) as Test;
```
- 针对以上进行说明,`GetConstructor` 方法的参数是一个 `Type` 数组，这个数组的作用是**指定构造函数的参数类型列表**
- `new Type[0]` 表示创建了一个长度为 0 的 `Type` 数组，意味着 “这个构造函数没有参数”，因此会匹配无参构造函数。
- 若使用 `new Type[2]`，则需要在数组中指定两个参数的类型（例如 `new Type[] { typeof(int), typeof(string) }`），此时 `GetConstructor` 会寻找 “包含两个对应类型参数” 的构造函数（就像代码中的 `Test(int i, string str)` 构造函数）。
</br>

- 当存在两个参数数量相同但类型不同的构造函数（如`Test(int i, string str)`和`Test(int i, char c)）`时：
  - 若要获取`Test(int i, string str)`，需用 *type.GetConstructor(new Type[] { typeof(int), typeof(string) })*
  - 若要获取`Test(int i, char c)`，需用 *type.GetConstructor(new Type[] { typeof(int), typeof(char) })*
- `Invoke`阶段传入的object数组**只需按顺序提供对应构造函数所需的参数值**即可，因为在此之前已经通过`GetConstructor`明确指定了要调用哪个构造函数。


#### 获取类的公共成员变量
- 类: **FieldInfo**
- 方法: **GetField()**, **GetValue(object? obj) / SetValue(object? obj, object? value)**

①**得到所有成员变量**
```CSharp
FieldInfo[] fieldInfos = type.GetFields();
for (int i = 0; i < fieldInfos.Length; i++)
{
    Console.WriteLine(fieldInfos[i]);
}
```
- 得到以下内容,你会发现只有公共的才会被输出出来
```
Int32 j
System.String str
```
②**得到指定名称的公共成员变量**
```CSharp
FieldInfo infoJ = type.GetField("j");
Console.WriteLine(infoJ);
```
- `GetField`中传入变量名字,得到以下内容
```
Int32 j
```
③通过反射获取和设置对象的值
- 在不同程序集中不能,你想获得对象就不能new出来了,只能通过反射得到信息
1. 获取对象的某个变量的值
```CSharp
Test test = new Test();
Console.WriteLine(infoJ.GetValue(test));//输出 10
```
1. 设置指定对象的某个变量的值
```CSharp
infoJ.SetValue(test,100);
Console.WriteLine(infoJ.GetValue(test));//输出 100
```
#### 获取类的公共成员方法
- 方法名: **GetMethod()**
- 通过Type类中的 GetMethod() 方法得到类中的方法
- MethodInfo是方法的反射信息
  1. 如果存在方法重载 用Type数组表示参数类型
    ```CSharp
    Type strType = typeof(string);
    MethodInfo[] methods = strType.GetMethods();
    ```
  2. 调用该方法

    !!! important 注意
        如果是静态方法 Invoke中的第一个参数传null即可
    ```CSharp
    //String里有这么一个函数System.String Substring(Int32, Int32)
    MethodInfo subStr = strType.GetMethod("Substring", new Type[] {typeof(int),typeof(int) });
    string str = "Hello,World!";
    //第一个参数相当于是哪个对象要执行这个成员方法
    object obj = subStr.Invoke(str, new object[] { 6, 6 });
    Console.WriteLine(obj); // 输出 World!
    ```

### 总结
- 成员 => Member
- 构造函数 => Constructor
- 成员变量 => Field
- 成员方法 => Method

***
## 9.2 Activator 和 Assembly
### Activator
- 用于快速实例化对象的类, 用于将 Type 对象快捷实例化为对象
- 先得到 Type , 然后快速实例化一个对象
1. 无参构造
```CSharp
Type testType = typeof(Test);
Test testObj = Activator.CreateInstance(testType) as Test;
Console.WriteLine(testObj.str);//输出 123
```
1. 有参构造
```CSharp
testObj = Activator.CreateInstance(testType, 99, "00000") as Test;
Console.WriteLine(testObj.str);//输出 00000
```


### Assembly
- 程序集类
- 主要用来加载其他程序集,加载后才能用Type来使用其他成程序集中的信息
- 如果想要使用不是自己程序集的内容,需要先加载程序集, 比如 dll文件
- 简单的把库文件看成一种代码仓库,它提供给使用者一些可以直接拿来用的变量,函数和类

**三种加载程序集的函数**
- 一般用来加载在同一文件下的其它程序集
```CSharp
Assembly asembly2 = Assembly.Load("程序集名称");
```
- 一般用来加载不在同一文件下的其它程序集
```CSharp
Assembly asembly = Assembly.LoadFrom("包含程序集清单的文件的名称或路径");
Assembly asembly3 = Assembly.LoadFile("要加载的文件的完全限定路径");
```
***
## 9.3 特性
- 特性是一种允许我们向程序的程序集添加元数据的语言结构, 它是用于保存程序结构信息的某种特殊类型的类

- 特性提供功能强大的方法以将声明信息与 C# 代码（类型、方法、属性等）相关联。特性与程序实体关联后，即可在运行时使用反射查询特性信息

- 特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集中, 它可以放置在几乎所有的声明中（类、变量、函数等等申明）

说人话：
- 特性本质是个类, 我们可以利用特性类为元数据添加额外信息
- 比如一个类、成员变量、成员方法等等为他们添加更多的额外信息, 之后可以通过反射来获取这些额外信息

### 自定义特性
- 继承特性基类 Attribute
- 命名时一般为 "名字 + Attribute"
```CSharp
class MyCustomAttribute : Attribute { }
```
### 使用
基本语法:
```CSharp
[特性名(参数列表)]
```
- 本质上 就是在调用特性类的构造函数
- 写在类、函数、变量上一行，表示他们具有该特性信息

**判断类是否使用了某个特性**
方法: *IsDefined*

```CSharp
MyClass mc = new MyClass();
Type t = mc.GetType();

//参数一：特性的类型
//参数二：代表是否搜索继承链（属性和事件忽略此参数）
if( t.IsDefined(typeof(MyCustomAttribute), false) )
{
    Console.WriteLine("该类型应用了MyCustom特性");
}
```

**获取Type元数据中的所有特性**
```CSharp
object[] array = t.GetCustomAttributes(true);
```

**限制自定义特性的使用范围**
通过为特性类 加特性 限制其使用范围

```CSharp
//参数一：AttributeTargets —— 特性能够用在哪些地方
//参数二：AllowMultiple —— 是否允许多个特性实例用在同一个目标上
//参数三：Inherited —— 特性是否能被派生类和重写成员继承
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = true)]
public class MyCustom2Attribute : Attribute { }
//所以这里的意思是
//MyCustom2Attribute 这个特性只用在类和结构体上, 
//能给同一个类加多个[MyCustom2],
//而且能被继承
```
### 系统自带特性——过时特性
过时特性: `Obsolete`
用于提示用户 使用的方法等成员已经过时 建议使用新方法, 一般加在函数前的特性
```CSharp
class TestClass
{
    //参数一：调用过时方法时 提示的内容
    //参数二：true-使用该方法时会报错  false-使用该方法时直接警告
    [Obsolete("OldSpeak方法已经过时了，请使用Speak方法", false)]
    public void OldSpeak(string str)
    {
        Console.WriteLine(str);
    }

    public void Speak()
    {

    }
}
```

### 系统自带特性——调用者信息特性
- 哪个文件调用？ `CallerFilePath`特性
- 哪一行调用？ `CallerLineNumber`特性
- 哪个函数调用？ `CallerMemberName`特性

需要引用命名空间 using System.Runtime.CompilerServices;
一般作为函数参数的特性

### 系统自带特性——条件编译特性
条件编译特性: `Conditional`
它会和预处理指令 #define配合使用

需要引用命名空间using System.Diagnostics;
主要可以用在一些调试代码上
有时想执行有时不想执行的代码

### 系统自带特性——外部Dll包函数特性
`DllImport`

用来标记非 .Net(C#)的函数，表明该函数在一个外部的DLL中定义。
一般用来调用 C或者C++的Dll包写好的方法
需要引用命名空间 using System.Runtime.InteropServices
***
# 10.迭代器
## 概念
- 迭代器（iterator）有时又称光标（cursor）
- 是程序设计的软件设计模式
- 迭代器模式提供一个方法顺序访问一个聚合对象中的各个元素
- 而又不暴露其内部的标识
</br>

- 在表现效果上看
- 是可以在容器对象（例如链表或数组）上遍历访问的接口
- 设计人员无需关心容器对象的内存分配的实现细节
- 可以用foreach遍历的类，都是实现了迭代器的

## 实现
- 关键接口：IEnumerator,IEnumerable
- 命名空间：using System.Collections;
- 可以通过同时继承IEnumerable和IEnumerator实现其中的方法
```CSharp
//这里的IEnumerable接口其实都可以不用写,foreach只看你有没有实现GetEnumerator()方法
class CustomList : IEnumerable
{
    private int[] list;

    public CustomList()
    {
        list = new int[] { 1, 2, 3, 4, 5, 6, 7, 8 };
    }

    public IEnumerator GetEnumerator() // 那这里就要去继承IEnumerator接口去实现其中的成员了
    {
        
    }
}

internal class Class1
{
    static void Main(string[] args)
    {
        CustomList list = new CustomList();
        //想要foreach遍历, 就必须让遍历的对象实现GetEnumerator()方法
        foreach (int item in list)
        {

        }
    }
}
```
## 需要实现的接口成员
- IEnumerator
```CSharp
public IEnumerator GetEnumerator()
```
- IEnumerable

```CSharp
object IEnumerator.Current => throw new NotImplementedException();
bool IEnumerator.MoveNext() 
void IEnumerator.Reset()
```

## foreach本质
1. 先获取in后面这个对象的 `IEnumerator`, 会调用对象其中的 `GetEnumerator` 方法 来获取
2. 执行得到这个 `IEnumerator` 对象中的 `MoveNext` 方法
3. 只要MoveNext方法的返回值时 `true` 就会去得到 `Current` , 然后复制给 `item`

知道本质后,我们再依次去实现相关的方法
```CSharp
// IEnumerable 实现
public IEnumerator GetEnumerator()
{
    Reset();
    return this;  // 返回自己作为迭代器
}

// IEnumerator 实现
public object Current
{
    get
    {
        if (position < 0 || position >= list.Length)
            throw new InvalidOperationException();
        return list[position];
    }
}

public bool MoveNext()
{
    position++;
    return position < list.Length;
}

public void Reset()
{
    position = -1;
}
```

## 用yield return 语法糖实现迭代器
上面是造轮子,下面我们直接来用系统提供的便捷的方法
- `yield return` 是C#提供给我们的语法糖
- 关键接口：`IEnumerable`
- 命名空间：`using System.Collections;`
- 让想要通过foreach遍历的自定义类实现接口中的方法`GetEnumerator`即可

```CSharp
class CustomList : IEnumerable
{
    private int[] list;

    public CustomList()
    {
        list = new int[] { 1, 2, 3, 4, 5, 6, 7, 8 };
    }

    public IEnumerator GetEnumerator()
    {
        for (int i = 0; i < list.Length; ++i)
        {
            yield return list[i];//可以理解为自动生成了上面的Current,MoveNext,Reset
        }
    }
}
```

***
# 11. 特殊语法

## 1. var
var是一种特殊的变量类型, 它可以用来表示任意类型的变量
说白了用法和C++的auto差不多,只是 auto 适用范围更广，可用于局部变量、函数参数等, var 的限制比较多

注意：
1. var不能作为类的成员 只能用于临时变量申明时, 也就是 一般写在函数语句块中
2. var必须初始化

## 2. 设置对象初始值
申明对象时, 可以通过直接写大括号的形式初始化公共成员变量和属性
```CSharp
class Person
{
    private int money;
    public bool sex;

    public string Name
    {
        get ;
        set ;
    }

    public int Age
    {
        get;
        set;
    }

    public Person(int money)
    {
        this.money = money;
    }
}

Person p = new Person(100) { sex = true, Age = 18, Name = "aaaa" };
```

## 3. 设置集合初始值
申明集合对象时, 也可以通过大括号 直接初始化内部属性
```CSharp
Dictionary<int, string> dic = new Dictionary<int, string>()
{
    { 1, "123" },
    { 2, "222"}
};
```

## 4. 匿名类型
var 变量可以申明为自定义的匿名类型, 声明的只能有成员变量, 不能有函数相关的内容
```CSharp
var v = new { age = 10, money = 11, name = "小明" };
Console.WriteLine(v.age);// 10
Console.WriteLine(v.name);// 小明
```

## 5. 可空类型
1. 值类型是不能赋值为 空的
    ```CSharp
    int c = null; // 这里会报错
    ```

2. 但是在申明时 在值类型后面加? 可以赋值为空
    ```CSharp
    int? c = 3;
    ```
3. 判断是否为空
    ```CSharp
    if( c.HasValue )
    ```
4. 
    ①.如果为空 默认返回值类型的默认值
    ```CSharp
    int? value = null;
    Console.WriteLine(value.GetValueOrDefault()); // 0
    ```
    ②.也可以指定一个默认值
    ```CSharp
    Console.WriteLine(value.GetValueOrDefault(100)); // 100
    ```
5. 对于引用类型
    相当于是一种语法糖 能够帮助我们自动去判断o是否为空
    ```CSharp
    object o = null;
    o?.ToString();
    ```
    上面的代码相当于
    ```CSharp
    if( o != null )
    {
        o.ToString();
    }
    ```
    在unity中会很常见,以下这样的例子
    ```CSharp
    Action action = null;
    action?.Invoke();
    ```
6. 空合并操作符
  空合并操作符 `??`, 语法为`左边值 ?? 右边值`
  如果左边值为null 就返回右边值 否则返回左边值, 只要是可以为null的类型都能用
    ```CSharp
    int? intV = null;
    int intI = intV ?? 100;
    ```
    相当于下面这句代码, 这里要注意一下,可空类型想要得到具体值,需要获取到该类型中的value成员,因为value里才是存的具体的值
    ```CSharp
    int intI = intV == null ? 100 : intV.Value;
    ```
## 7. 内插字符串
关键符号：`$`
用$来构造字符串，让字符串中可以拼接变量
```CSharp
string str = "没有后视镜的";
Console.WriteLine($"坦克是,{str}"); //输出  坦克是没有后视镜的
```

## 8. 单句逻辑简略写法
当循环或者if语句中只有 一句代码时 大括号可以省略
特殊的,对于属性和函数
```CSharp
class Person
{
    public string Name
    {
        get => "藤本树";
    }

    public void ChangeName(string name) => this.name = name;
}
```
***
# 12. 值类型和引用类型2
本节来更深入的讨论值类型和引用类型
首先需清楚值类型的实际内存在栈上, 而引用类型（如 string、class 等）的实例存储在堆上，而引用（变量本身）存储在栈上，引用中包含了堆上实例的地址
```CSharp
String str = "123";
//str的内存在栈上, 123的内存在堆上,只是让str这个栈内存里存储123这个堆内存的地址
```
## 1. 如何判断 值类型和引用类型
F12进到类型的内部去查看, 是 class 就是引用, 是 struct 就是值
这句话旨在当遇到别人写的类型时,通过该方法可以分辨出值和引用类型

但有一个特殊情况需要注意：
C# 中的字符串有字符串驻留（String Interning）机制，相同的字符串字面量会共享同一个堆内存实例，以节省空间。例如：
```CSharp
string a = "123";
string b = "123";
// a 和 b 指向堆上同一个 "123" 实例
```
另外，值类型作为引用类型的成员时，会随引用类型一起存储在堆上，例如：
```CSharp
class MyClass {
    public int Number; // 这个int会存储在堆上（因为是类的成员）
}
```
## 2. 语句块
我更喜欢叫它作用域,因为这个名字一听就知道和生命周期挂钩

命名空间
   ↓
类、接口、结构体
   ↓
函数、属性、索引器、运算符重载等（类、接口、结构体）
   ↓
条件分支、循环


- 上层语句块：类、结构体
- 中层语句块：函数
- 底层的语句块： 条件分支 循环等

我们的变量可以申明在哪里？
- 上、中、底都能申明变量
- 上层语句块中：成员变量
- 中、底层语句块中：临时变量

## 3. 变量的生命周期
编程时大部分都是 临时变量, 在中底层申明的临时变量（函数、条件分支、循环语句块等）, 语句块执行结束, 没有被记录的对象将被回收或变成垃圾

- 值类型：被系统自动回收
- 引用类型：栈上用于存地址的内存被系统自动回收，堆中具体内容变成垃圾，待下次GC回收

## 4. 结构体中的值和引用
结构体本身是值类型, 前提：该结构体没有做为其它类的成员
- 在结构体中的值，栈中存储值具体的内容
- 在结构体中的引用，堆中存储引用具体的内容

引用类型始终存储在堆中, 真正通过结构体使用其中引用类型时只是顺藤摸瓜
```CSharp
class Test{}

struct TetsStruct
{
    public Test t;
    public int i;
}
```
对于上面的代码来说, 结构体是值类型, 那它整体应该存在栈上, 但是这个`t`是引用类型, 它是堆上的, 那不是冲突了吗? 那这个`t`是怎么存的?

提出这样的问题是因为你没有理解上面的第一条的内容, 这里的t的内存是存在栈上的,所以不冲突

## 5. 类中的值和引用
类本身是引用类型
- 在类中的值，堆中存储具体的值
- 在类中的引用，堆中存储具体的值

值类型跟着大哥走，引用类型一根筋
```CSharp
class Test1 { }
class Test
{
    int b = 0;
    TetsStruct ts = new Struct;  //这里的b和ts就被存在了堆上了,即使它们是值类型

    // 这里没有初始化,所以内存是和上面的值类型是挨着的
    // 但是一旦new了对象之后,就会重新开辟一个堆内存,然后让t指向它
    Test1 t; 
}
```

## 6. 数组中的存储规则
数组本身是引用类型
- 值类型数组，堆中房间存具体内容
- 引用类型数组，堆中房间存地址

## 7. 结构体继承接口
利用里氏替换原则，用接口容器装载结构体存在装箱拆箱
先回顾一个知识: 结构体不能继承任何用户定义的类或结构体，但可以实现多个接口，同时隐式继承自 System.ValueType。
```CSharp
interface ITest{
    int Value{ get; set;}
}

struct TetsStruct : ITest
{
    int value;
    public int Value 
    {
        get
        {
            return value;
        }
        set
        {
            this.value = value;
        }
    }
}

TestStruct obj1 = new TestStruct();
obj1.Value = 1;

TestStruct obj2 = obj1;
obj2.Value = 2;

Console.WriteLine(obj1.Value);//1
Console.WriteLine(obj2.Value);//2

ITest iObj1 = obj1;//装箱  value 1
ITest iObj2 = iObj1;
iObj2.Value = 99;
Console.WriteLine(iObj1.Value);
Console.WriteLine(iObj2.Value);//都是99
```
***
