[toc]
***
# 1. 简单数据结构
***
## 1.1 ArrayList
在学习一个类的基本使用时,先看官方文档,对于使用技巧再去看别人的博客
[官方文档](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.arraylist?view=net-9.0)

**本质**
它的本质是一个object类型的数组

**命名空间**
需要`using System.Collections`

**增删改查**
以下都能在官方文档里查看,这里列出几个常用的

- 增
  - `Add()`       增加单个元素
  - `AddRange() ` 范围增加,把另一个容器里面的内容加到后面 
  - `Insert()`
- 删
  - `Remove()`    从头找
  - `RemoveAt()`
  - `Clear()`
- 查
  - `Contains()`  查看元素是否存在
  - `IndexOf()`   正向查找,找不到返回-1
  - `LastIndexOf()`   反向查找

**遍历**
普通遍历不讲了,讲迭代器遍历
```CSharp
static void Main(string[] args)
{
    ArrayList arr = new ArrayList();
    arr.Add("1234");    arr.Add(true);
    arr.Add("1234");    arr.Add(true);

    foreach (object item in arr)
    {
        Console.WriteLine(item);
    }
}
```

**装箱拆箱**
上面提到了ArrayList的本质,那它一定会有频繁的拆装箱,所以ArrayList尽量少用,后面有更好的容器,官方文档已经写出了上位替代了,可以看看
***
## 1.2 栈
本质也是object[]数组, 这里学的Stack不是泛型的,泛型的为`Stack<T>`,所以不用指定类型,啥都能存,下面的队列也是一样

**操作**
- 压栈: `Push()`
- 弹栈: `Pop()`
- 查看栈顶元素: `Peek()`,这里就和C++不一样了,C++是top()
- 查看元素是否在栈中: `Contains()`
- 清空: `Clear()`
- 查看长度: `Count`

**遍历**
- 用迭代器遍历,会从栈顶遍历到栈底
- 还可以将栈转换为Object数组,可以直接ToArray()

***
## 1.3 Queue
本质还是Object[]数组

**操作**
- 增加至队尾: `Enqueue()`
- 从队头取元素: `Dequeue()`
- 查看队头元素: `Peek()`
- 查看元素是否存在: `Contains()`
- 清空: `Clear()`
- 长度: `Count`

***
## 1.4 Hashtable
- 本质是基于键的哈希代码组织起来的 键值对
- 使用键来访问集合中的元素
- 不能出现相同的键


**操作**
- 增加元素: `Add(key, value) `
- 删除元素: `Remove(key)` 删除不存在的键是没反应的
- 清空: `Clear()`
- 检测键是否存在:`Contains(key)` / `ContainsKey(key)`
- 检测值是否存在: `ContainsValue`
- 键值对数: `Count`

**遍历**
1. 遍历所有键
```CSharp
foreach(object item in 哈希表名字.Keys)
```
2. 遍历所有值, 可以通过键来找到对应的值, 反过来不行
```CSharp
foreach(object item in 哈希表名字.Values)
```
3. 键值对一起遍历
```CSharp
foreach(DictionaryEntry item in 哈希表名字)
```
4. 迭代器遍历
```CSharp
IDictionaryEnumerator myEnumerator = hashtable.GetEnumerator();
bool flag = myEnumerator.MoveNext();
while (flag)
{
    Console.WriteLine("键：" + myEnumerator.Key + "值：" + myEnumerator.Value);
    flag = myEnumerator.MoveNext();
}
```
**装箱和拆箱**
- 往里面进行值类型存储就是在装箱
- 将值类型对象取出来转换使用时,就是在拆箱
***
# 2. 泛型
***
## 2.1 泛型
泛型实现了类型参数化, 通过类型参数化来实现同一份代码可以操作多种类型

泛型相当于类型占位符, 定义类或方法时使用替代符代表变量类型, 当真正使用类或者方法时再具体指定类型

### 泛型的分类
泛型占位字母可以有多个, 用逗号隔开

- 泛型类
```CSharp
class 类名<泛型占位字母>
```
- 泛型接口
```CSharp
interface 类名<泛型占位字母>
```
- 泛型函数
```CSharp
函数名<泛型占位字母>(参数列表)
```
### 泛型方法
对于泛型函数来说, 如果想得到该泛型类型的默认值, 如下:
```CSharp
public void TestFun<T>()
{
    T t = default(T);
}
```

**泛型类中的泛型方法**
```CSharp
class Test<T>
{
    public T value;
    //这个方法就不叫泛型方法了, 因为 T 在泛型类声明的时候就指定了
    //则它就不能再动态变化了
    public void TestFun(T t) { }
}
```
### 泛型的作用
1. 不同类型对象的相同逻辑处理就可以选择泛型
2. 使用泛型可以一定程度避免拆箱装箱
***
## 2.2 泛型约束

- 让泛型的类型有一定的限制
- 关键字: `where`
- 泛型约束一共有6种

这里分两个表格,看起来方便

| 值类型 |  引用类型 | 存在无参公共构造函数 | 
|--------|----------|---------------------|
|`where 泛型字母:struct`|`where 泛型字母:class`|`where 泛型字母:new()`|


| 某个类本身或者其派生类 | 某个接口的派生类型 | 另一泛型类型本身或者派生类型 | 
|--------|----------|---------------------|
|`where 泛型字母:类名`|`where 泛型字母:接口名`|`where 泛型字母:另一泛型字母`|

### 约束的组合使用
```CSharp
class Test<T> where T : class,new() { }
```
### 多个泛型有约束
```CSharp
class Test<T,K> where T : class,new() where K : struct { }
```
***
# 3. 常用泛型数据结构类
***
## 3.1 List
本质是一个可变类型的泛型数组

**命名空间**
`using System.Collections.Generic;`

**操作**
- 增: `Add()` / `AddRange()`
- 删: `Remove()` / `RemoveAt()`
- 存在: `Contains()`
- 正向查: `IndexOf()`
- 反向查: `LastIndexOf()`
- 长度: `Count`
- 容量: `Capacity`
***
## 3.2 Dictionary
可以理解为拥有泛型的Hashtable, 它也是基于键的哈希代码组织起来的键值对
键值对类型从Hashtable的object变成了可以自己指定的泛型

**声明**
```CSharp
Dictionary<int, string> dictionary = new Dictionary<int, string>();
```

**操作**
- 增: `Add()`
- 删: `Remove()`
- 键存在: `ContainsKey()`
- 值存在: `ContainsValue()`

**遍历**
这里以上面的声明的字典为例

1. 遍历所有键
```CSharp
foreach(int item in dictionary.Keys)
```
2. 遍历所有值, 可以通过键来找到对应的值, 反过来不行
```CSharp
foreach(string item in dictionary.Values)
```
3. 键值对一起遍历
```CSharp
foreach(KeyValuePair<int,string> item in dictionary)
```
***
## 3.3 顺序存储和链式存储

**数据结构**
一句话, 人定义的 存储数据 和 表示数据之间关系 的规则

**线性表** 
由n个具有相同特性的数据元素的优先序列

### 顺序存储
- 数组, Stack, Queue, List, ArratList
- 用一组地址连续的存储单元依次存储线性表的各个数据元素

### 链式存储
- 链表
- 用一组任意的存储单元存储线性表中的各个数据元素

### 顺序存储和链式存储的优缺点
从增删改查的角度思考
- 增: 链式存储 计算上 优于顺序存储(中间插入时链式不用像顺序一样去移动位置)
- 删: 链式存储 计算上 优于顺序存储(中间删除时链式不用像顺序一样去移动位置)
- 改: 顺序存储 使用上 优于链式存储(数组可以直接通过下标得到元素，链式需要遍历)
- 查: 顺序存储 使用上 优于链式存储(数组可以直接通过下标得到元素，链式需要遍历)
***
## 3.4 LinkedList
本质是一个可变类型的泛型双向链表

**操作**
- 链尾增加元素: `AddLast()`
- 链头增加元素: `AddFirst()`
- 移除头节点: `RemoveFirst()`
- 移除尾节点: `RemoveLast()`
- 移除指定节点: `Remove(value)`
- 头节点: `First`
- 尾节点: `Last`
- 找指定值的节点: `Find()`
  - 这里要注意了,这里返回的是节点,找不到返回空, 看这行代码就懂了
    ```CSharp
    LinkedListNode<int> node = linkedList.Find();
    ```
- 在某节点后加一个节点: `AddAfter(节点, value)`
  ```CSharp
  LinkedListNode<int> n = linkedLis.Find(20);
  linkedList.AddAfter(n, 15);
  ```
- 在某节点之前添加一个节点: `AddBefore(节点, value)`

**遍历**
- foreach遍历
```CSharp
foreach(int item in linkedList) { }
```
- 通过节点遍历
```CSharp
//从前往后
LinkedListNode<int> head = linkedList.First;
while(head != null) { head = head.Next; }

//从后往前
LinkedListNode<int> head = linkedList.Last;
while(head != null) { head = head.Previous; }
```
***
## 3.5 泛型栈和队列
在使用上和上面谈到的栈和队列一模一样,只是加了泛型
***
# 4.委托和事件
***
## 4.1委托
对于把函数当参数传递,我想起[C++里的函数指针](https://www.bilibili.com/video/BV1254y1h7Ha?spm_id_from=333.788.videopod.sections&vd_source=e5ff09f1c2b416e099232ca31ec5028d), 有兴趣可以去看看

- 委托是函数的容器, 可以理解为表示函数的变量类型, 用来存储和传递函数, 委托的本质是一个类, 用来定义函数的类型(返回值和参数的类型)
- 不同的函数必须对应和各自"格式"一致的委托

### 语法
- 关键字: delegate
- 语法: `访问修饰符 delegate 返回值 委托名(参数列表); `
- 写在namespace和class语句块中, 在namespace中居多

**自定义委托**
- 访问修饰符一般不写, 默认为public, 在别的命名空间中能使用
- 设为private后,其他命名空间就不能用了 


这里只是声明了一个可以用来存储无参无返回值函数的容器
这里只是定义了规则, 并没有使用
```CSharp
delegate void MyFun();
```
同一作用域中,委托规则的声明不可以重名

**泛型委托**
```CSharp
delegate T MyFun()
```
### 使用

```CSharp
namespace _08委托
{
    delegate void Del();
    delegate int Del2(int a);
    internal class Class1
    {
        static void Fun()
        {
            Console.WriteLine("123123");
        }

        static int Fun2(int value)
        {
            return value;
        }

        static void Main(string[] args)
        {
            //下面两种声明其实是差不多的
            Del del1 = new Del(Fun);
            Del2 del2 = Fun2;

            //调用委托, 下面两种调用其实是差不多的
            del1.Invoke();
            del2(5);
        }
    }
}
```
以上委托的使用是比较罕见的,委托常用在:
- 作为类的成员
- 作为函数的参数

假如某一函数中有一个变量,且只能在这个函数里创建并处理逻辑,处理完后然后再传给委托处理这个数, 以上实现就需要委托了

```CSharp
namespace _08委托
{
    delegate int Calculate(int a);

    class Test
    {
        public Calculate cal;
        public void TestFun(Calculate cal)
        {
            int i = 10;

            //假装处理一些逻辑
            i += 10;

            cal(i);
        }
    }

    internal class Class1
    {
        public static int Function(int value) 
        {
            Console.WriteLine(value);
            return value; 
        }
        static void Main(string[] args)
        {
            Calculate cal = new Calculate(Function);
            Test t = new Test();
            t.TestFun(cal); // 输出 20
        }
    }
}
```
以上这种先处理一些逻辑后,再通过前面处理过的结果,靠委托去批量的处理另一些逻辑,这种思想就是[观察者模式](https://design-patterns.readthedocs.io/zh-cn/latest/behavioral_patterns/observer.html)的雏形了


**这块可以不用看,但是看了能加深理解**
看完并理解上面的代码后, 先聚焦在`TestFun()`方法上, 想一想这种场景:
- 你的目的是将这个只能声明在`TestFun()`方法中的变量`i`处理一些逻辑后再交给`Function()`去处理逻辑
- 这个`i`只能定义在`TestFun()`方法中,所以只要出`TestFun()`方法的作用域后就会自动销毁
</br>

- 在不用委托的条件下,要怎么完成你的目的? 
- 那只能把`i`提出`TestFun()`,提到和`Function()`同一作用域及以上,提升它的生命周期
- 然后把它放到`TestFun()`的参数列表里,处理完逻辑之后,再传给`Function()`继续处理,但这也同时违背了 "只能声明在`TestFun()`方法中" 这一条件
- 上面内容看着抽象吧, 看下面代码

```CSharp
class Test
{
    public void TestFun(ref int i)
    {
        i += 10;
    }
}

internal class Class1
{
    public static int Function(int value) 
    {
        Console.WriteLine(value);
        return value; 
    }
    static void Main(string[] args)
    {
        int i = 10;
        Test t = new Test();
        t.TestFun(ref i);
        Function(i);//输出20 
    }
}
```
- 缺点就是你不知道你的`i`会不会被其他的函数干扰
**这块结束**

### 多播委托
人话这一块: 委托变量可以存储多个函数

**增: `+=`**
```CSharp
delegate void TestDel(int a);

internal class Class1
{
    public static void TestFun(int value) 
    {
        Console.WriteLine(value);
    }
    public static void TestFun2(int value) 
    {
        value -= 5;
        Console.WriteLine(value);
    }
    static void Main(string[] args)
    {
        TestDel del = TestFun;
        del += TestFun2;
        del(10);//这里会输出两行  第一行 10    第二行  5
    }
}
```
上面代码有个优化的地方
```CSharp
TestDel del = TestFun;//这里不能改为+=
del += TestFun2;
```
但是你在初始化委托的时候设置为空,那就可以统一增加函数的方式
```CSharp
TestDel del = null;
del += TestFun; // del = del + TestFun; 这样写也行
del += TestFun2;
```
而在委托执行的时候也是按照添加的顺序去执行,可以理解为先进先出

**删: `-=`**
理解上面的增了后,删也就好说了
值得一提的是,当你删除委托中没有的函数时,不会报错,只是没反应而已

### 系统定义好的委托
需要`using System`

- **Action**
代表**无参无返回值**的委托
  ```CSharp
  delegate void MyDel();
  static void Fun() { }

  //这两句作用是一样的
  Action action = Fun;
  MyDel action = Fun;
  ```
- **Func\<out T>**
  代表**无参返回值类型为T**的委托
  ```CSharp
  public static int TestFun3() {  return 1; }
  Func<int> func = TestFun3;
  ```
- **Action\<in T>**
代表 可以传多个参数的**有参无返回值**的委托,最多传16个参数

- **Func\<in T,out TResult>**
代表 可以传多个参数的**有参有返回值**的委托,最多传16个参数
尖括号中的最后一个参数永远是返回值类型  
***