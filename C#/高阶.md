[toc]
***
# 1. 简单数据结构
***
## 1.1 ArrayList
在学习一个类的基本使用时,先看官方文档,对于使用技巧再去看别人的博客
[官方文档](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.arraylist?view=net-9.0)

**本质**
它的本质是一个object类型的数组

**命名空间**
需要`using System.Collections`

**增删改查**
以下都能在官方文档里查看,这里列出几个常用的

- 增
  - `Add()`       增加单个元素
  - `AddRange() ` 范围增加,把另一个容器里面的内容加到后面 
  - `Insert()`
- 删
  - `Remove()`    从头找
  - `RemoveAt()`
  - `Clear()`
- 查
  - `Contains()`  查看元素是否存在
  - `IndexOf()`   正向查找,找不到返回-1
  - `LastIndexOf()`   反向查找

**遍历**
普通遍历不讲了,讲迭代器遍历
```CSharp
static void Main(string[] args)
{
    ArrayList arr = new ArrayList();
    arr.Add("1234");    arr.Add(true);
    arr.Add("1234");    arr.Add(true);

    foreach (object item in arr)
    {
        Console.WriteLine(item);
    }
}
```

**装箱拆箱**
上面提到了ArrayList的本质,那它一定会有频繁的拆装箱,所以ArrayList尽量少用,后面有更好的容器,官方文档已经写出了上位替代了,可以看看
***
## 1.2 栈
本质也是object[]数组, 这里学的Stack不是泛型的,泛型的为`Stack<T>`,所以不用指定类型,啥都能存,下面的队列也是一样

**操作**
- 压栈: `Push()`
- 弹栈: `Pop()`
- 查看栈顶元素: `Peek()`,这里就和C++不一样了,C++是top()
- 查看元素是否在栈中: `Contains()`
- 清空: `Clear()`
- 查看长度: `Count`

**遍历**
- 用迭代器遍历,会从栈顶遍历到栈底
- 还可以将栈转换为Object数组,可以直接ToArray()

***
## 1.3 Queue
本质还是Object[]数组

**操作**
- 增加至队尾: `Enqueue()`
- 从队头取元素: `Dequeue()`
- 查看队头元素: `Peek()`
- 查看元素是否存在: `Contains()`
- 清空: `Clear()`
- 长度: `Count`

***
## 1.4 Hashtable
- 本质是基于键的哈希代码组织起来的 键值对
- 使用键来访问集合中的元素
- 不能出现相同的键


**操作**
- 增加元素: `Add(key, value) `
- 删除元素: `Remove(key)` 删除不存在的键是没反应的
- 清空: `Clear()`
- 检测键是否存在:`Contains(key)` / `ContainsKey(key)`
- 检测值是否存在: `ContainsValue`
- 键值对数: `Count`

**遍历**
1. 遍历所有键
```CSharp
foreach(object item in 哈希表名字.Keys)
```
2. 遍历所有值, 可以通过键来找到对应的值, 反过来不行
```CSharp
foreach(object item in 哈希表名字.Values)
```
3. 键值对一起遍历
```CSharp
foreach(DictionaryEntry item in 哈希表名字)
```
4. 迭代器遍历
```CSharp
IDictionaryEnumerator myEnumerator = hashtable.GetEnumerator();
bool flag = myEnumerator.MoveNext();
while (flag)
{
    Console.WriteLine("键：" + myEnumerator.Key + "值：" + myEnumerator.Value);
    flag = myEnumerator.MoveNext();
}
```
**装箱和拆箱**
- 往里面进行值类型存储就是在装箱
- 将值类型对象取出来转换使用时,就是在拆箱
***
# 2. 泛型
***
## 2.1 泛型
泛型实现了类型参数化, 通过类型参数化来实现同一份代码可以操作多种类型

泛型相当于类型占位符, 定义类或方法时使用替代符代表变量类型, 当真正使用类或者方法时再具体指定类型

### 泛型的分类
泛型占位字母可以有多个, 用逗号隔开

- 泛型类
```CSharp
class 类名<泛型占位字母>
```
- 泛型接口
```CSharp
interface 类名<泛型占位字母>
```
- 泛型函数
```CSharp
函数名<泛型占位字母>(参数列表)
```
### 泛型方法
对于泛型函数来说, 如果想得到该泛型类型的默认值, 如下:
```CSharp
public void TestFun<T>()
{
    T t = default(T);
}
```

**泛型类中的泛型方法**
```CSharp
class Test<T>
{
    public T value;
    //这个方法就不叫泛型方法了, 因为 T 在泛型类声明的时候就指定了
    //则它就不能再动态变化了
    public void TestFun(T t) { }
}
```
### 泛型的作用
1. 不同类型对象的相同逻辑处理就可以选择泛型
2. 使用泛型可以一定程度避免拆箱装箱
***
## 2.2 泛型约束

- 让泛型的类型有一定的限制
- 关键字: `where`
- 泛型约束一共有6种

这里分两个表格,看起来方便

| 值类型 |  引用类型 | 存在无参公共构造函数 | 
|--------|----------|---------------------|
|`where 泛型字母:struct`|`where 泛型字母:class`|`where 泛型字母:new()`|


| 某个类本身或者其派生类 | 某个接口的派生类型 | 另一泛型类型本身或者派生类型 | 
|--------|----------|---------------------|
|`where 泛型字母:类名`|`where 泛型字母:接口名`|`where 泛型字母:另一泛型字母`|

### 约束的组合使用
```CSharp
class Test<T> where T : class,new() { }
```
### 多个泛型有约束
```CSharp
class Test<T,K> where T : class,new() where K : struct { }
```
***
# 3. 常用泛型数据结构类
***
## 3.1 List
本质是一个可变类型的泛型数组

**命名空间**
`using System.Collections.Generic;`

**操作**
- 增: `Add()` / `AddRange()`
- 删: `Remove()` / `RemoveAt()`
- 存在: `Contains()`
- 正向查: `IndexOf()`
- 反向查: `LastIndexOf()`
- 长度: `Count`
- 容量: `Capacity`
***
## 3.2 Dictionary
可以理解为拥有泛型的Hashtable, 它也是基于键的哈希代码组织起来的键值对
键值对类型从Hashtable的object变成了可以自己指定的泛型

**声明**
```CSharp
Dictionary<int, string> dictionary = new Dictionary<int, string>();
```

**操作**
- 增: `Add()`
- 删: `Remove()`
- 键存在: `ContainsKey()`
- 值存在: `ContainsValue()`

**遍历**
这里以上面的声明的字典为例

1. 遍历所有键
```CSharp
foreach(int item in dictionary.Keys)
```
2. 遍历所有值, 可以通过键来找到对应的值, 反过来不行
```CSharp
foreach(string item in dictionary.Values)
```
3. 键值对一起遍历
```CSharp
foreach(KeyValuePair<int,string> item in dictionary)
```
***
## 3.3 顺序存储和链式存储

**数据结构**
一句话, 人定义的 存储数据 和 表示数据之间关系 的规则

**线性表** 
由n个具有相同特性的数据元素的优先序列

### 顺序存储
- 数组, Stack, Queue, List, ArratList
- 用一组地址连续的存储单元依次存储线性表的各个数据元素

### 链式存储
- 链表
- 用一组任意的存储单元存储线性表中的各个数据元素

### 顺序存储和链式存储的优缺点
从增删改查的角度思考
- 增: 链式存储 计算上 优于顺序存储(中间插入时链式不用像顺序一样去移动位置)
- 删: 链式存储 计算上 优于顺序存储(中间删除时链式不用像顺序一样去移动位置)
- 改: 顺序存储 使用上 优于链式存储(数组可以直接通过下标得到元素，链式需要遍历)
- 查: 顺序存储 使用上 优于链式存储(数组可以直接通过下标得到元素，链式需要遍历)
***
## 3.4 LinkedList
本质是一个可变类型的泛型双向链表

**操作**
- 链尾增加元素: `AddLast()`
- 链头增加元素: `AddFirst()`
- 移除头节点: `RemoveFirst()`
- 移除尾节点: `RemoveLast()`
- 移除指定节点: `Remove(value)`
- 头节点: `First`
- 尾节点: `Last`
- 找指定值的节点: `Find()`
  - 这里要注意了,这里返回的是节点,找不到返回空, 看这行代码就懂了
    ```CSharp
    LinkedListNode<int> node = linkedList.Find();
    ```
- 在某节点后加一个节点: `AddAfter(节点, value)`
  ```CSharp
  LinkedListNode<int> n = linkedLis.Find(20);
  linkedList.AddAfter(n, 15);
  ```
- 在某节点之前添加一个节点: `AddBefore(节点, value)`

**遍历**
- foreach遍历
```CSharp
foreach(int item in linkedList) { }
```
- 通过节点遍历
```CSharp
//从前往后
LinkedListNode<int> head = linkedList.First;
while(head != null) { head = head.Next; }

//从后往前
LinkedListNode<int> head = linkedList.Last;
while(head != null) { head = head.Previous; }
```
***
## 3.5 泛型栈和队列
在使用上和上面谈到的栈和队列一模一样,只是加了泛型
***
# 4. 委托和事件
***
## 4.1 委托
对于把函数当参数传递,我想起[C++里的函数指针](https://www.bilibili.com/video/BV1254y1h7Ha?spm_id_from=333.788.videopod.sections&vd_source=e5ff09f1c2b416e099232ca31ec5028d), 有兴趣可以去看看

- 委托是函数的容器, 可以理解为表示函数的变量类型, 用来存储和传递函数, 委托的本质是一个类, 用来定义函数的类型(返回值和参数的类型)
- 不同的函数必须对应和各自"格式"一致的委托

### 语法
- 关键字: delegate
- 语法: `访问修饰符 delegate 返回值 委托名(参数列表); `
- 写在namespace和class语句块中, 在namespace中居多

**自定义委托**
- 访问修饰符一般不写, 默认为public, 在别的命名空间中能使用
- 设为private后,其他命名空间就不能用了 


这里只是声明了一个可以用来存储无参无返回值函数的容器
这里只是定义了规则, 并没有使用
```CSharp
delegate void MyFun();
```
同一作用域中,委托规则的声明不可以重名

**泛型委托**
```CSharp
delegate T MyFun()
```
### 使用

```CSharp
namespace _08委托
{
    delegate void Del();
    delegate int Del2(int a);
    internal class Class1
    {
        static void Fun()
        {
            Console.WriteLine("123123");
        }

        static int Fun2(int value)
        {
            return value;
        }

        static void Main(string[] args)
        {
            //下面两种声明其实是差不多的
            Del del1 = new Del(Fun);
            Del2 del2 = Fun2;

            //调用委托, 下面两种调用其实是差不多的
            del1.Invoke();
            del2(5);
        }
    }
}
```
以上委托的使用是比较罕见的,委托常用在:
- 作为类的成员
- 作为函数的参数

假如某一函数中有一个变量,且只能在这个函数里创建并处理逻辑,处理完后然后再传给委托处理这个数, 以上实现就需要委托了

```CSharp
namespace _08委托
{
    delegate int Calculate(int a);

    class Test
    {
        public Calculate cal;
        public void TestFun(Calculate cal)
        {
            int i = 10;

            //假装处理一些逻辑
            i += 10;

            cal(i);
        }
    }

    internal class Class1
    {
        public static int Function(int value) 
        {
            Console.WriteLine(value);
            return value; 
        }
        static void Main(string[] args)
        {
            Calculate cal = new Calculate(Function);
            Test t = new Test();
            t.TestFun(cal); // 输出 20
        }
    }
}
```
以上这种先处理一些逻辑后,再通过前面处理过的结果,靠委托去批量的处理另一些逻辑,这种思想就是[观察者模式](https://design-patterns.readthedocs.io/zh-cn/latest/behavioral_patterns/observer.html)的雏形了


**这块可以不用看,但是看了能加深理解**

看完并理解上面的代码后, 先聚焦在`TestFun()`方法上, 想一想这种场景:
- 你的目的是将这个只能声明在`TestFun()`方法中的变量`i`处理一些逻辑后再交给`Function()`去处理逻辑
- 这个`i`只能定义在`TestFun()`方法中,所以只要出`TestFun()`方法的作用域后就会自动销毁
</br>

- 在不用委托的条件下,要怎么完成你的目的? 
- 那只能把`i`提出`TestFun()`,提到和`Function()`同一作用域及以上,提升它的生命周期
- 然后把它放到`TestFun()`的参数列表里,处理完逻辑之后,再传给`Function()`继续处理,但这也同时违背了 "只能声明在`TestFun()`方法中" 这一条件
- 上面内容看着抽象吧, 看下面代码

```CSharp
class Test
{
    public void TestFun(ref int i)
    {
        i += 10;
    }
}

internal class Class1
{
    public static int Function(int value) 
    {
        Console.WriteLine(value);
        return value; 
    }
    static void Main(string[] args)
    {
        int i = 10;
        Test t = new Test();
        t.TestFun(ref i);
        Function(i);//输出20 
    }
}
```
- 缺点就是你不知道你的`i`会不会被其他的函数干扰

**这块结束**

### 多播委托
人话这一块: 委托变量可以存储多个函数

**增: `+=`**
```CSharp
delegate void TestDel(int a);

internal class Class1
{
    public static void TestFun(int value) 
    {
        Console.WriteLine(value);
    }
    public static void TestFun2(int value) 
    {
        value -= 5;
        Console.WriteLine(value);
    }
    static void Main(string[] args)
    {
        TestDel del = TestFun;
        del += TestFun2;
        del(10);//这里会输出两行  第一行 10    第二行  5
    }
}
```
上面代码有个优化的地方
```CSharp
TestDel del = TestFun;//这里不能改为+=
del += TestFun2;
```
但是你在初始化委托的时候设置为空,那就可以统一增加函数的方式
```CSharp
TestDel del = null;
del += TestFun; // del = del + TestFun; 这样写也行
del += TestFun2;
```
而在委托执行的时候也是按照添加的顺序去执行,可以理解为先进先出

**删: `-=`**
理解上面的增了后,删也就好说了
值得一提的是,当你删除委托中没有的函数时,不会报错,只是没反应而已

### 系统定义好的委托
需要`using System`

- **Action**
代表**无参无返回值**的委托
  ```CSharp
  delegate void MyDel();
  static void Fun() { }

  //这两句作用是一样的
  Action action = Fun;
  MyDel action = Fun;
  ```
- **Func\<out T>**
  代表**无参返回值类型为T**的委托
  ```CSharp
  public static int TestFun3() {  return 1; }
  Func<int> func = TestFun3;
  ```
- **Action\<in T>**
代表 可以传多个参数的**有参无返回值**的委托,最多传16个参数
</br>

- **Func\<in T,out TResult>**
代表 可以传多个参数的**有参有返回值**的委托,最多传16个参数
尖括号中的最后一个参数永远是返回值类型  
***
## 4.2 事件
### 概念
事件是一种特殊的变量类型, 是委托的安全包裹, 让委托的使用更有安全性

### 使用
**语法**
```CSharp
访问修饰符 event 委托类型 事件名;
```

**使用**
- 事件是**作为成员存在于类中**的,委托怎么用,事件就怎么用
- 它只能作为成员存在与类,接口以及结构体中

**与委托的区别**
1. 不能在类外部赋值
2. 不能在类外部调用
3. 事件不能作为临时变量在函数中使用,委托可以


- 委托可以在外部赋值,而事件不能在外部赋值,只能通过`+=`和`-=`去添加和移除事件里记录的函数
- 事件不能在外部调用,所以也就不存在以下的代码
```CSharp
class Test
{
    public event Action myEvent;
}
internal class Class1
{
    static void Main(string[] args)
    {
        Test t = new Test();
        //以下两句代码是会报错的
        t.myEvent();
        t.myEvent.Invoke();
    }
}
```
- 如果你想在外部调用那只能这么写

```CSharp
class Test
{
    public event Action myEvent;

    public void DoEvent()
    {
        myEvent();
    }
}
internal class Class1
{
    static void Main(string[] args)
    {
        Test t = new Test();
        t.DoEvent();
    }
}
```
### 为什么会有事件
1. 防止外部随意置空委托
2. 防止外部随意调用委托
3. 事件相当于对委托进行了一次封装,让其更加安全
***
## 4.3 匿名函数
- C++是不一样的,[匿名函数一般在需要快速创建一个一次性的函数时使用](https://www.bilibili.com/video/BV195411A7KX?spm_id_from=333.788.videopod.sections&vd_source=e5ff09f1c2b416e099232ca31ec5028d)

- 没有名字的函数,匿名函数的使用主要是配合委托和事件进行使用
- **脱离委托和事件是不会使用匿名函数的**

### 语法
```CSharp
delegate (参数列表)
{
    //逻辑
}
```
1. 函数中传递委托参数时
2. 委托或事件赋值时

### 使用
- 当你声明了一个匿名函数时,需要用委托或者事件装载起来,不然会报错
- 调用匿名函数是通过调用委托来实现
```CSharp
Action a = delegate() { };
```
- 写个例子
```CSharp
Action<int> a = delegate (int a)
{
    Console.WriteLine("匿名函数");
};
```
- 一般作为函数参数传递 或者 作为函数返回值
### 匿名函数的缺点
- 添加到委托或者事件容器中后 不记录 无法单独移除
- 因为匿名函数没有名字,所以不能用`-=`去指定移除
***
## 4.4 Lambda表达式
可以理解为匿名函数的简写,除了写法不同外,使用上和匿名函数一模一样
```CSharp
(参数列表) => { 函数体 };
```
### 使用
- 举个例子
```CSharp
Action<int> a = (int num) => 
{ 
    //写逻辑
};
```
- 你甚至还可以连参数类型都不写
```CSharp
Action<int> a = (num) =>
{
    Console.WriteLine("num: {0}", num);
};

a(5);//输出 num: 5
```

### 闭包
**内层的函数可以引用包含在它外层的函数的变量, 即使外层函数的执行已经终止**
```CSharp
class Test
{
    public event Action action;

    //外层函数
    public Test()
    {
        //外层函数的变量
        int value = 5;
        //内层函数
        action = () =>
        {
            Console.WriteLine("value: {0}", value);
        };
    }

    public void DoSomething()
    {
        action();
    }
}

internal class Class1
{
    static void Main(string[] args)
    {
        Test t = new Test();
        t.DoSomething();
    }
}
```
ok,我们来分析一下上面的代码,如果构造函数只写成这样
```CSharp
public Test() { int value = 5; }
```
那很明显,value出作用域后就会被销毁,但是像上面代码所示,把`value`放进了闭包,`value`的生命周期就变了
本来在这句代码执行完的时候,`value`就访问不到了
```CSharp
Test t = new Test();
```
但是你会发现这句代码照样调用了变量`value`
```CSharp
t.DoSomething();
```
我们一点点来捋一下,`action`这个事件是和`Test`对象同生命周期的,在构造函数中,将调用了`value`的匿名函数加入到了`action`中,这里就将`value`这个变量的生命周期拉长到了`action`同等生命周期(因为匿名函数不能指定移除,但是可以提前清空`action`容器,当你清空`action`时,那么此时`value`的生命周期就结束了),所以在`DoSomething`方法中可以正常的调用事件`action`

那么我们再进一步想一个问题,明明内存在栈上的`value`,为什么不会被自动销毁,反而生命周期还变长了?
- 答案已经很明显了,`value`的内存被提升到堆了
- 当匿名函数（`lambda`表达式）捕获了外部变量（如`value`）时，C#编译器会生成一个类来封装这些变量，从而延长其生命周期。捕获的变量不再位于栈上，而是被提升到堆中（由编译器生成的闭包类管理）。
- 被捕获的变量（`value`）的生命周期不再局限于构造函数的作用域，而是与捕获它的委托的生命周期相同。只要委托实例存在，该变量就不会被垃圾回收。


**该变量提供的值并非变量创建时的值,而是在父函数范围内的最终值**
```CSharp
class Test
{
    public event Action action;

    public Test()
    {
        for (int i = 0; i < 10; ++i)
        {
            action += () => { Console.Write(i + " "); };
        }
    }

    public void DoSomething()
    {
        action();
    }
}

internal class Class1
{
    static void Main(string[] args)
    {
        Test t = new Test();
        t.DoSomething();//输出 10 10 10 10 10 10 10 10 10 10
    }
}
```
这又是为什么? 我们再来捋一捋

当编译器遇到循环中的lambda表达式时,它发现lambda捕获了循环变量 i, 编译器会生成一个闭包类来存储被捕获的变量, 也就是说这句代码往action里加的 i 是同一个变量, 循环变量 i 在闭包中被共享（所有lambda都引用同一个变量）
```CSharp
action += () => { Console.Write(i + " "); };
```

那应该怎么解决呢? 
- 用一个变量去存储每个状态下的变量 i 就行了
```CSharp
public Test()
{
    for (int i = 0; i < 10; ++i)
    {
        int temp = i;  // 创建局部副本
        action += () => { Console.Write(temp + " "); };
    }
}
```
***